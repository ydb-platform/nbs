name: Check github workflow

on:
  pull_request:
    branches:
      - main
    paths:
    - ".github/**"
    types:
      - 'opened'
      - 'synchronize'
      - 'reopened'
      - 'labeled'
  workflow_dispatch:
    inputs:
      allow_downgrade:
        description: 'Allow downgrade'
        required: false
        type: choice
        default: "no"
        options:
          - "yes"
          - "no"
      large_tests:
        description: 'Launch large tests'
        required: false
        type: choice
        default: "no"
        options:
          - "yes"
          - "no"

permissions:
  contents: read
  pull-requests: write
  issues: write

defaults:
  run:
    shell: bash

env:
  allow_downgrade: ${{ vars.GLOBAL_ALLOW_DOWNGRADE == 'yes' || ((github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'allow-downgrade')) || inputs.allow_downgrade == 'yes') }}
  large_tests: ${{ (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'large-tests'))  && 'true' || inputs.large_tests == 'yes' }}

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  set-env:
    runs-on: [self-hosted, "self-hosted", "runner_light"]
    outputs:
      allow_downgrade: ${{ env.allow_downgrade == 'false' && 'no' || 'yes' }}
      large_tests: ${{ env.large_tests == 'false' && 'no' || 'yes' }}
    # we don't need anything, but otherwise github will complain
    steps:
      - name: set env
        id: set-env
        run: echo
  check-running-allowed:
    runs-on: [self-hosted, "self-hosted", "runner_light"]
    outputs:
      result: ${{ steps.check-ownership-membership.outputs.result }}
    steps:
      - name: Check if running tests is allowed
        id: check-ownership-membership
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PERSONAL_ACCESS_TOKEN }}
          script: |
            async function isOrgMember(owner, username) {
              core.info(`Checking membership for user: ${username}`);
              try {
                const { data: membership } = await github.rest.orgs.getMembershipForUser({
                  org: owner,
                  username
                });
                if (membership?.state === 'active') {
                  core.info(`${username} is confirmed as an org member`);
                  return true;
                } else {
                  core.info(`${username} is not an active org member (state: ${membership?.state})`);
                  return false;
                }
              } catch (error) {
                // Often the call fails if the user isn't in the org or it's private
                core.error(`Error checking membership for user ${username}: ${error.message}`);
                return false;
              }
            }

            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const prAuthor = context.payload.pull_request.user.login;

            core.info(`Starting membership check for PR #${prNumber} by @${prAuthor}`);

            const authorIsOrgMember = await isOrgMember(owner, prAuthor);
            if (authorIsOrgMember) {
              core.info(`User @${prAuthor} is org member => authorized`);
              return true;
            }

            core.info(`User @${prAuthor} is NOT an org member; checking for 'ok-to-test' label`);

            let events;
            try {
              const resp = await github.rest.issues.listEvents({
                owner,
                repo,
                issue_number: prNumber
              });
              events = resp.data;
            } catch (error) {
              core.error(`Error fetching issue events: ${error.message}`);
              return false;
            }

            // Find last 'labeled' event for 'ok-to-test'
            const labeledOkToTest = events
              .filter(e => e.event === 'labeled' && e.label?.name === 'ok-to-test')
              .pop();

            if (!labeledOkToTest) {
              core.info("No 'ok-to-test' label found on this PR");
              return false;
            }

            core.info(`Found 'ok-to-test' label event by @${labeledOkToTest.actor.login}, verifying if they are an org member...`);

            const labelerLogin = labeledOkToTest.actor.login;
            const labelerIsOrgMember = await isOrgMember(owner, labelerLogin);
            if (!labelerIsOrgMember) {
              core.info(`User @${labelerLogin} who labeled 'ok-to-test' is not an org member => not authorized`);
              return false;
            }

            core.info(`'ok-to-test' label added by an org member => authorized`);
            return true
      - name: comment-if-waiting-on-ok
        if: steps.check-ownership-membership.outputs.result == 'false' &&
            github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'Hi! Thank you for contributing!\nThe tests on this PR will run after a maintainer adds an `ok-to-test` label to this PR manually. Thank you for your patience!'
            });
      - name: cleanup-labels
        uses: actions/github-script@v7
        with:
          script: |
            let labelsToRemove = ['ok-to-test', 'recheck'];
            const prNumber = context.payload.pull_request.number;
            const prLabels = new Set(context.payload.pull_request.labels.map(l => l.name));
            for await (const label of labelsToRemove.filter(l => prLabels.has(l))) {
              core.info(`remove label=${label} for pr=${prNumber}`);
              try {
                const result = await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number: prNumber,
                  name: label
                });
              } catch(error) {
                // ignore the 404 error that arises
                // when the label did not exist for the
                // organization member
                if (error.status && error.status != 404) {
                  throw error;
                }
              }
            }
  shell:
    needs: [set-env, check-running-allowed]
    if: needs.check-running-allowed.outputs.result == 'true'
    runs-on: [self-hosted, "self-hosted", "runner_light"]

    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          submodules: false
          sparse-checkout: '.github'

      - name: get reporter name
        uses: haya14busa/action-cond@v1
        id: reporter
        with:
          cond: ${{ github.event_name == 'pull_request' }}
          if_true: "github-pr-review"
          if_false: "github-check"

      - name: set up dependencies
        run: pip install -r .github/scripts/requirements_dev.txt

      - name: generate shellscripts from github actions
        run: |
          python3 .github/scripts/shell_extractor.py
          find .temporary/ -type f -name "*.sh";

      - name: shellcheck for .github dir
        uses: ludeeus/action-shellcheck@master
        with:
          scandir: .github
        env:
          SHELLCHECK_OPTS: "-e SC2155,SC2086"


      - name: shellcheck for github actions shell scripts in .temporary dir
        uses: ludeeus/action-shellcheck@master
        env:
          SHELLCHECK_OPTS: "-e SC2155,SC2086"
        with:
          scandir: .temporary

      - name: shfmt
        uses: librarian/action-shfmt@v0.0.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workdir: .github/
          shfmt_flags: "-i 4 -ci -kp -bn -sr"

  python:
    needs: [set-env, check-running-allowed]
    if: needs.check-running-allowed.outputs.result == 'true'
    runs-on: [self-hosted, "self-hosted", "runner_light"]

    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          submodules: false
          sparse-checkout: '.github'

      - name: get reporter name
        uses: haya14busa/action-cond@v1
        id: reporter
        with:
          cond: ${{ github.event_name == 'pull_request' }}
          if_true: "github-pr-review"
          if_false: "github-check"

      - name: Prepare s3
        id: s3
        uses: ./.github/actions/s3cmd
        with:
          s3_bucket: ${{ vars.POOLED_LIGHT_AWS_BUCKET }}
          s3_endpoint: ${{ vars.POOLED_LIGHT_AWS_ENDPOINT }}
          s3_website_suffix: ${{ vars.POOLED_LIGHT_AWS_WEBSITE_SUFFIX }}
          s3_key_id: ${{ secrets.POOLED_LIGHT_AWS_KEY_ID }}
          s3_key_secret: ${{ secrets.POOLED_LIGHT_AWS_SECRET_KEY }}
          folder_prefix: nebius-
          build_preset: "relwithdebinfo"
          install: false

      - name: set up python environment
        uses: actions/setup-python@v5.0.0
        with:
          python-version: "3.10"

      - name: set up dependencies
        run: |
          pip install -r .github/scripts/requirements.txt
          pip install -r .github/scripts/requirements_dev.txt

      - name: flake8
        uses: reviewdog/action-flake8@v3.8.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workdir: .github/
          reporter: ${{ steps.reporter.outputs.value }}
          flake8_args: "--max-line-length 128 --ignore Q000,D100,D101,D102,D103,D104,D105,D106,D107,D401,D205,D400"

      - name: black
        uses: reviewdog/action-black@v3.10.2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workdir: .github/
          reporter: ${{ steps.reporter.outputs.value }}
      
      - name: pytest
        id: pytest
        shell: bash
        run: |
          set -x
          export PYTHONPATH=$PYTHONPATH:$GITHUB_WORKSPACE/.github
          cd .github/ || true
          pytest --tb=short --disable-warnings --maxfail=1 --junitxml=${GITHUB_WORKSPACE}/pytest-test-results.xml --html=${GITHUB_WORKSPACE}/pytest-report.html --self-contained-html
      - name: Upload pytest test results
        if: ${{ always() }}
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results
          path: pytest-test-results.xml
      - name: Upload pytest test results
        if: ${{ always() }}
        id: upload-html
        uses: actions/upload-artifact@v4
        with:
          name: pytest-report-html
          path: pytest-report.html 
      - name: upload test results to s3
        if: ${{ always() }}
        run: |
          set -x
          sudo -E -H -u github aws s3 cp --acl public-read --follow-symlinks --no-progress pytest-report.html "$S3_BUCKET_PATH/test_reports/pytest-report.html"
          sudo -E -H -u github aws s3 cp --acl public-read --follow-symlinks --no-progress pytest-test-results.xml "$S3_BUCKET_PATH/test_reports/pytest-test-results.xml"

      - name: comment on issue (${{ steps.pytest.outcome }})
        if: ${{ github.event_name == 'pull_request' && always() }}
        uses: actions/github-script@v7.0.1
        env:
          STEP_OUTCOME: ${{ steps.pytest.outcome }}
          ARTIFACT_URL: ${{ steps.upload.outputs.artifact-url }}
          HTML_ARTIFACT_URL: ${{ steps.upload-html.outputs.artifact-url }}
        with:
          script: |
            const s3_path = process.env.S3_URL_PREFIX;
            const outcome = process.env.STEP_OUTCOME;
            const artifact_url = process.env.ARTIFACT_URL;
            const html_artifact_url = process.env.HTML_ARTIFACT_URL;
            const status_emoji = outcome == 'success' ? ':green_circle:' : ':red_circle:';
            const comment = 'status: ' + status_emoji + ' [pytest result (artifact)](' + artifact_url + ') [pytest report (artifact)](' + html_artifact_url + ') [pytest report (s3)](' + s3_path + '/test_reports/pytest-report.html) [pytest results (s3)](' + s3_path + '/test_reports/pytest-test-results.xml)';
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            })


  workflows:
    needs: [set-env, check-running-allowed]
    if: needs.check-running-allowed.outputs.result == 'true'
    runs-on: [self-hosted, "self-hosted", "runner_light"]
    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          submodules: false
          sparse-checkout: '.github'
      - name: set up home
        shell: bash
        run: echo "HOME=$GITHUB_WORKSPACE" >> $GITHUB_ENV

      - name: install action-validator with asdf
        uses: asdf-vm/actions/install@v4.0.1
        with:
          tool_versions: |
            action-validator 0.8.0 

      - name: Prepare s3
        id: s3
        uses: ./.github/actions/s3cmd
        with:
          s3_bucket: ${{ vars.POOLED_LIGHT_AWS_BUCKET }}
          s3_endpoint: ${{ vars.POOLED_LIGHT_AWS_ENDPOINT }}
          s3_website_suffix: ${{ vars.POOLED_LIGHT_AWS_WEBSITE_SUFFIX }}
          s3_key_id: ${{ secrets.POOLED_LIGHT_AWS_KEY_ID }}
          s3_key_secret: ${{ secrets.POOLED_LIGHT_AWS_SECRET_KEY }}
          folder_prefix: nebius-
          build_preset: "relwithdebinfo"
          install: false

      - name: check workflows syntax
        id: lint
        run: |
          set -x
          export TMP_OUT=$(mktemp)
          find .github/workflows -type f \( -iname \*.yaml -o -iname \*.yml \) -print0 \
            | xargs -0 -I {} action-validator --verbose {} > $TMP_OUT

          echo "WORKFLOW_LINT=$(cat $TMP_OUT | awk -v ORS='\\n' 1)"
          cat $TMP_OUT >> "$GITHUB_STEP_SUMMARY"
          echo "WORKFLOW_LINT=$(cat $TMP_OUT | awk -v ORS='\\n' 1)" >> "$GITHUB_OUTPUT"
          echo "S3_WEBSITE_PREFIX=$TMP_OUT" | tee -a "$GITHUB_ENV" | tee -a "$GITHUB_OUTPUT"
          echo "OUTPUT_FILE=$TMP_OUT" | tee -a "$GITHUB_ENV" | tee -a "$GITHUB_OUTPUT"
          chown github:github $TMP_OUT
          chmod 644 $TMP_OUT

      - name: upload workflow lint results
        if: ${{ always() }}
        id: upload-workflow-lint-to-s3
        run: |
          set -x
          sudo -E -H -u github aws s3 cp --acl public-read --follow-symlinks --no-progress "$OUTPUT_FILE" "$S3_BUCKET_PATH/workflow_lint/workflow-lint.txt"

      - name: comment on issue
        uses: actions/github-script@v7.0.1
        if:  ${{ github.event_name == 'pull_request' }}
        env:
          STEP_OUTCOME: ${{ steps.lint.outcome }}
        with:
          script: |
            const outcome = process.env.STEP_OUTCOME;
            const status_emoji = outcome == 'success' ? ':green_circle:' : ':red_circle:';
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'status: ' + status_emoji + ' [workflow lint result (s3)](' + process.env.S3_URL_PREFIX + '/workflow_lint/workflow-lint.txt)'
            })
  nbs-github-actions:
    needs: [set-env, check-running-allowed]
    if: needs.check-running-allowed.outputs.result == 'true'
    name: Launch scripts on test-data
    uses: ./.github/workflows/github_actions_scripts.yaml
    secrets: inherit

  create-build-and-test-target-var:
    needs:
      - check-running-allowed
    if: needs.check-running-allowed.outputs.result == 'true'
    runs-on: [self-hosted, "self-hosted", "runner_light"]
    outputs:
      matrix_include: ${{ steps.set-build-and-test-targets.outputs.matrix_include }}
      matrix_include_asan: ${{ steps.set-build-and-test-targets.outputs.matrix_include_asan }}
      matrix_include_tsan: ${{ steps.set-build-and-test-targets.outputs.matrix_include_tsan }}
      matrix_include_msan: ${{ steps.set-build-and-test-targets.outputs.matrix_include_msan }}
      matrix_include_ubsan: ${{ steps.set-build-and-test-targets.outputs.matrix_include_ubsan }}
    steps:
      - name: checkout PR
        uses: actions/checkout@v4
        if: github.event.pull_request.head.sha != ''
        with:
          submodules: false
          sparse-checkout: '.github'
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: ${{ !contains(github.event.pull_request.labels.*.name, 'rebase') && 1 || 0 }}
      - name: rebase PR
        if: ${{ github.event.pull_request.head.sha != '' && contains(github.event.pull_request.labels.*.name, 'rebase') }}
        shell: bash
        run: |
          git config user.email "robot-nbs@nebius.com"
          git config user.name "Robot NBS"
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git rebase origin/${{ github.event.pull_request.base.ref }}
      - name: checkout
        uses: actions/checkout@v4
        if: github.event.pull_request.head.sha == ''
        with:
          submodules: false
          sparse-checkout: '.github'
      - name: Calculate pr build and test targets matrix
        id: set-build-and-test-targets
        uses: ./.github/actions/nebius_calculate_pr_matrix
        with:
          scheduling_type: ${{ vars.NEBIUS_SCHEDULING_TYPE || 'on_demand' }}

  build_and_test:
    needs: [check-running-allowed, create-build-and-test-target-var]
    if: needs.check-running-allowed.outputs.result == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.create-build-and-test-target-var.outputs.matrix_include) }}
    name: Build and test (${{ matrix.mode }}${{ matrix.vm_name_suffix }})
    uses: ./.github/workflows/build_and_test_proxy.yaml
    with:
      mode: ${{ matrix.mode }}
      build_target: ${{ matrix.build_target }}
      test_target: ${{ matrix.test_target }}
      build_preset: ${{ matrix.build_preset }}
      test_size: ${{ contains(github.event.pull_request.labels.*.name, 'large-tests') && 'small,medium,large' || 'small' }}
      test_type: ${{ matrix.test_type }}
      vm_name_suffix: ${{ matrix.vm_name_suffix }}
      number_of_retries: ${{ matrix.number_of_retries }}
      cache_update_build: false
      cache_update_tests: false
      sleep_after_tests: ${{ contains(github.event.pull_request.labels.*.name, 'sleep') && '7200' || '1' }}
    secrets: inherit

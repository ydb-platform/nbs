diff --git a/cloud/blockstore/libs/storage/api/partition.h b/cloud/blockstore/libs/storage/api/partition.h
index a53fbae21e..b7fdd22244 100644
--- a/cloud/blockstore/libs/storage/api/partition.h
+++ b/cloud/blockstore/libs/storage/api/partition.h
@@ -39,6 +39,7 @@ namespace NCloud::NBlockStore::NStorage::NPartition {
     xxx(GetRebuildMetadataStatus, __VA_ARGS__)                                 \
     xxx(ScanDisk,                 __VA_ARGS__)                                 \
     xxx(GetScanDiskStatus,        __VA_ARGS__)                                 \
+//    xxx(CheckRange,               __VA_ARGS__)                                 \
 // BLOCKSTORE_PARTITION_REQUESTS_FWD_VOLUME

 ////////////////////////////////////////////////////////////////////////////////
diff --git a/cloud/blockstore/libs/storage/api/volume.h b/cloud/blockstore/libs/storage/api/volume.h
index 76e774f87b..c690074311 100644
--- a/cloud/blockstore/libs/storage/api/volume.h
+++ b/cloud/blockstore/libs/storage/api/volume.h
@@ -10,6 +10,8 @@
 #include <cloud/blockstore/libs/storage/protos/volume.pb.h>
 #include <cloud/blockstore/libs/storage/protos_ydb/volume.pb.h>

+#include <utility>
+
 namespace NCloud::NBlockStore::NStorage {

 ////////////////////////////////////////////////////////////////////////////////
@@ -251,10 +253,12 @@ struct TEvVolume
     {
         ui64 BlockId;
         ui64 BlocksCount;
+        TString DiskId;

-        TCheckRange(ui64 blockId, ui64 blocksCount)
+        TCheckRange(ui64 blockId, ui64 blocksCount, TString diskId)
             : BlockId(blockId)
             , BlocksCount(blocksCount)
+            , DiskId(std::move(diskId))
         {}
     };

diff --git a/cloud/blockstore/libs/storage/partition/part_actor.h b/cloud/blockstore/libs/storage/partition/part_actor.h
index e3ded32352..e056439c9b 100644
--- a/cloud/blockstore/libs/storage/partition/part_actor.h
+++ b/cloud/blockstore/libs/storage/partition/part_actor.h
@@ -408,6 +408,10 @@ private:
         const TString& operationId,
         ui32& ranges) const;

+    void CheckRange(
+        const TEvVolume::TEvCheckRange::TPtr& ev,
+        const NActors::TActorContext& ctx);
+
     NActors::IActorPtr CreateMetadataRebuildUsedBlocksActor(
         NActors::TActorId tablet,
         ui64 blocksPerBatch,
diff --git a/cloud/blockstore/libs/storage/partition/part_actor_checkrange.cpp b/cloud/blockstore/libs/storage/partition/part_actor_checkrange.cpp
new file mode 100644
index 0000000000..a153364d2c
--- /dev/null
+++ b/cloud/blockstore/libs/storage/partition/part_actor_checkrange.cpp
@@ -0,0 +1,192 @@
+#include "part_actor.h"
+#include "cloud/blockstore/libs/storage/disk_agent/model/public.h"
+//
+#include <cloud/blockstore/libs/service/context.h>
+#include <cloud/blockstore/libs/storage/core/config.h>
+#include <cloud/blockstore/libs/storage/core/probes.h>
+
+#include <contrib/ydb/library/actors/core/actor_bootstrapped.h>
+
+#include <util/datetime/base.h>
+#include <util/generic/algorithm.h>
+#include <util/generic/guid.h>
+#include <util/generic/string.h>
+#include <util/generic/vector.h>
+#include <util/generic/xrange.h>
+#include <util/stream/str.h>
+
+namespace NCloud::NBlockStore::NStorage::NPartition {
+
+using namespace NActors;
+
+using namespace NKikimr;
+
+LWTRACE_USING(BLOCKSTORE_STORAGE_PROVIDER);
+
+namespace {
+
+////////////////////////////////////////////////////////////////////////////////
+
+class TCheckRangeActor final
+    : public TActorBootstrapped<TCheckRangeActor>
+{
+private:
+    const TActorId Tablet;
+    const ui64 blockIndex;
+    const ui64 BlocksCount;
+    const TString DiskId;
+
+public:
+    TCheckRangeActor(
+        const TActorId& tablet,
+        ui64 blockId,
+        ui64 blocksCoun,
+        TString diskId);
+
+    void Bootstrap(const TActorContext& ctx);
+
+private:
+    void ReadBlocks(const TActorContext& ctx);
+
+    void ReplyAndDie(
+        const TActorContext& ctx,
+        const NProto::TError& error = {});
+
+    void HandleReadBlocksResponse(
+        const TEvService::TEvReadBlocksResponse::TPtr& ev,
+        const TActorContext& ctx);
+
+private:
+    STFUNC(StateWork);
+
+    void HandleWakeup(
+        const TEvents::TEvWakeup::TPtr& ev,
+        const TActorContext& ctx);
+
+    void HandlePoisonPill(
+        const TEvents::TEvPoisonPill::TPtr& ev,
+        const TActorContext& ctx);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+TCheckRangeActor::TCheckRangeActor(
+        const TActorId& tablet,
+        ui64 blockIndex,
+        ui64 blocksCount,
+        TString diskId)
+    : Tablet(tablet)
+    , blockIndex(blockIndex)
+    , BlocksCount(blocksCount)
+    , DiskId(std::move(diskId))
+{}
+
+void TCheckRangeActor::Bootstrap(const TActorContext& ctx)
+{
+    ReadBlocks(ctx);
+    Become(&TThis::StateWork);
+    Die(ctx);
+}
+
+void TCheckRangeActor::ReadBlocks(const TActorContext& ctx)
+{
+    auto request = std::make_unique<TEvService::TEvReadBlocksRequest>();
+    request->Record.SetDiskId(DiskId);
+    request->Record.SetStartIndex(blockIndex);
+    //на подумать
+    request->Record.SetSessionId(sessionId);
+    request->Record.SetBlocksCount(BlocksCount);
+
+    auto* headers = request->Record.MutableHeaders();
+
+    headers->SetIsBackgroundRequest(true);
+    headers->SetClientId(TString(BackgroundOpsClientId));
+
+    auto event = std::make_unique<IEventHandle>(
+        DiskId,
+        ctx.SelfID,
+        request.release(),
+        IEventHandle::FlagForwardOnNondelivery,
+        0,            // cookie
+        &ctx.SelfID   // forwardOnNondelivery
+    );
+
+    ctx.Send(event.release());
+}
+
+void TCheckRangeActor::ReplyAndDie(
+    const TActorContext& ctx,
+    const NProto::TError& error)
+{
+    {
+        auto response = std::make_unique<TEvPartitionPrivate::TEvForcedCompactionCompleted>(error);
+        NCloud::Send(ctx, Tablet, std::move(response));
+    }
+
+    Die(ctx);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+STFUNC(TCheckRangeActor::StateWork)
+{
+    switch (ev->GetTypeRewrite()) {
+        HFunc(TEvents::TEvPoisonPill, HandlePoisonPill);
+        HFunc(TEvents::TEvWakeup, HandleWakeup);
+        HFunc(TEvService::TEvReadBlocksResponse, HandleReadBlocksResponse);
+        default:
+            HandleUnexpectedEvent(ev, TBlockStoreComponents::PARTITION_WORKER);
+            break;
+    }
+}
+
+void TCheckRangeActor::HandleWakeup(
+    const TEvents::TEvWakeup::TPtr& ev,
+    const TActorContext& ctx)
+{
+    Y_UNUSED(ev);
+    ReadBlocks(ctx);
+}
+
+void TCheckRangeActor::HandlePoisonPill(
+    const TEvents::TEvPoisonPill::TPtr& ev,
+    const TActorContext& ctx)
+{
+    Y_UNUSED(ev);
+
+    auto error = MakeError(E_REJECTED, "tablet is shutting down");
+
+    ReplyAndDie(ctx, error);
+}
+
+void TCheckRangeActor::HandleReadBlocksResponse(
+    const TEvService::TEvReadBlocksResponse::TPtr& ev,
+    const TActorContext& ctx)
+{
+
+}
+
+}   // namespace
+
+////////////////////////////////////////////////////////////////////////////////
+
+
+void TPartitionActor::CheckRange(
+    const TEvVolume::TEvCheckRange::TPtr& ev,
+    const TActorContext& ctx)
+{
+    auto* msg = ev->Get();
+
+    auto actorId = NCloud::Register<TCheckRangeActor>(
+        ctx,
+        ev->Sender,
+        msg->BlockId,
+        msg->BlocksCount,
+        msg->DiskId);
+
+    Actors.Insert(actorId);
+
+    LOG_INFO(ctx, TBlockStoreComponents::PARTITION, "Check range started");
+}
+
+}   // namespace NCloud::NBlockStore::NStorage::NPartition
diff --git a/cloud/blockstore/libs/storage/partition/part_actor_readblocks.cpp b/cloud/blockstore/libs/storage/partition/part_actor_readblocks.cpp
index 27c33550f5..89770cf60b 100644
--- a/cloud/blockstore/libs/storage/partition/part_actor_readblocks.cpp
+++ b/cloud/blockstore/libs/storage/partition/part_actor_readblocks.cpp
@@ -563,7 +563,7 @@ void TReadBlocksActor::HandleReadBlobResponse(
     Y_ABORT_UNLESS(RequestsCompleted <= RequestsScheduled);
     if (RequestsCompleted < RequestsScheduled) {
         return;
-    }
+}

     if (WaitBaseDiskRequests) {
         return;
@@ -932,6 +932,11 @@ void TPartitionActor::ReadBlocks(
     IReadBlocksHandlerPtr readHandler,
     bool replyLocal)
 {
+    LOG_ERROR(
+        ctx,
+        TBlockStoreComponents::VOLUME,
+        "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! reading blocks");
+
     State->GetCleanupQueue().AcquireBarrier(commitId);

     LOG_TRACE(ctx, TBlockStoreComponents::PARTITION,
@@ -1183,6 +1188,7 @@ void TPartitionActor::CompleteReadBlocks(
         "ReadBlocks",
         args.RequestInfo->CallContext->RequestId);

+    //Возвращает обратно в партактора
     NCloud::Reply(ctx, *args.RequestInfo, std::move(response));

     FinalizeReadBlocks(
diff --git a/cloud/blockstore/libs/storage/volume/volume_actor.h b/cloud/blockstore/libs/storage/volume/volume_actor.h
index 97c7371fd2..1d4c166d2d 100644
--- a/cloud/blockstore/libs/storage/volume/volume_actor.h
+++ b/cloud/blockstore/libs/storage/volume/volume_actor.h
@@ -358,6 +358,15 @@ private:

     NActors::TActorId ScanDiskId;

+    struct TScanDiskStatus
+    {
+        bool IsFinished;
+        ui64 LastBlockId;
+        ui64 BrokenBlockId;
+        TString ErrorMessage;
+        TString TimeStamp;
+    };
+
 public:
     TVolumeActor(
         const NActors::TActorId& owner,
@@ -1003,6 +1012,7 @@ private:
     ////////////////////////////////////////////////////////////////////////////

     NActors::IActorPtr CreateScanDiskActor(
+        TString diskId,
         NActors::TActorId tablet,
         ui64 blobsPerBatch,
         ui64 finalCommitId,
diff --git a/cloud/blockstore/libs/storage/volume/volume_actor_loadstate.cpp b/cloud/blockstore/libs/storage/volume/volume_actor_loadstate.cpp
index 72701f1ee2..c60b120d58 100644
--- a/cloud/blockstore/libs/storage/volume/volume_actor_loadstate.cpp
+++ b/cloud/blockstore/libs/storage/volume/volume_actor_loadstate.cpp
@@ -196,10 +196,13 @@ void TVolumeActor::CompleteLoadState(
     ScheduleAllocateDiskIfNeeded(ctx);

     LOG_ERROR(ctx, TBlockStoreComponents::VOLUME, "Volume registrations started");
+    //LOG_ERROR(ctx, TBlockStoreComponents::VOLUME, State->GetDiskId());

     ScanDiskId = NCloud::Register(
         ctx,
         CreateScanDiskActor(
+            //State->GetDiskId(),
+            "disk_id",
             SelfId(),
             100,
             0,
diff --git a/cloud/blockstore/libs/storage/volume/volume_actor_scandisk.cpp b/cloud/blockstore/libs/storage/volume/volume_actor_scandisk.cpp
index 66475807b8..bd71df4d51 100644
--- a/cloud/blockstore/libs/storage/volume/volume_actor_scandisk.cpp
+++ b/cloud/blockstore/libs/storage/volume/volume_actor_scandisk.cpp
@@ -1,55 +1,67 @@
+#include "volume_actor.h"
+
+#include "cloud/blockstore/libs/storage/disk_agent/model/public.h"
 #include "cloud/blockstore/libs/storage/partition_common/model/blob_markers.h"
 #include "cloud/storage/core/libs/common/block_buffer.h"
 #include "cloud/storage/core/libs/tablet/model/partial_blob_id.h"
 #include "cloud/storage/core/protos/error.pb.h"
 #include "contrib/ydb/library/actors/core/log.h"
+
 #include <contrib/ydb/library/actors/core/actor_bootstrapped.h>
-#include "volume_actor.h"

 namespace NCloud::NBlockStore::NStorage::NVolume {

 using namespace NActors;

 using namespace NKikimr;
-//using namespace NKikimr::NTabletFlatExecutor;
+// using namespace NKikimr::NTabletFlatExecutor;

 namespace {

 ////////////////////////////////////////////////////////////////////////////////

-//constexpr ui64 MaxUniqueId = std::numeric_limits<ui64>::max();
+// constexpr ui64 MaxUniqueId = std::numeric_limits<ui64>::max();

-
-class TScanDiskActor final
-    : public TActorBootstrapped<TScanDiskActor>
+class TScanDiskActor final: public TActorBootstrapped<TScanDiskActor>
 {
 private:
-    const NActors::TActorId  VolumeId;
-    const ui32 BlobsPerBatch = 0;
+    TString DiskId;
+    const NActors::TActorId VolumeId;
+    const ui32 BlocksPerBatch = 0;
     const TPartialBlobId FinalBlobId;
     const TDuration RetryTimeout;
     bool IsCompleted = false;
-    ui64 currentBlobId = 0;
+    bool HasErrors = false;

-    TVector<NBlobMarkers::TBlobMark> RequestsInCurrentBatch;
+    ui64 ErrorBlockId = 0;
+    TString ErrorMessage;

+    ui64 CurrentBlockId = 0;

-    //TVector<ui64> BrokenBlobs;
+    TVector<NBlobMarkers::TBlobMark> RequestsInCurrentBatch;
+
+    // TVector<ui64> BrokenBlobs;

 public:
     TScanDiskActor(
-        const NActors::TActorId & volumeId,
+        TString diskId,
+        const NActors::TActorId& volumeId,
         ui32 blobsPerBatch,
         ui64 finalCommitId,
-        TDuration retryTimeout
-        );
+        TDuration retryTimeout);

     void Bootstrap(const TActorContext& ctx);

 private:
     void SendCheckRangeRequest(const TActorContext& ctx);

-    void SendReadBlobRequest(const TActorContext& ctx, ui32 requestIndex);
+    void SendReadBlocksRequest(const TActorContext& ctx);
+
+    void CheckRange(const TActorContext& ctx);
+
+    void HandleReadBlocksResponse(
+        const TEvService::TEvReadBlocksResponse::TPtr& ev,
+        const TActorContext& ctx);

     void ReportStatus(const TActorContext& ctx);

@@ -77,35 +89,52 @@ private:
 ////////////////////////////////////////////////////////////////////////////////

 TScanDiskActor::TScanDiskActor(
-        const NActors::TActorId & volumeId,
-        ui32 blobsPerBatch,
-        ui64 finalBlobId,
-        TDuration retryTimeout
-        //TBlockBuffer blockBuffer
-        )
-    : VolumeId(volumeId)
-    , BlobsPerBatch(blobsPerBatch)
+    TString diskId,
+    const NActors::TActorId& volumeId,
+    ui32 blobsPerBatch,
+    ui64 finalBlobId,
+    TDuration retryTimeout
+    // TBlockBuffer blockBuffer
+    )
+    : DiskId(std::move(diskId))
+    , VolumeId(volumeId)
+    , BlocksPerBatch(blobsPerBatch)
     , FinalBlobId(MakePartialBlobId(finalBlobId, Max()))
     , RetryTimeout(retryTimeout)
 {}

-void TScanDiskActor::Bootstrap(const TActorContext &ctx)
+void TScanDiskActor::Bootstrap(const TActorContext& ctx)
 {
     LOG_ERROR(
         ctx,
         TBlockStoreComponents::VOLUME,
         "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! scandisk in volume has "
         "started");
-    SendCheckRangeRequest(ctx);
+        sleep(5);
+    CheckRange(ctx);
     Become(&TThis::StateWork);
 }

+void TScanDiskActor::CheckRange(const TActorContext& ctx)
+{
+    if (HasErrors) {
+        IsCompleted = true;
+        ReportStatus(ctx);
+        Die(ctx);
+    }
+
+    // SendCheckRangeRequest(ctx);
+
+    SendReadBlocksRequest(ctx);
+}
+
 void TScanDiskActor::SendCheckRangeRequest(const TActorContext& ctx)
 {
     auto request = std::make_unique<TEvVolume::TEvCheckRange>(
         MakeIntrusive<TCallContext>(),
-        currentBlobId,
-        BlobsPerBatch);
+        CurrentBlockId,
+        BlocksPerBatch,
+        DiskId);

     NCloud::Send(ctx, VolumeId, std::move(request));

@@ -116,27 +145,40 @@ void TScanDiskActor::SendCheckRangeRequest(const TActorContext& ctx)
         "sended ");
 }

+void TScanDiskActor::SendReadBlocksRequest(const TActorContext& ctx)
+{
+    auto request = std::make_unique<TEvService::TEvReadBlocksRequest>();
+    request->Record.SetDiskId(DiskId);
+    request->Record.SetStartIndex(CurrentBlockId);
+    // на подумать
+    request->Record.SetSessionId("");
+    request->Record.SetBlocksCount(BlocksPerBatch);
+
+    auto* headers = request->Record.MutableHeaders();
+
+    headers->SetIsBackgroundRequest(true);
+    headers->SetClientId(TString(BackgroundOpsClientId));
+    NCloud::Send(ctx, VolumeId, std::move(request));
+}

 ////////////////////////////////////////////////////////////////////////////////

 STFUNC(TScanDiskActor::StateWork)
 {
     switch (ev->GetTypeRewrite()) {
-
         HFunc(TEvents::TEvWakeup, HandleWakeup);
         HFunc(TEvents::TEvPoisonPill, HandlePoisonPill);
-        HFunc(
-            TEvVolume::TEvCheckRangeResponse,
-            HandleCheckRangeResponse);
+        HFunc(TEvVolume::TEvCheckRangeResponse, HandleCheckRangeResponse);
         /*
         HFunc(
             TEvPartitionCommonPrivate::TEvReadBlobResponse,
             HandleReadBlobResponse);
         */

+        HFunc(TEvService::TEvReadBlocksResponse, HandleReadBlocksResponse);
+
         default:
-            HandleUnexpectedEvent(
-                ev, TBlockStoreComponents::PARTITION_WORKER);
+            HandleUnexpectedEvent(ev, TBlockStoreComponents::PARTITION_WORKER);
             break;
     }
 }
@@ -173,8 +215,10 @@ void TScanDiskActor::HandleCheckRangeResponse(
         "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! scandisk response "
         "catched ");

-    if (FinalBlobId.CommitId() <= currentBlobId){
+    if (FinalBlobId.UniqueId() <= CurrentBlockId) {
         IsCompleted = true;
+    } else {
+        CurrentBlockId += BlocksPerBatch;
     }

     ReportStatus(ctx);
@@ -204,36 +248,77 @@ void TScanDiskActor::HandleCheckRangeResponse(
     ReadBlobResponsesCounter = 0;

     RequestsInCurrentBatch = std::move(msg->BlobsInBatch);
-    for (ui32 requestIndex = 0; requestIndex < RequestsInCurrentBatch.size(); ++requestIndex) {
-        SendReadBlobRequest(ctx, requestIndex);
+    for (ui32 requestIndex = 0; requestIndex < RequestsInCurrentBatch.size();
+    ++requestIndex) { SendReadBlobRequest(ctx, requestIndex);
     }
     */
 }

-void TScanDiskActor::ReportStatus(
+void TScanDiskActor::HandleReadBlocksResponse(
+    const TEvService::TEvReadBlocksResponse::TPtr& ev,
     const TActorContext& ctx)
 {
+    const auto* msg = ev->Get();
+
+    LOG_ERROR(
+        ctx,
+        TBlockStoreComponents::VOLUME,
+        "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! readblocks response "
+        "catched ");
+
+    if (HasError(msg->Record.GetError())) {
+        ErrorBlockId = CurrentBlockId;
+        ErrorMessage = msg->Record.GetError().GetMessage();
+        LOG_ERROR(
+            ctx,
+            TBlockStoreComponents::VOLUME,
+            "While scanning a disk with an id = " + DiskId +
+                " a reading error has occurred: " + ErrorMessage + "   message   " +  msg->Record.GetError().message() );
+        HasErrors = true;
+    }
+
+    if (FinalBlobId.UniqueId() <= CurrentBlockId) {
+        IsCompleted = true;
+    } else {
+        CurrentBlockId += BlocksPerBatch;
+    }
+
+    ReportStatus(ctx);
+    SendReadBlocksRequest(ctx);
+
+    Y_UNUSED(msg);
+}
+
+void TScanDiskActor::ReportStatus(const TActorContext& ctx)
+{
+    LOG_ERROR(
+        ctx,
+        TBlockStoreComponents::VOLUME,
+        "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! reporting status ");
+
     auto request = std::make_unique<TEvVolume::TEvCheckRangeReportStatus>(
         MakeIntrusive<TCallContext>(),
-        currentBlobId,
+        CurrentBlockId,
         IsCompleted);

     NCloud::Send(ctx, VolumeId, std::move(request));
 }

-}  // namespace
+}   // namespace

-}  // namespace NCloud::NBlockStore::NStorage::NPartition
+}   // namespace NCloud::NBlockStore::NStorage::NVolume

 namespace NCloud::NBlockStore::NStorage {
 NActors::IActorPtr TVolumeActor::CreateScanDiskActor(
-    NActors::TActorId  tablet,
+    TString diskId,
+    NActors::TActorId tabletId,
     ui64 blobsPerBatch,
     ui64 finalCommitId,
     TDuration retryTimeout)
 {
     return std::make_unique<NVolume::TScanDiskActor>(
-        std::move(tablet),
+        std::move(diskId),
+        tabletId,
         blobsPerBatch,
         finalCommitId,
         retryTimeout);

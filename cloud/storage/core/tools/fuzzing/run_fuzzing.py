#!/usr/bin/python3

import argparse
import os
import subprocess
import sys
import time

from signal import signal, SIGINT, SIGKILL, SIGTERM

process = None


def create_parser():
    parser = argparse.ArgumentParser(
        description='Run fuzzing process. Processes run for a total_time,'
        "but they can be stopped if on stop_time don't find new path from whitelist")
    parser.add_argument ('-e', '--exec', required=True,
        help='binary file to run')
    parser.add_argument ('-t', '--total_time',
        help='maximum time of fuzzing in sec (default 600)', default=600)
    parser.add_argument ('-j', '--jobs',
        help='fuzzing process count (default 1)', default=1)
    parser.add_argument ('-c', '--corpus_path', required=True, action='append',
        help='path to fuzzing corpus path')
    parser.add_argument ('-w', '--white_list',
        help='list of folders for find new path of fuzzing')
    parser.add_argument ('-s', '--stop_time',
        help='time for finding new path of fuzzing')
    parser.add_argument ('-l', '--max_length',
        help='max length of generated byte array for fuzzing. 0 - unlimited (default 0)', default=0)

    return parser


def kill_group(proc, timeout=600):
    print("Kill group")
    os.kill(proc.pid, SIGTERM)
    try:
        proc.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        os.kill(proc.pid, SIGKILL)
    proc.wait()


def handler(signal_received, frame):
    print("Killed", signal_received, frame)
    process.terminate()
    os._exit(-1)


def main():
    try:
        parser = create_parser()
        namespace = parser.parse_args()

        files_must_exist = [namespace.exec, *namespace.corpus_path]
        if namespace.white_list != None:
            files_must_exist.append(namespace.white_list)

        for file in files_must_exist:
            if not os.path.exists(file):
                print("File doesn't exist:", file)
                exit(-1)

        process = subprocess.Popen([namespace.exec,
                                    "-max_total_time={}".format(namespace.total_time),
                                    "-rss_limit_mb=4096",
                                    "-timeout=600",
                                    "-max_len={}".format(namespace.max_length),
                                    "-detect_leaks=0",
                                    "-print_final_stats=1",
                                    "-handle_term=1",
                                    "-interrupted_exitcode=78",
                                    "-dump_interrupted=1",
                                    "-report_slow_units=0",
                                    "-use_counters=0",
                                    "-jobs={}".format(namespace.jobs),
                                    "-workers={}".format(namespace.jobs),
                                    "-runs=-1",
                                    "-print_pcs=1",
                                    ' '.join(namespace.corpus_path)])

        signal(SIGINT, handler)

        if namespace.white_list != None:
            sources = open(namespace.white_list, 'r').read().splitlines()
        else:
            sources = {}

        files = ['fuzz-{}.log'.format(i) for i in range(int(namespace.jobs))]

        exists = False
        max_wait = 30
        while max_wait > 0 and not exists:
            time.sleep(1)
            max_wait -= 1
            exists = not (False in [os.path.exists(f) for f in files])

        if not exists:
            raise RuntimeError("fuzz logs didn't appear in time")

        logs = [open(f, 'r') for f in files]

        pev_time = time.time()
        now_time = time.time()

        print("Started", now_time)

        while (pev_time + int(namespace.stop_time)) > now_time:
            if process.poll() is not None:
                print("Done", now_time, process.returncode)
                os._exit(process.returncode)
            for log in logs:
                text = log.read()
                if text:
                    for line in text.splitlines():
                        words = line.split()
                        # example: NEW_PC: 0x4121cfc in smthg /path/file:line:col, looking for path
                        if len(words) >= 5 and words[0] == 'NEW_PC:':
                            for source in sources:
                                if words[4].find(source) != -1:
                                    print(line, "Now is", now_time)
                                    pev_time = now_time
            now_time = time.time()
        print("Stop time passed")
    except Exception as ex:
        print("Failed: ", ex, "error code:", sys.exc_info()[2])
    finally:
        return_code = process.poll()
        print("Stoped", now_time, return_code)
        if return_code == None:
            kill_group(process)
            return_code = 0
        exit(return_code)


if __name__ == '__main__':
    main()

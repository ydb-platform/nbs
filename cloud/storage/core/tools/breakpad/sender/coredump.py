# -*- coding: UTF-8 -*-

import logging
import os
import re
import subprocess

from subprocess import CalledProcessError, TimeoutExpired

logger = logging.getLogger(__name__)


class CoredumpError(Exception):
    pass


class MinidumpError(CoredumpError):
    pass


class Coredump(object):
    GDB_CMD = "/usr/bin/gdb"
    EXECFILE_RE = re.compile(r'^Core was generated by `(.+)\'\.$', re.M)

    def __init__(self, corefile, gdb_timeout):
        super().__init__()
        self._logger = logger.getChild(self.__class__.__name__)
        self._corefile = corefile
        self._execfile = None
        self._backtrace = None
        self._gdb_timeout = gdb_timeout

    def _run_command(self, cmd):
        try:
            self._logger.debug("Exec %r", ' '.join(cmd))
            result = subprocess.run(args=cmd,
                                    capture_output=True,
                                    check=True,
                                    timeout=self._gdb_timeout)
        except Exception as e:
            raise CoredumpError(e)
        return result.stdout.decode("utf-8", errors="replace")

    @property
    def execfile(self):
        if not self._execfile:
            file_output = self._run_command(["file", self._corefile])
            # Searching for pattern "from '<binary_path> <args>'"
            m = re.search(r"from '([^' ]+)", file_output)
            if not m:
                raise CoredumpError("Can't find execfile in 'file' output")
            self._execfile = m.group(1)

        return self._execfile

    @property
    def service(self):
        return os.path.basename(self.execfile)

    @property
    def backtrace(self):
        if not self._backtrace:
            cmd = [
                self.GDB_CMD,
                self.execfile,
                self._corefile,
                "-iex=set auto-load safe-path /",
                "-iex=set print thread-events off",
                "-ex=thread apply all bt",
                "--batch",
                "-q"
            ]
            self._backtrace = self._run_command(cmd)

        return self._backtrace

    def cleanup(self):
        if not os.path.isfile(self._corefile):
            return
        try:
            os.unlink(self._corefile)
        except OSError as e:
            self._logger.warning("unlink %s failed %r", self._corefile, e)


class Minidump(Coredump):
    MINIDUMP2CORE_CMD = "/usr/bin/minidump-2-core"

    def __init__(self, minidump, gdb_timeout):
        super().__init__(minidump + ".core", gdb_timeout)
        self._logger = logger.getChild(self.__class__.__name__)
        self._minidump = minidump
        self._make_corefile()

    def _make_corefile(self):
        minidump_path = self._minidump
        core_path = self._minidump + ".core"

        cmd = [self.MINIDUMP2CORE_CMD, minidump_path, "-o", core_path]
        self._logger.debug("Exec %r", ' '.join(cmd))
        self._logger.info("Save core to %s", core_path)

        try:
            subprocess.run(args=cmd,
                           capture_output=True,
                           check=True)
        except (TimeoutExpired, CalledProcessError) as e:
            raise MinidumpError(e)

    def cleanup(self):
        super().cleanup()
        if not os.path.isfile(self._minidump):
            return
        try:
            os.unlink(self._minidump)
        except OSError as e:
            self._logger.warning("unlink %s failed %r", self._minidump, e)

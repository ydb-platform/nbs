# -*- coding: UTF-8 -*-

import logging
import os
import re
import subprocess

from subprocess import CalledProcessError, TimeoutExpired
from shlex import join

logger = logging.getLogger(__name__)


class CoredumpError(Exception):
    pass


class MinidumpError(CoredumpError):
    pass


class Coredump(object):
    GDB_CMD = "/usr/bin/gdb"
    EXECFILE_RE = re.compile(r'^Core was generated by `(.+)\'\.$', re.M)

    def __init__(self, corefile, gdb_timeout, gdb_disabled):
        super().__init__()
        self._logger = logger.getChild(self.__class__.__name__)
        self._corefile = corefile
        self._execfile = None
        self._backtrace = None
        self._gdb_timeout = gdb_timeout
        self._gdb_disabled = gdb_disabled

    def _run_command(self, cmd):
        try:
            cmd_str = join(cmd)
            self._logger.debug(f"Exec \"{cmd_str}\"")
            result = subprocess.run(args=cmd,
                                    capture_output=True,
                                    check=True,
                                    timeout=self._gdb_timeout)
        except CalledProcessError as e:
            msg = f"Error occurred running command \"{cmd_str}\", " \
                  f"return_code={e.returncode}, stderr:\n {e.stderr}"
            raise CoredumpError(msg) from e
        except TimeoutExpired as e:
            msg = f"Timeout expired running command \"{cmd_str}\", " \
                  f"timeout={e.timeout}"
            raise CoredumpError(msg) from e

        return result.stdout.decode("utf-8", errors="replace")

    @property
    def execfile(self):
        if not self._execfile:
            file_output = self._run_command(["file", self._corefile])
            # Searching for pattern "from '<binary_path> <args>'"
            m = re.search(r"from '([^' ]+)", file_output)
            if not m:
                raise CoredumpError("Can't find execfile in 'file' output")
            self._execfile = m.group(1)

        return self._execfile

    @property
    def service(self):
        return os.path.basename(self.execfile)

    @property
    def backtrace(self):
        if self._gdb_disabled:
            return "<unknown> (running gdb was disabled)"

        if not self._backtrace:
            cmd = [
                self.GDB_CMD,
                self.execfile,
                self._corefile,
                "-iex=set auto-load safe-path /",
                "-iex=set print thread-events off",
                "-ex=thread apply all bt",
                "--batch",
                "-q"
            ]
            self._backtrace = self._run_command(cmd)

        return self._backtrace

    def remove_file(self, filepath: str):
        if not os.path.isfile(filepath):
            return
        try:
            os.unlink(filepath)
        except OSError as e:
            self._logger.warning("unlink %s failed %r", filepath, e)

    def cleanup(self):
        self.remove_file(self._corefile)


class Minidump(Coredump):
    MINIDUMP2CORE_CMD = "/usr/bin/minidump-2-core"

    def __init__(self, minidump, gdb_timeout, gdb_disabled):
        super().__init__(minidump + ".core", gdb_timeout, gdb_disabled)
        self._logger = logger.getChild(self.__class__.__name__)
        self._minidump = minidump
        self._make_corefile()

    def _make_corefile(self):
        minidump_path = self._minidump
        core_path = self._minidump + ".core"

        cmd = [self.MINIDUMP2CORE_CMD, minidump_path, "-o", core_path]
        self._logger.info("Saving core to %s", core_path)

        try:
            self._run_command(cmd)
        except CoredumpError as e:
            raise MinidumpError from e

    def cleanup(self):
        super().cleanup()
        self.remove_file(self._minidump)

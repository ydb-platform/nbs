syntax = "proto3";

package NCloud.NBlockStore.NProto;

option go_package = "github.com/ydb-platform/nbs/cloud/blockstore/libs/storage/protos";

import "cloud/blockstore/public/api/protos/disk.proto";
import "cloud/blockstore/public/api/protos/headers.proto";
import "cloud/blockstore/public/api/protos/io.proto";
import "cloud/blockstore/public/api/protos/placement.proto";
import "cloud/blockstore/public/api/protos/rdma.proto";
import "cloud/blockstore/public/api/protos/volume.proto";
import "cloud/storage/core/protos/error.proto";
import "cloud/storage/core/protos/media.proto";

////////////////////////////////////////////////////////////////////////////////

enum EDeviceState
{
    DEVICE_STATE_ONLINE = 0;
    DEVICE_STATE_WARNING = 1;
    DEVICE_STATE_ERROR = 2;
}

////////////////////////////////////////////////////////////////////////////////

enum ECheckpointState
{
    CHECKPOINT_STATE_CREATING = 0;
    CHECKPOINT_STATE_OK = 1;
    CHECKPOINT_STATE_ERROR = 2;
}

////////////////////////////////////////////////////////////////////////////////

// Mean time between failures.
message TMeanTimeBetweenFailures
{
    // Work time in seconds.
    uint64 WorkTime = 1;

    // Number of transitions to broken state.
    uint64 BrokenCount = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TAgentConfig
{
    // Node that agent is running on.
    uint32 NodeId = 1;

    // Devices attached to the agent.
    repeated TDeviceConfig Devices = 2;

    // Disk Agent Id which is used for registration in Disk registry.
    string AgentId = 3;

    // Current state of the Disk Agent
    EAgentState State = 4;

    // Timestamp when state has been changed (in microseconds)
    uint64 StateTs = 5;

    // Timestamp when CMS requested host shutdown (in microseconds)
    uint64 CmsTs = 6;

    // Agent generation.
    uint64 SeqNumber = 7;

    // Dedicated process flag.
    bool DedicatedDiskAgent = 8;

    // Reason for agent state.
    string StateMessage = 9;

    // Timestamp of the last transition to available state (in seconds)..
    uint64 WorkTs = 10;

    // Mean time between failures.
    TMeanTimeBetweenFailures TimeBetweenFailures = 11;

    // Unallowed devices attached to the agent.
    repeated TDeviceConfig UnknownDevices = 12;

    // Flag which indicates that the agent was launched as a temporary one
    // during blue-green deployment.
    bool TemporaryAgent = 13;
}

////////////////////////////////////////////////////////////////////////////////

message TDiskSession
{
    // Label of volume.
    string DiskId = 1;

    // Client identifier.
    string ClientId = 2;

    // Is session acquisition in progress.
    bool AcquireInProgress = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TDeviceConfig
{
    // Device name.
    string DeviceName = 1;

    // Device identifier.
    string DeviceUUID = 2;

    // Device blocks size in bytes.
    uint32 BlockSize = 3;

    // Number of total device blocks available (may be adjusted by DR).
    uint64 BlocksCount = 4;

    // NVMe-oF transport identifier.
    string TransportId = 5;

    // Node id of the host where this device is located.
    uint32 NodeId = 6;

    // The rack where this device is located.
    string Rack = 7;

    // Current state of the device.
    EDeviceState State = 8;

    // Timestamp when state has been changed (in microseconds)
    uint64 StateTs = 9;

    // Timestamp when CMS requested device shutdown (in microseconds).
    uint64 CmsTs = 10;

    // Reason for device state.
    string StateMessage = 11;

    // NVMe controller name.
    string BaseName = 12;

    // Agent id.
    string AgentId = 13;

    // Number of total device blocks available.
    uint64 UnadjustedBlockCount = 14;

    // Rdma target endpoint.
    TRdmaEndpoint RdmaEndpoint = 15;

    // Device pool name.
    string PoolName = 16;

    // Device pool kind.
    EDevicePoolKind PoolKind = 17;

    // Serial number.
    string SerialNumber = 18;

    // Physical offset in bytes.
    uint64 PhysicalOffset = 19;
}

////////////////////////////////////////////////////////////////////////////////

message TSuspendedDevice
{
    string Id = 1;
    bool ResumeAfterErase = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TDeviceMigration
{
    // Migration source device id.
    string SourceDeviceId = 1;

    // Migration target device config.
    TDeviceConfig TargetDevice = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TFinishedDeviceMigration
{
    string DeviceId = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TCheckpointReplica
{
    // CheckpointId.
    string CheckpointId = 1;

    // The name of the disk that the checkpoint belongs to.
    string SourceDiskId = 2;

    // Timestamp when checkpoint was changed (in microseconds)
    uint64 StateTs = 3;

    // Current state of checkpoint
    ECheckpointState State = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TDiskHistoryItem
{
    uint64 Timestamp = 1;
    string Message = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TDiskConfig
{
    // Label of volume.
    string DiskId = 1;

    // List of device UUIDs that make up the disk.
    repeated string DeviceUUIDs = 2;

    // Disk blocks size in bytes.
    uint32 BlockSize = 3;

    // Disk's current state.
    EDiskState State = 4;

    // Timestamp when state has been changed (in microseconds)
    uint64 StateTs = 5;

    // Migration configuration
    repeated TDeviceMigration Migrations = 6;

    // Cloud Id, used for user notification.
    string CloudId = 7;

    // Folder Id, used for user notification.
    string FolderId = 8;

    // User Id, used for user notification.
    string UserId = 9;

    // Replica count for mirrored disks.
    uint32 ReplicaCount = 10;

    // Master disk id (for replicas).
    string MasterDiskId = 11;

    // Finished or canceled device migrations.
    repeated TFinishedDeviceMigration FinishedMigrations = 12;

    // New devices used instead of recently replaced ones.
    repeated string DeviceReplacementUUIDs = 13;

    // Storage media.
    NCloud.NProto.EStorageMediaKind StorageMediaKind = 14;

    // Contains checkpoint info if this disk is used as a checkpoint replica.
    TCheckpointReplica CheckpointReplica = 15;

    // The timestamp of the start of migration (in microseconds).
    uint64 MigrationStartTs = 16;

    // A log of important events in the life of this disk.
    repeated TDiskHistoryItem History = 17;

    // A list of devices that are lagging behind on writes.
    repeated TLaggingDevice LaggingDevices = 18;
}

////////////////////////////////////////////////////////////////////////////////

message TPlacementGroupConfig
{
    // Id of the group.
    string GroupId = 1;

    message TDiskInfo
    {
        string DiskId = 1;
        repeated string DeviceRacks = 2;

        // For PLACEMENT_STRATEGY_PARTITION takes values from 1 to
        // PlacementPartitionCount.
        uint32 PlacementPartitionIndex = 3;
    }

    // Disks in this group.
    repeated TDiskInfo Disks = 2;

    // Config version.
    uint32 ConfigVersion = 3;

    // Custom placement group settings.
    TPlacementGroupSettings Settings = 4;

    // Placement strategy.
    EPlacementStrategy PlacementStrategy = 5;

    // Number of placement partitions.
    // Used for PLACEMENT_STRATEGY_PARTITION PlacementStrategy.
    uint32 PlacementPartitionCount = 6;
}

////////////////////////////////////////////////////////////////////////////////

message TDevicePoolConfig
{
    // Device pool name.
    string Name = 1;

    // Allocation unit for this pool (in bytes).
    uint64 AllocationUnit = 2;

    // Device pool kind.
    EDevicePoolKind Kind = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TDiskRegistryConfig
{
    // Disk registry config version.
    uint32 Version = 1;

    // List of agents allowed to connect to the Disk Registry.
    repeated TAgentConfig KnownAgents = 2;

    uint64 LastDiskStateSeqNo = 3;

    // Allow to allocate disks.
    bool WritableState = 4;

    // Device overrides. See NBS-2432.
    repeated TDeviceOverride DeviceOverrides = 5;

    // Device pool configs.
    repeated TDevicePoolConfig DevicePoolConfigs = 6;

    // Restore state.
    bool RestoreState = 7;

    // Last backup timestamp (in milliseconds)
    uint64 LastBackupTs = 8;
}

////////////////////////////////////////////////////////////////////////////////

message TDeviceRateLimits
{
    uint64 IopsLimit = 1;

    // Common bandwidth limit (in megabytes per second)
    uint64 BandwidthLimit = 2;

    // Read bandwidth limit (in megabytes per second)
    uint64 ReadBandwidthLimit = 3;

    // Write bandwidth limit (in megabytes per second)
    uint64 WriteBandwidthLimit = 4;
};

////////////////////////////////////////////////////////////////////////////////

message TDeviceStats
{
    message TBucketInfo
    {
        double Value = 1;
        uint64 Count = 2;
    };

    string DeviceUUID = 1;

    repeated TBucketInfo HistogramBuckets = 2;

    uint64 BytesRead = 3;
    uint64 NumReadOps = 4;
    uint64 BytesWritten = 5;
    uint64 NumWriteOps = 6;

    uint64 Errors = 7;

    uint64 BytesZeroed = 8;
    uint64 NumZeroOps = 9;

    uint64 NumEraseOps = 10;

    string DeviceName = 11;
}

////////////////////////////////////////////////////////////////////////////////

message TAgentStats
{
    // Node that agent is running on.
    uint32 NodeId = 1;

    // Devices attached to the agent.
    repeated TDeviceStats DeviceStats = 2;

    // Error count at Disk Agent initialization
    uint32 InitErrorsCount = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TLaggingDevice
{
    // UUID of the lagging device.
    string DeviceUUID = 1;

    // Index of the lagging device in the replica.
    uint32 RowIndex = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TLaggingAgent
{
    // Agent id.
    string AgentId = 1;

    // Index of the mirror disk replica.
    // 0 - main devices
    // 1,2 - replica devices
    uint32 ReplicaIndex = 2;

    // A list of devices that belong to the agent.
    repeated TLaggingDevice Devices = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TLaggingAgentsInfo
{
    // A list of agents that lagging behind on writes.
    repeated TLaggingAgent Agents = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TDiskRegistryAgentListRequestParams
{
    repeated string AgentIds = 1;

    uint64 TimeoutMs = 2;

    optional uint64 NewNonReplicatedAgentMinTimeoutMs = 3;
    optional uint64 NewNonReplicatedAgentMaxTimeoutMs = 4;
}

message TDiskRegistryAgentParams
{
    uint64 DeadlineMs = 1;

    optional uint64 NewNonReplicatedAgentMinTimeoutMs = 2;
    optional uint64 NewNonReplicatedAgentMaxTimeoutMs = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TUserNotification
{
    uint64 SeqNo = 2;
    // In microseconds.
    uint64 Timestamp = 3;

    // If duplicated in obsolete ErrorNotifications for compatibility.
    bool HasLegacyCopy = 4;

    oneof Event {
        TDiskError DiskError = 5;
        TDiskBackOnline DiskBackOnline = 6;
    }

    //---------------------------------------

    message TDiskError
    {
        string DiskId = 1;
    }

    message TDiskBackOnline
    {
        string DiskId = 1;
    }
}

////////////////////////////////////////////////////////////////////////////////

message TDiskRegistryStateBackup
{
    repeated TDiskConfig Disks = 1;
    repeated TPlacementGroupConfig PlacementGroups = 2;
    repeated TAgentConfig Agents = 3;
    repeated TDiskSession Sessions = 4;
    TDiskRegistryConfig Config = 5;

    // deprecated
    repeated string OldDirtyDevices = 6;

    message TDiskStateUpdate
    {
        TDiskState State = 1;
        uint64 SeqNo = 2;
    };

    repeated TDiskStateUpdate DiskStateChanges = 7;

    message TBrokenDiskInfo
    {
        string DiskId = 1;
        uint64 TsToDestroy = 2;
    }

    repeated TBrokenDiskInfo BrokenDisks = 8;
    repeated string DisksToNotify = 9;
    repeated string DisksToCleanup = 10;

    // Obsolete
    repeated string ErrorNotifications = 11;

    repeated string OutdatedVolumeConfigs = 12;

    // deprecated
    repeated string OldSuspendedDevices = 13;

    message TDirtyDevice
    {
        string Id = 1;
        string DiskId = 2;
    }

    repeated TDirtyDevice DirtyDevices = 14;

    message TAutomaticallyReplacedDeviceInfo
    {
        string DeviceId = 1;
        uint64 ReplacementTs = 2;
    }

    repeated TAutomaticallyReplacedDeviceInfo AutomaticallyReplacedDevices = 15;

    map<string, TDiskRegistryAgentParams> DiskRegistryAgentListParams = 16;

    repeated TUserNotification UserNotifications = 17;

    repeated TSuspendedDevice SuspendedDevices = 18;
}

////////////////////////////////////////////////////////////////////////////////

// Used to propagate write request to multiple disk agents.
message TReplicationTarget
{
    // NodeId of target host.
    uint32 NodeId = 1;

    // UUID of target device to write.
    string DeviceUUID = 2;

    // Start block index on target device.
    uint64 StartIndex = 3;

    // Operation timeout (in milliseconds)
    uint32 Timeout = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TRegisterAgentRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Agent configuration.
    TAgentConfig AgentConfig = 2;
}

message TRegisterAgentResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // List of device IDs to which Disk Agent should disable IO operations.
    repeated string DevicesToDisableIO = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TUnregisterAgentRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Node that agent is running on.
    uint32 NodeId = 2;
}

message TUnregisterAgentResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TAllocateDiskRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume to create.
    string DiskId = 2;

    // Minimum addressable block size (smallest unit of I/O operations).
    uint32 BlockSize = 3;

    // Maximum number of blocks stored in volume.
    uint64 BlocksCount = 4;

    // Placement group id.
    string PlacementGroupId = 5;

    // Cloud Id, used for user notification.
    string CloudId = 6;

    // Folder Id, used for user notification.
    string FolderId = 7;

    // Replica count (for mirrored disks).
    uint32 ReplicaCount = 8;

    // Target agent ids.
    repeated string AgentIds = 9;

    // Device pool name.
    string PoolName = 10;

    // Storage media to use.
    NCloud.NProto.EStorageMediaKind StorageMediaKind = 11;

    // Placement partition index.
    uint32 PlacementPartitionIndex = 12;
}

message TReplica
{
    // Device list.
    repeated TDeviceConfig Devices = 1;
}

message TAllocateDiskResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // List of device UUIDs that make up the disk.
    repeated TDeviceConfig Devices = 2;

    // IO state
    EVolumeIOMode IOMode = 3;

    // Migration configuration
    repeated TDeviceMigration Migrations = 4;

    // IO state timestamp
    uint64 IOModeTs = 5;

    // Mute IO errors after a while
    bool MuteIOErrors = 6;

    // Replicas for mirrored disks.
    repeated TReplica Replicas = 7;

    // New devices used instead of recently replaced ones.
    repeated string DeviceReplacementUUIDs = 8;

    // Devices that had been lagging.
    repeated TLaggingDevice RemovedLaggingDevices = 9;

    // Devices that had been lost by disk agent or devices with unavailable agent.
    repeated string UnavailableDeviceUUIDs = 10;
}

////////////////////////////////////////////////////////////////////////////////

message TDeallocateDiskRequest
{
    reserved 3;

    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume to remove.
    string DiskId = 2;

    // Wait for secure cleanup of disk's devices before response.
    bool Sync = 4;
}

message TDeallocateDiskResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TAcquireDevicesRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // List of device UUIDs to acquire.
    repeated string DeviceUUIDs = 2;

    // Session identifier.
    // string SessionId = 3; // obsolete

    // Rate limits.
    TDeviceRateLimits RateLimits = 4;

    // Access mode.
    EVolumeAccessMode AccessMode = 5;

    // MountSeqNumber from volume state.
    uint64 MountSeqNumber = 6;

    // Disk id.
    string DiskId = 7;

    // Volume generation.
    uint32 VolumeGeneration = 8;
}

message TAcquireDevicesResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReleaseDevicesRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // List of device UUIDs to release.
    repeated string DeviceUUIDs = 2;

    // Session identifier.
    // string SessionId = 3; // obsolete

    // Disk id.
    string DiskId = 4;

    // Volume generation.
    uint32 VolumeGeneration = 5;
}

message TReleaseDevicesResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TAcquireDiskRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume to acquire.
    string DiskId = 2;

    // Session identifier.
    // string SessionId = 3; // obsolete

    // Access mode.
    EVolumeAccessMode AccessMode = 4;

    // MountSeqNumber from volume state.
    uint64 MountSeqNumber = 5;

    // Volume generation.
    uint32 VolumeGeneration = 6;
}

message TAcquireDiskResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // List of devices that make up the disk.
    // Note. Contains only the devices located at available agents.
    repeated TDeviceConfig Devices = 2;

    // Migration configuration.
    repeated TDeviceMigration Migrations = 3;

    // Replicas.
    repeated TReplica Replicas = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TReleaseDiskRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume to release.
    string DiskId = 2;

    // Session identifier.
    // string SessionId = 3; // obsolete

    // Volume generation.
    uint32 VolumeGeneration = 4;
}

message TReleaseDiskResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TDescribeDiskRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume.
    string DiskId = 2;
}

message TDescribeDiskResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // List of device configs that make up the disk.
    repeated TDeviceConfig Devices = 2;

    // Minimum addressable block size (smallest unit of I/O operations).
    uint32 BlockSize = 3;

    // Maximum number of blocks stored in volume.
    uint64 BlocksCount = 4;

    // Disk's current state.
    EDiskState State = 5;

    // Timestamp when state has been changed (in microseconds)
    uint64 StateTs = 6;

    // Migrations.
    repeated TDeviceMigration Migrations = 7;

    // Replicas.
    repeated TReplica Replicas = 8;

    // Cloud Id, used for user notification.
    string CloudId = 9;

    // Folder Id, used for user notification.
    string FolderId = 10;

    // New devices used instead of recently replaced ones.
    repeated string DeviceReplacementUUIDs = 11;
}

////////////////////////////////////////////////////////////////////////////////
// Blocks read request/response.

message TReadDeviceBlocksRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // UUID of device to read from.
    string DeviceUUID = 2;

    // Start block index.
    uint64 StartIndex = 3;

    // Logical block size
    uint32 BlockSize = 4;

    // Number of blocks to read.
    uint32 BlocksCount = 5;

    // Session identifier.
    // string SessionId = 6; // obsolete
}

message TReadDeviceBlocksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Requested blocks.
    TIOVector Blocks = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Blocks write request/response.

message TWriteDeviceBlocksRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // UUID of device to write to.
    string DeviceUUID = 2;

    // Start block index.
    uint64 StartIndex = 3;

    // Logical block size
    uint32 BlockSize = 4;

    // Blocks to write.
    TIOVector Blocks = 5;

    // Session identifier.
    // string SessionId = 6; // obsolete

    // RequestId generated by TVolumeAgent
    uint64 VolumeRequestId = 7;

    // The flag is set when the original request is split into requests to
    // multiple devices
    bool MultideviceRequest = 8;

    // Used to propagate request to multiple disk-agents.
    repeated TReplicationTarget ReplicationTargets = 9;
}

message TWriteDeviceBlocksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Used to validate multi-agent requests.
    repeated NCloud.NProto.TError ReplicationResponses = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Blocks zero request/response.

message TZeroDeviceBlocksRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // UUID of device to write to.
    string DeviceUUID = 2;

    // Start block index.
    uint64 StartIndex = 3;

    // Logical block size
    uint32 BlockSize = 4;

    // Number of blocks to delete.
    uint32 BlocksCount = 5;

    // Session identifier.
    // string SessionId = 6; // obsolete

    // RequestId generated by TVolumeAgent
    uint64 VolumeRequestId = 7;

    // The flag is set when the original request is split into requests to
    // multiple devices
    bool MultideviceRequest = 8;
}

message TZeroDeviceBlocksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Blocks direct copy request/response.

message TDirectCopyBlocksRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // UUID of source device to read from.
    string SourceDeviceUUID = 2;

    // Start block index on source id.
    uint64 SourceStartIndex = 3;

    // Logical block size
    uint32 BlockSize = 4;

    // Number of blocks to copy.
    uint32 BlockCount = 5;

    // NodeId of target host.
    uint32 TargetNodeId = 6;

    // ClientId for writing.
    string TargetClientId = 7;

    // UUID of target device to write.
    string TargetDeviceUUID = 8;

    // Start block index on target device.
    uint64 TargetStartIndex = 9;
}

message TDirectCopyBlocksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // If true, it means that all the data read was zeros.
    // It's a hint, false negatives are allowed.
    bool AllZeroes = 2;

    // The time spent reading the data (in microseconds).
    uint64 ReadDuration = 3;

    // The time spent writing the data (in microseconds).
    uint64 WriteDuration = 4;

    // The disk agent's recommended bandwidth for copying blocks.
    uint64 RecommendedBandwidth = 5;
}

////////////////////////////////////////////////////////////////////////////////
// Update Disk Registry config

message TUpdateConfigRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    TDiskRegistryConfig Config = 2;

    // Ignore affected disks and force to apply config
    // Removed. See NBS-2299.
    // bool ForceUpdate = 3;

    // Ignore config version and force to apply config
    bool IgnoreVersion = 4;
}

message TUpdateConfigResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Disks that depend on removed devices
    repeated string AffectedDisks = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Describe Disk Registry config

message TDescribeConfigRequest
{
    // Optional request headers.
    THeaders Headers = 1;
}

message TDescribeConfigResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    TDiskRegistryConfig Config = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Secure erase devices

message TSecureEraseDeviceRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    string DeviceUUID = 2;
}

message TSecureEraseDeviceResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Checksum blocks request/response.

message TChecksumDeviceBlocksRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // UUID of device to read from.
    string DeviceUUID = 2;

    // Start block index.
    uint64 StartIndex = 3;

    // Logical block size
    uint32 BlockSize = 4;

    // Number of blocks to read.
    uint32 BlocksCount = 5;

    // Session identifier.
    // string SessionId = 6; // obsolete
}

message TChecksumDeviceBlocksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Requested blocks checksum.
    uint64 Checksum = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Disable agent request/response.

message TDisableConcreteAgentRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Optional device filter - if set, only the specified devices will be
    // affected.
    repeated string DeviceUUIDs = 2;
}

message TDisableConcreteAgentResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Eanble agent devices request/response.

message TEnableAgentDeviceRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // The specified device will be enabled back after
    // disabling via TDisableConcreteAgentRequest.
    string DeviceUUID = 2;
}

message TEnableAgentDeviceResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Disk registry force migration request/response.

message TStartForceMigrationRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Disk whose device will be migrated.
    string SourceDiskId = 2;

    // Device to migrate.
    string SourceDeviceId = 3;

    // Target device for migration.
    string TargetDeviceId = 4;
}

message TStartForceMigrationResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TUpdateAgentStatsRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    TAgentStats AgentStats = 2;
}

message TUpdateAgentStatsResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReplaceDeviceRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Target disk
    string DiskId = 2;

    // Device to be replaced
    string DeviceUUID = 3;

    // Device to use for the replacement
    string DeviceReplacementUUID = 4;
}

message TReplaceDeviceResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TChangeDeviceStateRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Target device.
    string DeviceUUID = 2;

    // New state.
    EDeviceState DeviceState = 3;

    // Reason for the new state.
    string Reason = 4;
}

message TChangeDeviceStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TChangeAgentStateRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Target agent.
    string AgentId = 2;

    // New state.
    EAgentState AgentState = 3;

    // Reason for the new state.
    string Reason = 4;
}

message TChangeAgentStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TDisableAgentRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Target agent.
    string AgentId = 2;

    // Optional device filter - if set, only the specified devices will be
    // affected.
    repeated string DeviceUUIDs = 3;
}

message TDisableAgentResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TDeviceMigrationIds
{
    // Migration source device id
    string SourceDeviceId = 1;

    // Migration target device id
    string TargetDeviceId = 2;
}

message TFinishMigrationRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Label of volume.
    string DiskId = 2;

    // Migrations.
    repeated TDeviceMigrationIds Migrations = 3;
}

message TFinishMigrationResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Backup Disk Registry state

message TBackupDiskRegistryStateRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Backup local DB instead of memory state.
    bool BackupLocalDB = 2;

    // File to save backup file.
    string BackupFilePath = 3;
}

message TBackupDiskRegistryStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Disk Regsitry state backup
    TDiskRegistryStateBackup Backup = 2;

    // File to save backup file.
    string BackupFilePath = 3;
}

////////////////////////////////////////////////////////////////////////////////
// Restore Disk Registry state

message TRestoreDiskRegistryStateRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Disk Registry state backup.
    TDiskRegistryStateBackup Backup = 2;

    // Ignore validation check.
    bool Force = 3;
}

message TRestoreDiskRegistryStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Allows/forbids DiskRegistry tablet to modify local database.

message TSetWritableStateRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Change writable state option.
    bool State = 2;
}

message TSetWritableStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TMarkDiskForCleanupRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Volume label.
    string DiskId = 2;
}

message TMarkDiskForCleanupResponse
{
    // Optional error, will be set if error occured.
    NCloud.NProto.TError Error = 1;
}


////////////////////////////////////////////////////////////////////////////////

message TSetUserIdRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Volume label.
    string DiskId = 2;

    // User IAM ID for notifications.
    string UserId = 3;
}

message TSetUserIdResponse
{
    // Optional error, will be set if error occured.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TUpdateDiskBlockSizeRequest
{
    // Disk identifier to perform operations on.
    string DiskId = 1;

    // Disk block size in bytes.
    uint32 BlockSize = 2;

    // Force dangerous actions
    bool Force = 3;
}

message TUpdateDiskBlockSizeResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TUpdateDiskReplicaCountRequest
{
    // Disk identifier to perform operations on.
    string MasterDiskId = 1;

    // Desired replica count
    uint32 ReplicaCount = 2;
}

message TUpdateDiskReplicaCountResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TMarkReplacementDeviceRequest
{
    // Disk identifier to perform operations on.
    string DiskId = 1;

    // Device id to mark.
    string DeviceId = 2;

    // Adds/removes this device to the replacement list.
    bool IsReplacement = 3;
}

message TMarkReplacementDeviceResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Suspend device

message TSuspendDeviceRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Device id.
    string DeviceId = 2;
}

message TSuspendDeviceResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Update placement group settings

message TUpdatePlacementGroupSettingsRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Id of the group.
    string GroupId = 2;

    // Config version.
    uint32 ConfigVersion = 3;

    // Settings.
    TPlacementGroupSettings Settings = 4;
}

message TUpdatePlacementGroupSettingsResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Volume create from devices request/response.

message TCreateVolumeFromDevicesRequest
{
    // Label of volume to create.
    string DiskId = 1;

    // Owner information.
    string ProjectId = 2;

    // User folder Id, used for billing.
    string FolderId = 3;

    // Cloud Id, used for billing.
    string CloudId = 4;

    // Block size in bytes
    uint32 BlockSize = 5;

    // Devices from which the disk is assembled
    repeated string DeviceUUIDs = 6;
}

message TCreateVolumeFromDevicesResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Update disk registry params

message TUpdateDiskRegistryAgentListParamsRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Params to update
    TDiskRegistryAgentListRequestParams Params = 3;
}

message TUpdateDiskRegistryAgentListParamsResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Get dependent disks

message TGetDependentDisksRequest
{
    // Agent hostname to search for dependent disks
    string Host = 1;

    // Device path (ignored if empty)
    string Path = 2;

    // Do not count replicated disks
    bool IgnoreReplicatedDisks = 3;
}

message TGetDependentDisksResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Timeout to retry if E_TRY_AGAIN returned (in seconds).
    uint64 Timeout = 2;

    // List of agent's dependent disks
    repeated string DependentDiskIds = 3;
}

////////////////////////////////////////////////////////////////////////////////
// Allocate disk for checkpoint replica

message TAllocateCheckpointRequest
{
    // The name of the disk for which the checkpoint is being created.
    string SourceDiskId = 1;

    // The name of the checkpoint.
    string CheckpointId = 2;
}

message TAllocateCheckpointResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // The name of the disk on which the replica for the checkpoint was created.
    string ShadowDiskId = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Deallocate disk for checkpoint replica

message TDeallocateCheckpointRequest
{
    // The name of the disk for which the checkpoint was created.
    string SourceDiskId = 1;

    // The name of the checkpoint.
    string CheckpointId = 2;
}

message TDeallocateCheckpointResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Get current data state for checkpoint replica

message TGetCheckpointDataStateRequest
{
    // The name of the disk for which the checkpoint was created.
    string SourceDiskId = 1;

    // The name of the checkpoint.
    string CheckpointId = 2;
}

message TGetCheckpointDataStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Checkpoint data state.
    ECheckpointState CheckpointState = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Set current data state for checkpoint replica

message TSetCheckpointDataStateRequest
{
    // The name of the disk for which the checkpoint was created.
    string SourceDiskId = 1;

    // The name of the checkpoint.
    string CheckpointId = 2;

    // New checkpoint data state.
    ECheckpointState CheckpointState = 3;
}

message TSetCheckpointDataStateResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Get disk agent node id by agent id.

message TGetAgentNodeIdRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Target agent.
    string AgentId = 2;
}

message TGetAgentNodeIdResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Node that agent is running on.
    uint32 NodeId = 2;

    // Agent state.
    EAgentState AgentState = 3;

    // Whether the agent is connected to the DR or not.
    bool Connected = 4;
}

////////////////////////////////////////////////////////////////////////////////
// Report that some of the devices were lagging.

message TAddLaggingDevicesRequest
{
    // Optional request headers.
    THeaders Headers = 1;

    // Disk identifier to perform operations on.
    string DiskId = 2;

    // Devices that has been lagging.
    repeated TLaggingDevice LaggingDevices = 3;
}

message TAddLaggingDevicesResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

////////////////////////////////////////////////////////////////////////////////
// Get dependent disks

message TWaitDependentDisksToSwitchNodeRequest
{
    // Target agent.
    string AgentId = 1;

    // Wait for this Disk Agent node id to disappear from dependent volume
    // configs.
    uint32 OldNodeId = 2;
}

message TWaitDependentDisksToSwitchNodeResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;

    // Possible disk states during switching.
    enum EDiskState
    {
        // Initial state.
        DISK_STATE_INITIAL = 0;

        // Disk has switched its node id.
        DISK_STATE_SWITCHED = 1;

        // The volume is ready.
        DISK_STATE_READY = 2;

        // An error occured during waiting.
        DISK_STATE_ERROR = 3;
    }

    message TDependentDiskState
    {
        // Disk id.
        string DiskId = 1;

        // Disk state.
        EDiskState DiskState = 2;
    }

    // List of disks with their corresponding states at the time of the actor's
    // shutdown.
    repeated TDependentDiskState DependentDiskStates = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Partially suspend agent. Used for blue-green deployment.
// We need to prepare a running instance that a new instance will be launched
// soon.

message TPartiallySuspendAgentRequest
{
    // Node that agent is running on.
    uint32 NodeId = 1;

    // Time in ms until Disk Agent goes back to working state.
    uint32 CancelSuspensionDelay  = 2;
}

message TPartiallySuspendAgentResponse
{
    // Optional error, set only if error happened.
    NCloud.NProto.TError Error = 1;
}

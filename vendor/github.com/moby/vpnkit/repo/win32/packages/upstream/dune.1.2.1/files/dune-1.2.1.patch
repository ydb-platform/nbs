--- ./src/action_exec.ml
+++ ./src/action_exec.ml
@@ -89,8 +89,21 @@
     Io.copy_file ~src ~dst ();
     Fiber.return ()
   | Symlink (src, dst) ->
-    if Sys.win32 then
-      Io.copy_file ~src ~dst ()
+    if Sys.win32 then (
+      Io.copy_file ~src ~dst ();
+      let src = Path.to_string src in
+      let dst = Path.to_string dst in
+      let st = Unix.stat src in
+      try
+        Unix.(utimes dst st.st_mtime st.st_mtime)
+      with
+      | Unix.Unix_error _ ->
+        try
+          Unix.chmod dst 0o666;
+          protectx () ~finally:(fun () -> Unix.(chmod dst st.st_perm)) ~f:(fun () ->
+              Unix.(utimes dst st.st_mtime st.st_mtime))
+        with
+        | Unix.Unix_error _ -> ())
     else begin
       let src =
         match Path.parent dst with
--- ./src/import.ml
+++ ./src/import.ml
@@ -25,6 +25,9 @@
           remove fn
     else
       remove
+
+  let ocaml_major,ocaml_minor =
+    Scanf.sscanf ocaml_version "%u.%u" (fun a b -> a, b)
 end

 type ('a, 'b) eq = Eq : ('a, 'a) eq
--- ./src/process.ml
+++ ./src/process.ml
@@ -198,12 +198,21 @@
                [O_WRONLY; O_CREAT; O_TRUNC; O_SHARE_DELETE] 0o666 in
     (fd, Some (Fd fd))
   | Opened_file { desc; tail; _ } ->
-    let fd =
-      match desc with
-      | Fd      fd -> fd
-      | Channel oc -> flush oc; Unix.descr_of_out_channel oc
-    in
-    (fd, Option.some_if tail desc)
+    match desc with
+    | Fd      fd -> (fd, Option.some_if tail desc)
+    | Channel oc ->
+      flush oc;
+      let fd = Unix.descr_of_out_channel oc in
+      (* Since OCaml 4.05.0 HANDLES passed to CreateProcess are
+         duplicated by default. *)
+      if Sys.(win32 = false || (ocaml_major,ocaml_minor) >= (4,5)) then
+        (fd, Option.some_if tail desc)
+      else begin
+        let fd' = Unix.dup fd in
+        if tail then
+          close_out oc;
+        fd', Some (Fd fd')
+      end

 let close_std_output = function
   | None -> ()
--- ./src/stdune/io.ml
+++ ./src/stdune/io.ml
@@ -44,6 +44,84 @@
   val copy_file : ?chmod:(int -> int) -> src:path -> dst:path -> unit -> unit
 end

+module Win32_io = struct
+
+  (* Pervasives.open* support neither O_CLOEXEC nor O_SHARE_DELETE *)
+
+  let sys_exn e fn =
+    let msg = fn ^ ":" ^ Unix.error_message e in
+    raise (Sys_error msg)
+
+  let eclose ecode fd fn =
+    (try Unix.close fd with Unix.Unix_error _ -> ());
+    sys_exn ecode fn
+
+  let open_gen mode perm fn =
+    let init = [Unix.O_SHARE_DELETE ; Unix.O_CLOEXEC] in
+    let trans acc = function
+    |    Open_rdonly -> Unix.O_RDONLY::acc
+    |    Open_wronly -> Unix.O_WRONLY::acc
+    |    Open_creat -> Unix.O_CREAT::acc
+    |    Open_trunc -> Unix.O_TRUNC::acc
+    |    Open_excl -> Unix.O_EXCL::acc
+    |    Open_nonblock -> Unix.O_NONBLOCK::acc
+    |    Open_append (* lseek must be used, if the HANDLE might be passed
+                     to a child process. The not implemented support of
+                     Unix.O_APPEND (FILE_APPEND_DATA) would probably not work
+                     in this case anyway *)
+    |    Open_binary (* Open_binary/Open_text are handled in open_(in|out)_gen *)
+    |    Open_text -> acc in
+    let m = List.fold_left ~f:trans ~init mode in
+    match Unix.openfile fn m perm with
+    | exception (Unix.Unix_error(x,_,_)) -> sys_exn x fn
+    | fd ->
+      if List.mem Open_append ~set:mode then (
+        try
+          ignore (Unix.lseek fd 0 Unix.SEEK_END : int)
+        with
+        | Unix.Unix_error(e,_,_) -> eclose e fd fn
+      );
+      fd
+
+  let open_out_gen mode perm fn =
+    let fd = open_gen mode perm fn in
+    match Unix.out_channel_of_descr fd with
+    | exception (Unix.Unix_error(e,_,_)) -> eclose e fd fn
+    | oc ->
+      if List.mem Open_text ~set:mode then (
+        try
+          set_binary_mode_out oc false
+        with
+        | x -> close_out oc ; raise x
+      );
+      oc
+
+  let open_out name =
+    open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name
+
+  let open_out_bin name =
+    open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name
+
+  let open_in_gen mode perm fn =
+    let fd = open_gen mode perm fn in
+    match Unix.in_channel_of_descr fd with
+    | exception (Unix.Unix_error(e,_,_)) -> eclose e fd fn
+    | ic ->
+      if List.mem Open_text ~set:mode then (
+        try
+          set_binary_mode_in ic false
+        with
+        | x -> close_in ic ; raise x
+      );
+      ic
+
+  let open_in name =
+    open_in_gen [Open_rdonly; Open_text] 0 name
+
+  let open_in_bin name =
+    open_in_gen [Open_rdonly; Open_binary] 0 name
+end
+
 module Make (Path : sig
     type t
     val to_string : t -> string
@@ -53,11 +131,17 @@

   let open_in ?(binary=true) p =
     let fn = Path.to_string p in
-    if binary then P.open_in_bin fn else P.open_in fn
+    if Sys.win32 then
+      if binary then Win32_io.open_in_bin fn else Win32_io.open_in fn
+    else
+      if binary then P.open_in_bin fn else P.open_in fn

   let open_out ?(binary=true) p =
     let fn = Path.to_string p in
-    if binary then P.open_out_bin fn else P.open_out fn
+    if Sys.win32 then
+      if binary then Win32_io.open_out_bin fn else Win32_io.open_out fn
+    else
+      if binary then P.open_out_bin fn else P.open_out fn

   let with_file_in ?binary fn ~f =
     Exn.protectx (open_in ?binary fn) ~finally:close_in ~f

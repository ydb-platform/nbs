#line 1 "numpy/core/src/multiarray/einsum.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/*
 * This file contains the implementation of the 'einsum' function,
 * which provides an einstein-summation operation.
 *
 * Copyright (c) 2011 by Mark Wiebe (mwwiebe@gmail.com)
 * The University of British Columbia
 *
 * See LICENSE.txt for the license.
 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#define _MULTIARRAYMODULE
#include <numpy/npy_common.h>
#include <numpy/arrayobject.h>
#include <numpy/halffloat.h>
#include <npy_pycompat.h>

#include <ctype.h>

#include "convert.h"
#include "common.h"
#include "ctors.h"

#ifdef NPY_HAVE_SSE_INTRINSICS
#define EINSUM_USE_SSE1 1
#else
#define EINSUM_USE_SSE1 0
#endif

/*
 * TODO: Only some SSE2 for float64 is implemented.
 */
#ifdef NPY_HAVE_SSE2_INTRINSICS
#define EINSUM_USE_SSE2 1
#else
#define EINSUM_USE_SSE2 0
#endif

#if EINSUM_USE_SSE1
#include <xmmintrin.h>
#endif

#if EINSUM_USE_SSE2
#include <emmintrin.h>
#endif

#define EINSUM_IS_SSE_ALIGNED(x) ((((npy_intp)x)&0xf) == 0)

/********** PRINTF DEBUG TRACING **************/
#define NPY_EINSUM_DBG_TRACING 0

#if NPY_EINSUM_DBG_TRACING
#define NPY_EINSUM_DBG_PRINT(s) printf("%s", s);
#define NPY_EINSUM_DBG_PRINT1(s, p1) printf(s, p1);
#define NPY_EINSUM_DBG_PRINT2(s, p1, p2) printf(s, p1, p2);
#define NPY_EINSUM_DBG_PRINT3(s, p1, p2, p3) printf(s);
#else
#define NPY_EINSUM_DBG_PRINT(s)
#define NPY_EINSUM_DBG_PRINT1(s, p1)
#define NPY_EINSUM_DBG_PRINT2(s, p1, p2)
#define NPY_EINSUM_DBG_PRINT3(s, p1, p2, p3)
#endif
/**********************************************/

#line 103

#line 108
static void
byte_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_byte *)data_out = ((*(npy_byte *)data0) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) *
                                         (*(npy_byte *)data2) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_byte *)data_out)[0] = ((npy_byte *)data0)[0] +
                                         ((npy_byte *)data_out)[0];
        ((npy_byte *)data_out)[1] = ((npy_byte *)data0)[1] +
                                         ((npy_byte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
byte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data_out = (npy_byte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_byte *)data_out + 2*6)[0] =
                                    ((npy_byte *)data0 + 2*6)[0] +
                                    ((npy_byte *)data_out + 2*6)[0];
            ((npy_byte *)data_out + 2*6)[1] =
                                    ((npy_byte *)data0 + 2*6)[1] +
                                    ((npy_byte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_byte *)data_out + 2*5)[0] =
                                    ((npy_byte *)data0 + 2*5)[0] +
                                    ((npy_byte *)data_out + 2*5)[0];
            ((npy_byte *)data_out + 2*5)[1] =
                                    ((npy_byte *)data0 + 2*5)[1] +
                                    ((npy_byte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_byte *)data_out + 2*4)[0] =
                                    ((npy_byte *)data0 + 2*4)[0] +
                                    ((npy_byte *)data_out + 2*4)[0];
            ((npy_byte *)data_out + 2*4)[1] =
                                    ((npy_byte *)data0 + 2*4)[1] +
                                    ((npy_byte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_byte *)data_out + 2*3)[0] =
                                    ((npy_byte *)data0 + 2*3)[0] +
                                    ((npy_byte *)data_out + 2*3)[0];
            ((npy_byte *)data_out + 2*3)[1] =
                                    ((npy_byte *)data0 + 2*3)[1] +
                                    ((npy_byte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_byte *)data_out + 2*2)[0] =
                                    ((npy_byte *)data0 + 2*2)[0] +
                                    ((npy_byte *)data_out + 2*2)[0];
            ((npy_byte *)data_out + 2*2)[1] =
                                    ((npy_byte *)data0 + 2*2)[1] +
                                    ((npy_byte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_byte *)data_out + 2*1)[0] =
                                    ((npy_byte *)data0 + 2*1)[0] +
                                    ((npy_byte *)data_out + 2*1)[0];
            ((npy_byte *)data_out + 2*1)[1] =
                                    ((npy_byte *)data0 + 2*1)[1] +
                                    ((npy_byte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_byte *)data_out + 2*0)[0] =
                                    ((npy_byte *)data0 + 2*0)[0] +
                                    ((npy_byte *)data_out + 2*0)[0];
            ((npy_byte *)data_out + 2*0)[1] =
                                    ((npy_byte *)data0 + 2*0)[1] +
                                    ((npy_byte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_byte *)data_out + 2*0)[0] =
                                ((npy_byte *)data0 + 2*0)[0] +
                                ((npy_byte *)data_out + 2*0)[0];
        ((npy_byte *)data_out + 2*0)[1] =
                                ((npy_byte *)data0 + 2*0)[1] +
                                ((npy_byte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_byte *)data_out + 2*1)[0] =
                                ((npy_byte *)data0 + 2*1)[0] +
                                ((npy_byte *)data_out + 2*1)[0];
        ((npy_byte *)data_out + 2*1)[1] =
                                ((npy_byte *)data0 + 2*1)[1] +
                                ((npy_byte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_byte *)data_out + 2*2)[0] =
                                ((npy_byte *)data0 + 2*2)[0] +
                                ((npy_byte *)data_out + 2*2)[0];
        ((npy_byte *)data_out + 2*2)[1] =
                                ((npy_byte *)data0 + 2*2)[1] +
                                ((npy_byte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_byte *)data_out + 2*3)[0] =
                                ((npy_byte *)data0 + 2*3)[0] +
                                ((npy_byte *)data_out + 2*3)[0];
        ((npy_byte *)data_out + 2*3)[1] =
                                ((npy_byte *)data0 + 2*3)[1] +
                                ((npy_byte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_byte *)data_out + 2*4)[0] =
                                ((npy_byte *)data0 + 2*4)[0] +
                                ((npy_byte *)data_out + 2*4)[0];
        ((npy_byte *)data_out + 2*4)[1] =
                                ((npy_byte *)data0 + 2*4)[1] +
                                ((npy_byte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_byte *)data_out + 2*5)[0] =
                                ((npy_byte *)data0 + 2*5)[0] +
                                ((npy_byte *)data_out + 2*5)[0];
        ((npy_byte *)data_out + 2*5)[1] =
                                ((npy_byte *)data0 + 2*5)[1] +
                                ((npy_byte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_byte *)data_out + 2*6)[0] =
                                ((npy_byte *)data0 + 2*6)[0] +
                                ((npy_byte *)data_out + 2*6)[0];
        ((npy_byte *)data_out + 2*6)[1] =
                                ((npy_byte *)data0 + 2*6)[1] +
                                ((npy_byte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_byte *)data_out + 2*7)[0] =
                                ((npy_byte *)data0 + 2*7)[0] +
                                ((npy_byte *)data_out + 2*7)[0];
        ((npy_byte *)data_out + 2*7)[1] =
                                ((npy_byte *)data0 + 2*7)[1] +
                                ((npy_byte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
byte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
byte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
byte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
byte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data2 = (npy_byte *)dataptr[2];
    npy_byte *data_out = (npy_byte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
byte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
byte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#else
    npy_byte accum = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_byte *)dataptr[1])[0] += accum_re;
            ((npy_byte *)dataptr[1])[1] += accum_im;
#else
            *((npy_byte *)dataptr[1]) = (accum +
                                    (*((npy_byte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
byte_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
#else
    npy_byte accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_byte *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1) *
                 (*(npy_byte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_byte *)data0)[0];
        accum_im += ((npy_byte *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_byte *)dataptr[1])[0] += accum_re;
    ((npy_byte *)dataptr[1])[1] += accum_im;
#  else
    ((npy_byte *)dataptr[nop])[0] += accum_re;
    ((npy_byte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_byte *)dataptr[1]) = (accum +
                                    (*((npy_byte *)dataptr[1])));
#  else
    *((npy_byte *)dataptr[nop]) = (accum +
                                    (*((npy_byte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
byte_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_byte *)data_out = ((*(npy_byte *)data0) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) *
                                         (*(npy_byte *)data2) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_byte *)data_out)[0] = ((npy_byte *)data0)[0] +
                                         ((npy_byte *)data_out)[0];
        ((npy_byte *)data_out)[1] = ((npy_byte *)data0)[1] +
                                         ((npy_byte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
byte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data_out = (npy_byte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_byte *)data_out + 2*6)[0] =
                                    ((npy_byte *)data0 + 2*6)[0] +
                                    ((npy_byte *)data_out + 2*6)[0];
            ((npy_byte *)data_out + 2*6)[1] =
                                    ((npy_byte *)data0 + 2*6)[1] +
                                    ((npy_byte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_byte *)data_out + 2*5)[0] =
                                    ((npy_byte *)data0 + 2*5)[0] +
                                    ((npy_byte *)data_out + 2*5)[0];
            ((npy_byte *)data_out + 2*5)[1] =
                                    ((npy_byte *)data0 + 2*5)[1] +
                                    ((npy_byte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_byte *)data_out + 2*4)[0] =
                                    ((npy_byte *)data0 + 2*4)[0] +
                                    ((npy_byte *)data_out + 2*4)[0];
            ((npy_byte *)data_out + 2*4)[1] =
                                    ((npy_byte *)data0 + 2*4)[1] +
                                    ((npy_byte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_byte *)data_out + 2*3)[0] =
                                    ((npy_byte *)data0 + 2*3)[0] +
                                    ((npy_byte *)data_out + 2*3)[0];
            ((npy_byte *)data_out + 2*3)[1] =
                                    ((npy_byte *)data0 + 2*3)[1] +
                                    ((npy_byte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_byte *)data_out + 2*2)[0] =
                                    ((npy_byte *)data0 + 2*2)[0] +
                                    ((npy_byte *)data_out + 2*2)[0];
            ((npy_byte *)data_out + 2*2)[1] =
                                    ((npy_byte *)data0 + 2*2)[1] +
                                    ((npy_byte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_byte *)data_out + 2*1)[0] =
                                    ((npy_byte *)data0 + 2*1)[0] +
                                    ((npy_byte *)data_out + 2*1)[0];
            ((npy_byte *)data_out + 2*1)[1] =
                                    ((npy_byte *)data0 + 2*1)[1] +
                                    ((npy_byte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_byte *)data_out + 2*0)[0] =
                                    ((npy_byte *)data0 + 2*0)[0] +
                                    ((npy_byte *)data_out + 2*0)[0];
            ((npy_byte *)data_out + 2*0)[1] =
                                    ((npy_byte *)data0 + 2*0)[1] +
                                    ((npy_byte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_byte *)data_out + 2*0)[0] =
                                ((npy_byte *)data0 + 2*0)[0] +
                                ((npy_byte *)data_out + 2*0)[0];
        ((npy_byte *)data_out + 2*0)[1] =
                                ((npy_byte *)data0 + 2*0)[1] +
                                ((npy_byte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_byte *)data_out + 2*1)[0] =
                                ((npy_byte *)data0 + 2*1)[0] +
                                ((npy_byte *)data_out + 2*1)[0];
        ((npy_byte *)data_out + 2*1)[1] =
                                ((npy_byte *)data0 + 2*1)[1] +
                                ((npy_byte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_byte *)data_out + 2*2)[0] =
                                ((npy_byte *)data0 + 2*2)[0] +
                                ((npy_byte *)data_out + 2*2)[0];
        ((npy_byte *)data_out + 2*2)[1] =
                                ((npy_byte *)data0 + 2*2)[1] +
                                ((npy_byte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_byte *)data_out + 2*3)[0] =
                                ((npy_byte *)data0 + 2*3)[0] +
                                ((npy_byte *)data_out + 2*3)[0];
        ((npy_byte *)data_out + 2*3)[1] =
                                ((npy_byte *)data0 + 2*3)[1] +
                                ((npy_byte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_byte *)data_out + 2*4)[0] =
                                ((npy_byte *)data0 + 2*4)[0] +
                                ((npy_byte *)data_out + 2*4)[0];
        ((npy_byte *)data_out + 2*4)[1] =
                                ((npy_byte *)data0 + 2*4)[1] +
                                ((npy_byte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_byte *)data_out + 2*5)[0] =
                                ((npy_byte *)data0 + 2*5)[0] +
                                ((npy_byte *)data_out + 2*5)[0];
        ((npy_byte *)data_out + 2*5)[1] =
                                ((npy_byte *)data0 + 2*5)[1] +
                                ((npy_byte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_byte *)data_out + 2*6)[0] =
                                ((npy_byte *)data0 + 2*6)[0] +
                                ((npy_byte *)data_out + 2*6)[0];
        ((npy_byte *)data_out + 2*6)[1] =
                                ((npy_byte *)data0 + 2*6)[1] +
                                ((npy_byte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_byte *)data_out + 2*7)[0] =
                                ((npy_byte *)data0 + 2*7)[0] +
                                ((npy_byte *)data_out + 2*7)[0];
        ((npy_byte *)data_out + 2*7)[1] =
                                ((npy_byte *)data0 + 2*7)[1] +
                                ((npy_byte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
byte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
byte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
byte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
byte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data2 = (npy_byte *)dataptr[2];
    npy_byte *data_out = (npy_byte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
byte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
byte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#else
    npy_byte accum = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_byte *)dataptr[1])[0] += accum_re;
            ((npy_byte *)dataptr[1])[1] += accum_im;
#else
            *((npy_byte *)dataptr[1]) = (accum +
                                    (*((npy_byte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
byte_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
#else
    npy_byte accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_byte *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1) *
                 (*(npy_byte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_byte *)data0)[0];
        accum_im += ((npy_byte *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_byte *)dataptr[2])[0] += accum_re;
    ((npy_byte *)dataptr[2])[1] += accum_im;
#  else
    ((npy_byte *)dataptr[nop])[0] += accum_re;
    ((npy_byte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_byte *)dataptr[2]) = (accum +
                                    (*((npy_byte *)dataptr[2])));
#  else
    *((npy_byte *)dataptr[nop]) = (accum +
                                    (*((npy_byte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
byte_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_byte *)data_out = ((*(npy_byte *)data0) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) *
                                         (*(npy_byte *)data2) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_byte *)data_out)[0] = ((npy_byte *)data0)[0] +
                                         ((npy_byte *)data_out)[0];
        ((npy_byte *)data_out)[1] = ((npy_byte *)data0)[1] +
                                         ((npy_byte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
byte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data_out = (npy_byte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_byte *)data_out + 2*6)[0] =
                                    ((npy_byte *)data0 + 2*6)[0] +
                                    ((npy_byte *)data_out + 2*6)[0];
            ((npy_byte *)data_out + 2*6)[1] =
                                    ((npy_byte *)data0 + 2*6)[1] +
                                    ((npy_byte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_byte *)data_out + 2*5)[0] =
                                    ((npy_byte *)data0 + 2*5)[0] +
                                    ((npy_byte *)data_out + 2*5)[0];
            ((npy_byte *)data_out + 2*5)[1] =
                                    ((npy_byte *)data0 + 2*5)[1] +
                                    ((npy_byte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_byte *)data_out + 2*4)[0] =
                                    ((npy_byte *)data0 + 2*4)[0] +
                                    ((npy_byte *)data_out + 2*4)[0];
            ((npy_byte *)data_out + 2*4)[1] =
                                    ((npy_byte *)data0 + 2*4)[1] +
                                    ((npy_byte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_byte *)data_out + 2*3)[0] =
                                    ((npy_byte *)data0 + 2*3)[0] +
                                    ((npy_byte *)data_out + 2*3)[0];
            ((npy_byte *)data_out + 2*3)[1] =
                                    ((npy_byte *)data0 + 2*3)[1] +
                                    ((npy_byte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_byte *)data_out + 2*2)[0] =
                                    ((npy_byte *)data0 + 2*2)[0] +
                                    ((npy_byte *)data_out + 2*2)[0];
            ((npy_byte *)data_out + 2*2)[1] =
                                    ((npy_byte *)data0 + 2*2)[1] +
                                    ((npy_byte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_byte *)data_out + 2*1)[0] =
                                    ((npy_byte *)data0 + 2*1)[0] +
                                    ((npy_byte *)data_out + 2*1)[0];
            ((npy_byte *)data_out + 2*1)[1] =
                                    ((npy_byte *)data0 + 2*1)[1] +
                                    ((npy_byte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_byte *)data_out + 2*0)[0] =
                                    ((npy_byte *)data0 + 2*0)[0] +
                                    ((npy_byte *)data_out + 2*0)[0];
            ((npy_byte *)data_out + 2*0)[1] =
                                    ((npy_byte *)data0 + 2*0)[1] +
                                    ((npy_byte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_byte *)data_out + 2*0)[0] =
                                ((npy_byte *)data0 + 2*0)[0] +
                                ((npy_byte *)data_out + 2*0)[0];
        ((npy_byte *)data_out + 2*0)[1] =
                                ((npy_byte *)data0 + 2*0)[1] +
                                ((npy_byte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_byte *)data_out + 2*1)[0] =
                                ((npy_byte *)data0 + 2*1)[0] +
                                ((npy_byte *)data_out + 2*1)[0];
        ((npy_byte *)data_out + 2*1)[1] =
                                ((npy_byte *)data0 + 2*1)[1] +
                                ((npy_byte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_byte *)data_out + 2*2)[0] =
                                ((npy_byte *)data0 + 2*2)[0] +
                                ((npy_byte *)data_out + 2*2)[0];
        ((npy_byte *)data_out + 2*2)[1] =
                                ((npy_byte *)data0 + 2*2)[1] +
                                ((npy_byte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_byte *)data_out + 2*3)[0] =
                                ((npy_byte *)data0 + 2*3)[0] +
                                ((npy_byte *)data_out + 2*3)[0];
        ((npy_byte *)data_out + 2*3)[1] =
                                ((npy_byte *)data0 + 2*3)[1] +
                                ((npy_byte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_byte *)data_out + 2*4)[0] =
                                ((npy_byte *)data0 + 2*4)[0] +
                                ((npy_byte *)data_out + 2*4)[0];
        ((npy_byte *)data_out + 2*4)[1] =
                                ((npy_byte *)data0 + 2*4)[1] +
                                ((npy_byte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_byte *)data_out + 2*5)[0] =
                                ((npy_byte *)data0 + 2*5)[0] +
                                ((npy_byte *)data_out + 2*5)[0];
        ((npy_byte *)data_out + 2*5)[1] =
                                ((npy_byte *)data0 + 2*5)[1] +
                                ((npy_byte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_byte *)data_out + 2*6)[0] =
                                ((npy_byte *)data0 + 2*6)[0] +
                                ((npy_byte *)data_out + 2*6)[0];
        ((npy_byte *)data_out + 2*6)[1] =
                                ((npy_byte *)data0 + 2*6)[1] +
                                ((npy_byte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_byte *)data_out + 2*7)[0] =
                                ((npy_byte *)data0 + 2*7)[0] +
                                ((npy_byte *)data_out + 2*7)[0];
        ((npy_byte *)data_out + 2*7)[1] =
                                ((npy_byte *)data0 + 2*7)[1] +
                                ((npy_byte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
byte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
byte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
byte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
byte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data2 = (npy_byte *)dataptr[2];
    npy_byte *data_out = (npy_byte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
byte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
byte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#else
    npy_byte accum = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_byte *)dataptr[1])[0] += accum_re;
            ((npy_byte *)dataptr[1])[1] += accum_im;
#else
            *((npy_byte *)dataptr[1]) = (accum +
                                    (*((npy_byte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
byte_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
#else
    npy_byte accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_byte *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1) *
                 (*(npy_byte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_byte *)data0)[0];
        accum_im += ((npy_byte *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_byte *)dataptr[3])[0] += accum_re;
    ((npy_byte *)dataptr[3])[1] += accum_im;
#  else
    ((npy_byte *)dataptr[nop])[0] += accum_re;
    ((npy_byte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_byte *)dataptr[3]) = (accum +
                                    (*((npy_byte *)dataptr[3])));
#  else
    *((npy_byte *)dataptr[nop]) = (accum +
                                    (*((npy_byte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
byte_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_byte *)data_out = ((*(npy_byte *)data0) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_byte *)data_out = ((*(npy_byte *)data0) *
                                         (*(npy_byte *)data1) *
                                         (*(npy_byte *)data2) +
                                         (*(npy_byte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_byte *)data_out)[0] = ((npy_byte *)data0)[0] +
                                         ((npy_byte *)data_out)[0];
        ((npy_byte *)data_out)[1] = ((npy_byte *)data0)[1] +
                                         ((npy_byte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
byte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data_out = (npy_byte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_byte *)data_out + 2*6)[0] =
                                    ((npy_byte *)data0 + 2*6)[0] +
                                    ((npy_byte *)data_out + 2*6)[0];
            ((npy_byte *)data_out + 2*6)[1] =
                                    ((npy_byte *)data0 + 2*6)[1] +
                                    ((npy_byte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_byte *)data_out + 2*5)[0] =
                                    ((npy_byte *)data0 + 2*5)[0] +
                                    ((npy_byte *)data_out + 2*5)[0];
            ((npy_byte *)data_out + 2*5)[1] =
                                    ((npy_byte *)data0 + 2*5)[1] +
                                    ((npy_byte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_byte *)data_out + 2*4)[0] =
                                    ((npy_byte *)data0 + 2*4)[0] +
                                    ((npy_byte *)data_out + 2*4)[0];
            ((npy_byte *)data_out + 2*4)[1] =
                                    ((npy_byte *)data0 + 2*4)[1] +
                                    ((npy_byte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_byte *)data_out + 2*3)[0] =
                                    ((npy_byte *)data0 + 2*3)[0] +
                                    ((npy_byte *)data_out + 2*3)[0];
            ((npy_byte *)data_out + 2*3)[1] =
                                    ((npy_byte *)data0 + 2*3)[1] +
                                    ((npy_byte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_byte *)data_out + 2*2)[0] =
                                    ((npy_byte *)data0 + 2*2)[0] +
                                    ((npy_byte *)data_out + 2*2)[0];
            ((npy_byte *)data_out + 2*2)[1] =
                                    ((npy_byte *)data0 + 2*2)[1] +
                                    ((npy_byte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_byte *)data_out + 2*1)[0] =
                                    ((npy_byte *)data0 + 2*1)[0] +
                                    ((npy_byte *)data_out + 2*1)[0];
            ((npy_byte *)data_out + 2*1)[1] =
                                    ((npy_byte *)data0 + 2*1)[1] +
                                    ((npy_byte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_byte *)data_out + 2*0)[0] =
                                    ((npy_byte *)data0 + 2*0)[0] +
                                    ((npy_byte *)data_out + 2*0)[0];
            ((npy_byte *)data_out + 2*0)[1] =
                                    ((npy_byte *)data0 + 2*0)[1] +
                                    ((npy_byte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_byte *)data_out + 2*0)[0] =
                                ((npy_byte *)data0 + 2*0)[0] +
                                ((npy_byte *)data_out + 2*0)[0];
        ((npy_byte *)data_out + 2*0)[1] =
                                ((npy_byte *)data0 + 2*0)[1] +
                                ((npy_byte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_byte *)data_out + 2*1)[0] =
                                ((npy_byte *)data0 + 2*1)[0] +
                                ((npy_byte *)data_out + 2*1)[0];
        ((npy_byte *)data_out + 2*1)[1] =
                                ((npy_byte *)data0 + 2*1)[1] +
                                ((npy_byte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_byte *)data_out + 2*2)[0] =
                                ((npy_byte *)data0 + 2*2)[0] +
                                ((npy_byte *)data_out + 2*2)[0];
        ((npy_byte *)data_out + 2*2)[1] =
                                ((npy_byte *)data0 + 2*2)[1] +
                                ((npy_byte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_byte *)data_out + 2*3)[0] =
                                ((npy_byte *)data0 + 2*3)[0] +
                                ((npy_byte *)data_out + 2*3)[0];
        ((npy_byte *)data_out + 2*3)[1] =
                                ((npy_byte *)data0 + 2*3)[1] +
                                ((npy_byte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_byte *)data_out + 2*4)[0] =
                                ((npy_byte *)data0 + 2*4)[0] +
                                ((npy_byte *)data_out + 2*4)[0];
        ((npy_byte *)data_out + 2*4)[1] =
                                ((npy_byte *)data0 + 2*4)[1] +
                                ((npy_byte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_byte *)data_out + 2*5)[0] =
                                ((npy_byte *)data0 + 2*5)[0] +
                                ((npy_byte *)data_out + 2*5)[0];
        ((npy_byte *)data_out + 2*5)[1] =
                                ((npy_byte *)data0 + 2*5)[1] +
                                ((npy_byte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_byte *)data_out + 2*6)[0] =
                                ((npy_byte *)data0 + 2*6)[0] +
                                ((npy_byte *)data_out + 2*6)[0];
        ((npy_byte *)data_out + 2*6)[1] =
                                ((npy_byte *)data0 + 2*6)[1] +
                                ((npy_byte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_byte *)data_out + 2*7)[0] =
                                ((npy_byte *)data0 + 2*7)[0] +
                                ((npy_byte *)data_out + 2*7)[0];
        ((npy_byte *)data_out + 2*7)[1] =
                                ((npy_byte *)data0 + 2*7)[1] +
                                ((npy_byte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
byte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
byte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
byte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte *data_out = (npy_byte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte value0 = (*(npy_byte *)dataptr[0]);
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
byte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte value1 = (*(npy_byte *)dataptr[1]);
    npy_byte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_byte *)dataptr[2] = ((*(npy_byte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
byte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_byte *data0 = (npy_byte *)dataptr[0];
    npy_byte *data1 = (npy_byte *)dataptr[1];
    npy_byte *data2 = (npy_byte *)dataptr[2];
    npy_byte *data_out = (npy_byte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
byte_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        *(npy_byte *)dataptr[nop] = (temp +
                                           (*(npy_byte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_byte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_byte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_byte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_byte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
byte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#else
    npy_byte accum = 0;
    npy_byte *data0 = (npy_byte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_byte *)dataptr[1])[0] += accum_re;
            ((npy_byte *)dataptr[1])[1] += accum_im;
#else
            *((npy_byte *)dataptr[1]) = (accum +
                                    (*((npy_byte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
byte_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_byte accum_re = 0, accum_im = 0;
#else
    npy_byte accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("byte_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_byte *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_byte *)data0) *
                 (*(npy_byte *)data1) *
                 (*(npy_byte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_byte temp = (*(npy_byte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_byte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_byte *)data0)[0];
        accum_im += ((npy_byte *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_byte re, im, tmp;
        int i;
        re = ((npy_byte *)dataptr[0])[0];
        im = ((npy_byte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_byte *)dataptr[i])[0] -
                  im * ((npy_byte *)dataptr[i])[1];
            im = re * ((npy_byte *)dataptr[i])[1] +
                 im * ((npy_byte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_byte *)dataptr[1000])[0] += accum_re;
    ((npy_byte *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_byte *)dataptr[nop])[0] += accum_re;
    ((npy_byte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_byte *)dataptr[1000]) = (accum +
                                    (*((npy_byte *)dataptr[1000])));
#  else
    *((npy_byte *)dataptr[nop]) = (accum +
                                    (*((npy_byte *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
short_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_short *)data_out = ((*(npy_short *)data0) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) *
                                         (*(npy_short *)data2) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_short *)data_out)[0] = ((npy_short *)data0)[0] +
                                         ((npy_short *)data_out)[0];
        ((npy_short *)data_out)[1] = ((npy_short *)data0)[1] +
                                         ((npy_short *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
short_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data_out = (npy_short *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_short *)data_out + 2*6)[0] =
                                    ((npy_short *)data0 + 2*6)[0] +
                                    ((npy_short *)data_out + 2*6)[0];
            ((npy_short *)data_out + 2*6)[1] =
                                    ((npy_short *)data0 + 2*6)[1] +
                                    ((npy_short *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_short *)data_out + 2*5)[0] =
                                    ((npy_short *)data0 + 2*5)[0] +
                                    ((npy_short *)data_out + 2*5)[0];
            ((npy_short *)data_out + 2*5)[1] =
                                    ((npy_short *)data0 + 2*5)[1] +
                                    ((npy_short *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_short *)data_out + 2*4)[0] =
                                    ((npy_short *)data0 + 2*4)[0] +
                                    ((npy_short *)data_out + 2*4)[0];
            ((npy_short *)data_out + 2*4)[1] =
                                    ((npy_short *)data0 + 2*4)[1] +
                                    ((npy_short *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_short *)data_out + 2*3)[0] =
                                    ((npy_short *)data0 + 2*3)[0] +
                                    ((npy_short *)data_out + 2*3)[0];
            ((npy_short *)data_out + 2*3)[1] =
                                    ((npy_short *)data0 + 2*3)[1] +
                                    ((npy_short *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_short *)data_out + 2*2)[0] =
                                    ((npy_short *)data0 + 2*2)[0] +
                                    ((npy_short *)data_out + 2*2)[0];
            ((npy_short *)data_out + 2*2)[1] =
                                    ((npy_short *)data0 + 2*2)[1] +
                                    ((npy_short *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_short *)data_out + 2*1)[0] =
                                    ((npy_short *)data0 + 2*1)[0] +
                                    ((npy_short *)data_out + 2*1)[0];
            ((npy_short *)data_out + 2*1)[1] =
                                    ((npy_short *)data0 + 2*1)[1] +
                                    ((npy_short *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_short *)data_out + 2*0)[0] =
                                    ((npy_short *)data0 + 2*0)[0] +
                                    ((npy_short *)data_out + 2*0)[0];
            ((npy_short *)data_out + 2*0)[1] =
                                    ((npy_short *)data0 + 2*0)[1] +
                                    ((npy_short *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_short *)data_out + 2*0)[0] =
                                ((npy_short *)data0 + 2*0)[0] +
                                ((npy_short *)data_out + 2*0)[0];
        ((npy_short *)data_out + 2*0)[1] =
                                ((npy_short *)data0 + 2*0)[1] +
                                ((npy_short *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_short *)data_out + 2*1)[0] =
                                ((npy_short *)data0 + 2*1)[0] +
                                ((npy_short *)data_out + 2*1)[0];
        ((npy_short *)data_out + 2*1)[1] =
                                ((npy_short *)data0 + 2*1)[1] +
                                ((npy_short *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_short *)data_out + 2*2)[0] =
                                ((npy_short *)data0 + 2*2)[0] +
                                ((npy_short *)data_out + 2*2)[0];
        ((npy_short *)data_out + 2*2)[1] =
                                ((npy_short *)data0 + 2*2)[1] +
                                ((npy_short *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_short *)data_out + 2*3)[0] =
                                ((npy_short *)data0 + 2*3)[0] +
                                ((npy_short *)data_out + 2*3)[0];
        ((npy_short *)data_out + 2*3)[1] =
                                ((npy_short *)data0 + 2*3)[1] +
                                ((npy_short *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_short *)data_out + 2*4)[0] =
                                ((npy_short *)data0 + 2*4)[0] +
                                ((npy_short *)data_out + 2*4)[0];
        ((npy_short *)data_out + 2*4)[1] =
                                ((npy_short *)data0 + 2*4)[1] +
                                ((npy_short *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_short *)data_out + 2*5)[0] =
                                ((npy_short *)data0 + 2*5)[0] +
                                ((npy_short *)data_out + 2*5)[0];
        ((npy_short *)data_out + 2*5)[1] =
                                ((npy_short *)data0 + 2*5)[1] +
                                ((npy_short *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_short *)data_out + 2*6)[0] =
                                ((npy_short *)data0 + 2*6)[0] +
                                ((npy_short *)data_out + 2*6)[0];
        ((npy_short *)data_out + 2*6)[1] =
                                ((npy_short *)data0 + 2*6)[1] +
                                ((npy_short *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_short *)data_out + 2*7)[0] =
                                ((npy_short *)data0 + 2*7)[0] +
                                ((npy_short *)data_out + 2*7)[0];
        ((npy_short *)data_out + 2*7)[1] =
                                ((npy_short *)data0 + 2*7)[1] +
                                ((npy_short *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
short_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
short_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
short_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
short_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data2 = (npy_short *)dataptr[2];
    npy_short *data_out = (npy_short *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
short_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
short_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#else
    npy_short accum = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_short *)dataptr[1])[0] += accum_re;
            ((npy_short *)dataptr[1])[1] += accum_im;
#else
            *((npy_short *)dataptr[1]) = (accum +
                                    (*((npy_short *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
short_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
#else
    npy_short accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_short *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1) *
                 (*(npy_short *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_short *)data0)[0];
        accum_im += ((npy_short *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_short *)dataptr[1])[0] += accum_re;
    ((npy_short *)dataptr[1])[1] += accum_im;
#  else
    ((npy_short *)dataptr[nop])[0] += accum_re;
    ((npy_short *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_short *)dataptr[1]) = (accum +
                                    (*((npy_short *)dataptr[1])));
#  else
    *((npy_short *)dataptr[nop]) = (accum +
                                    (*((npy_short *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
short_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_short *)data_out = ((*(npy_short *)data0) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) *
                                         (*(npy_short *)data2) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_short *)data_out)[0] = ((npy_short *)data0)[0] +
                                         ((npy_short *)data_out)[0];
        ((npy_short *)data_out)[1] = ((npy_short *)data0)[1] +
                                         ((npy_short *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
short_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data_out = (npy_short *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_short *)data_out + 2*6)[0] =
                                    ((npy_short *)data0 + 2*6)[0] +
                                    ((npy_short *)data_out + 2*6)[0];
            ((npy_short *)data_out + 2*6)[1] =
                                    ((npy_short *)data0 + 2*6)[1] +
                                    ((npy_short *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_short *)data_out + 2*5)[0] =
                                    ((npy_short *)data0 + 2*5)[0] +
                                    ((npy_short *)data_out + 2*5)[0];
            ((npy_short *)data_out + 2*5)[1] =
                                    ((npy_short *)data0 + 2*5)[1] +
                                    ((npy_short *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_short *)data_out + 2*4)[0] =
                                    ((npy_short *)data0 + 2*4)[0] +
                                    ((npy_short *)data_out + 2*4)[0];
            ((npy_short *)data_out + 2*4)[1] =
                                    ((npy_short *)data0 + 2*4)[1] +
                                    ((npy_short *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_short *)data_out + 2*3)[0] =
                                    ((npy_short *)data0 + 2*3)[0] +
                                    ((npy_short *)data_out + 2*3)[0];
            ((npy_short *)data_out + 2*3)[1] =
                                    ((npy_short *)data0 + 2*3)[1] +
                                    ((npy_short *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_short *)data_out + 2*2)[0] =
                                    ((npy_short *)data0 + 2*2)[0] +
                                    ((npy_short *)data_out + 2*2)[0];
            ((npy_short *)data_out + 2*2)[1] =
                                    ((npy_short *)data0 + 2*2)[1] +
                                    ((npy_short *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_short *)data_out + 2*1)[0] =
                                    ((npy_short *)data0 + 2*1)[0] +
                                    ((npy_short *)data_out + 2*1)[0];
            ((npy_short *)data_out + 2*1)[1] =
                                    ((npy_short *)data0 + 2*1)[1] +
                                    ((npy_short *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_short *)data_out + 2*0)[0] =
                                    ((npy_short *)data0 + 2*0)[0] +
                                    ((npy_short *)data_out + 2*0)[0];
            ((npy_short *)data_out + 2*0)[1] =
                                    ((npy_short *)data0 + 2*0)[1] +
                                    ((npy_short *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_short *)data_out + 2*0)[0] =
                                ((npy_short *)data0 + 2*0)[0] +
                                ((npy_short *)data_out + 2*0)[0];
        ((npy_short *)data_out + 2*0)[1] =
                                ((npy_short *)data0 + 2*0)[1] +
                                ((npy_short *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_short *)data_out + 2*1)[0] =
                                ((npy_short *)data0 + 2*1)[0] +
                                ((npy_short *)data_out + 2*1)[0];
        ((npy_short *)data_out + 2*1)[1] =
                                ((npy_short *)data0 + 2*1)[1] +
                                ((npy_short *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_short *)data_out + 2*2)[0] =
                                ((npy_short *)data0 + 2*2)[0] +
                                ((npy_short *)data_out + 2*2)[0];
        ((npy_short *)data_out + 2*2)[1] =
                                ((npy_short *)data0 + 2*2)[1] +
                                ((npy_short *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_short *)data_out + 2*3)[0] =
                                ((npy_short *)data0 + 2*3)[0] +
                                ((npy_short *)data_out + 2*3)[0];
        ((npy_short *)data_out + 2*3)[1] =
                                ((npy_short *)data0 + 2*3)[1] +
                                ((npy_short *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_short *)data_out + 2*4)[0] =
                                ((npy_short *)data0 + 2*4)[0] +
                                ((npy_short *)data_out + 2*4)[0];
        ((npy_short *)data_out + 2*4)[1] =
                                ((npy_short *)data0 + 2*4)[1] +
                                ((npy_short *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_short *)data_out + 2*5)[0] =
                                ((npy_short *)data0 + 2*5)[0] +
                                ((npy_short *)data_out + 2*5)[0];
        ((npy_short *)data_out + 2*5)[1] =
                                ((npy_short *)data0 + 2*5)[1] +
                                ((npy_short *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_short *)data_out + 2*6)[0] =
                                ((npy_short *)data0 + 2*6)[0] +
                                ((npy_short *)data_out + 2*6)[0];
        ((npy_short *)data_out + 2*6)[1] =
                                ((npy_short *)data0 + 2*6)[1] +
                                ((npy_short *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_short *)data_out + 2*7)[0] =
                                ((npy_short *)data0 + 2*7)[0] +
                                ((npy_short *)data_out + 2*7)[0];
        ((npy_short *)data_out + 2*7)[1] =
                                ((npy_short *)data0 + 2*7)[1] +
                                ((npy_short *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
short_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
short_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
short_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
short_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data2 = (npy_short *)dataptr[2];
    npy_short *data_out = (npy_short *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
short_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
short_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#else
    npy_short accum = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_short *)dataptr[1])[0] += accum_re;
            ((npy_short *)dataptr[1])[1] += accum_im;
#else
            *((npy_short *)dataptr[1]) = (accum +
                                    (*((npy_short *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
short_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
#else
    npy_short accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_short *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1) *
                 (*(npy_short *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_short *)data0)[0];
        accum_im += ((npy_short *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_short *)dataptr[2])[0] += accum_re;
    ((npy_short *)dataptr[2])[1] += accum_im;
#  else
    ((npy_short *)dataptr[nop])[0] += accum_re;
    ((npy_short *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_short *)dataptr[2]) = (accum +
                                    (*((npy_short *)dataptr[2])));
#  else
    *((npy_short *)dataptr[nop]) = (accum +
                                    (*((npy_short *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
short_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_short *)data_out = ((*(npy_short *)data0) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) *
                                         (*(npy_short *)data2) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_short *)data_out)[0] = ((npy_short *)data0)[0] +
                                         ((npy_short *)data_out)[0];
        ((npy_short *)data_out)[1] = ((npy_short *)data0)[1] +
                                         ((npy_short *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
short_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data_out = (npy_short *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_short *)data_out + 2*6)[0] =
                                    ((npy_short *)data0 + 2*6)[0] +
                                    ((npy_short *)data_out + 2*6)[0];
            ((npy_short *)data_out + 2*6)[1] =
                                    ((npy_short *)data0 + 2*6)[1] +
                                    ((npy_short *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_short *)data_out + 2*5)[0] =
                                    ((npy_short *)data0 + 2*5)[0] +
                                    ((npy_short *)data_out + 2*5)[0];
            ((npy_short *)data_out + 2*5)[1] =
                                    ((npy_short *)data0 + 2*5)[1] +
                                    ((npy_short *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_short *)data_out + 2*4)[0] =
                                    ((npy_short *)data0 + 2*4)[0] +
                                    ((npy_short *)data_out + 2*4)[0];
            ((npy_short *)data_out + 2*4)[1] =
                                    ((npy_short *)data0 + 2*4)[1] +
                                    ((npy_short *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_short *)data_out + 2*3)[0] =
                                    ((npy_short *)data0 + 2*3)[0] +
                                    ((npy_short *)data_out + 2*3)[0];
            ((npy_short *)data_out + 2*3)[1] =
                                    ((npy_short *)data0 + 2*3)[1] +
                                    ((npy_short *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_short *)data_out + 2*2)[0] =
                                    ((npy_short *)data0 + 2*2)[0] +
                                    ((npy_short *)data_out + 2*2)[0];
            ((npy_short *)data_out + 2*2)[1] =
                                    ((npy_short *)data0 + 2*2)[1] +
                                    ((npy_short *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_short *)data_out + 2*1)[0] =
                                    ((npy_short *)data0 + 2*1)[0] +
                                    ((npy_short *)data_out + 2*1)[0];
            ((npy_short *)data_out + 2*1)[1] =
                                    ((npy_short *)data0 + 2*1)[1] +
                                    ((npy_short *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_short *)data_out + 2*0)[0] =
                                    ((npy_short *)data0 + 2*0)[0] +
                                    ((npy_short *)data_out + 2*0)[0];
            ((npy_short *)data_out + 2*0)[1] =
                                    ((npy_short *)data0 + 2*0)[1] +
                                    ((npy_short *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_short *)data_out + 2*0)[0] =
                                ((npy_short *)data0 + 2*0)[0] +
                                ((npy_short *)data_out + 2*0)[0];
        ((npy_short *)data_out + 2*0)[1] =
                                ((npy_short *)data0 + 2*0)[1] +
                                ((npy_short *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_short *)data_out + 2*1)[0] =
                                ((npy_short *)data0 + 2*1)[0] +
                                ((npy_short *)data_out + 2*1)[0];
        ((npy_short *)data_out + 2*1)[1] =
                                ((npy_short *)data0 + 2*1)[1] +
                                ((npy_short *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_short *)data_out + 2*2)[0] =
                                ((npy_short *)data0 + 2*2)[0] +
                                ((npy_short *)data_out + 2*2)[0];
        ((npy_short *)data_out + 2*2)[1] =
                                ((npy_short *)data0 + 2*2)[1] +
                                ((npy_short *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_short *)data_out + 2*3)[0] =
                                ((npy_short *)data0 + 2*3)[0] +
                                ((npy_short *)data_out + 2*3)[0];
        ((npy_short *)data_out + 2*3)[1] =
                                ((npy_short *)data0 + 2*3)[1] +
                                ((npy_short *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_short *)data_out + 2*4)[0] =
                                ((npy_short *)data0 + 2*4)[0] +
                                ((npy_short *)data_out + 2*4)[0];
        ((npy_short *)data_out + 2*4)[1] =
                                ((npy_short *)data0 + 2*4)[1] +
                                ((npy_short *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_short *)data_out + 2*5)[0] =
                                ((npy_short *)data0 + 2*5)[0] +
                                ((npy_short *)data_out + 2*5)[0];
        ((npy_short *)data_out + 2*5)[1] =
                                ((npy_short *)data0 + 2*5)[1] +
                                ((npy_short *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_short *)data_out + 2*6)[0] =
                                ((npy_short *)data0 + 2*6)[0] +
                                ((npy_short *)data_out + 2*6)[0];
        ((npy_short *)data_out + 2*6)[1] =
                                ((npy_short *)data0 + 2*6)[1] +
                                ((npy_short *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_short *)data_out + 2*7)[0] =
                                ((npy_short *)data0 + 2*7)[0] +
                                ((npy_short *)data_out + 2*7)[0];
        ((npy_short *)data_out + 2*7)[1] =
                                ((npy_short *)data0 + 2*7)[1] +
                                ((npy_short *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
short_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
short_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
short_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
short_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data2 = (npy_short *)dataptr[2];
    npy_short *data_out = (npy_short *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
short_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
short_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#else
    npy_short accum = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_short *)dataptr[1])[0] += accum_re;
            ((npy_short *)dataptr[1])[1] += accum_im;
#else
            *((npy_short *)dataptr[1]) = (accum +
                                    (*((npy_short *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
short_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
#else
    npy_short accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_short *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1) *
                 (*(npy_short *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_short *)data0)[0];
        accum_im += ((npy_short *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_short *)dataptr[3])[0] += accum_re;
    ((npy_short *)dataptr[3])[1] += accum_im;
#  else
    ((npy_short *)dataptr[nop])[0] += accum_re;
    ((npy_short *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_short *)dataptr[3]) = (accum +
                                    (*((npy_short *)dataptr[3])));
#  else
    *((npy_short *)dataptr[nop]) = (accum +
                                    (*((npy_short *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
short_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_short *)data_out = ((*(npy_short *)data0) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_short *)data_out = ((*(npy_short *)data0) *
                                         (*(npy_short *)data1) *
                                         (*(npy_short *)data2) +
                                         (*(npy_short *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_short *)data_out)[0] = ((npy_short *)data0)[0] +
                                         ((npy_short *)data_out)[0];
        ((npy_short *)data_out)[1] = ((npy_short *)data0)[1] +
                                         ((npy_short *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
short_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data_out = (npy_short *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_short *)data_out + 2*6)[0] =
                                    ((npy_short *)data0 + 2*6)[0] +
                                    ((npy_short *)data_out + 2*6)[0];
            ((npy_short *)data_out + 2*6)[1] =
                                    ((npy_short *)data0 + 2*6)[1] +
                                    ((npy_short *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_short *)data_out + 2*5)[0] =
                                    ((npy_short *)data0 + 2*5)[0] +
                                    ((npy_short *)data_out + 2*5)[0];
            ((npy_short *)data_out + 2*5)[1] =
                                    ((npy_short *)data0 + 2*5)[1] +
                                    ((npy_short *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_short *)data_out + 2*4)[0] =
                                    ((npy_short *)data0 + 2*4)[0] +
                                    ((npy_short *)data_out + 2*4)[0];
            ((npy_short *)data_out + 2*4)[1] =
                                    ((npy_short *)data0 + 2*4)[1] +
                                    ((npy_short *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_short *)data_out + 2*3)[0] =
                                    ((npy_short *)data0 + 2*3)[0] +
                                    ((npy_short *)data_out + 2*3)[0];
            ((npy_short *)data_out + 2*3)[1] =
                                    ((npy_short *)data0 + 2*3)[1] +
                                    ((npy_short *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_short *)data_out + 2*2)[0] =
                                    ((npy_short *)data0 + 2*2)[0] +
                                    ((npy_short *)data_out + 2*2)[0];
            ((npy_short *)data_out + 2*2)[1] =
                                    ((npy_short *)data0 + 2*2)[1] +
                                    ((npy_short *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_short *)data_out + 2*1)[0] =
                                    ((npy_short *)data0 + 2*1)[0] +
                                    ((npy_short *)data_out + 2*1)[0];
            ((npy_short *)data_out + 2*1)[1] =
                                    ((npy_short *)data0 + 2*1)[1] +
                                    ((npy_short *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_short *)data_out + 2*0)[0] =
                                    ((npy_short *)data0 + 2*0)[0] +
                                    ((npy_short *)data_out + 2*0)[0];
            ((npy_short *)data_out + 2*0)[1] =
                                    ((npy_short *)data0 + 2*0)[1] +
                                    ((npy_short *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_short *)data_out + 2*0)[0] =
                                ((npy_short *)data0 + 2*0)[0] +
                                ((npy_short *)data_out + 2*0)[0];
        ((npy_short *)data_out + 2*0)[1] =
                                ((npy_short *)data0 + 2*0)[1] +
                                ((npy_short *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_short *)data_out + 2*1)[0] =
                                ((npy_short *)data0 + 2*1)[0] +
                                ((npy_short *)data_out + 2*1)[0];
        ((npy_short *)data_out + 2*1)[1] =
                                ((npy_short *)data0 + 2*1)[1] +
                                ((npy_short *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_short *)data_out + 2*2)[0] =
                                ((npy_short *)data0 + 2*2)[0] +
                                ((npy_short *)data_out + 2*2)[0];
        ((npy_short *)data_out + 2*2)[1] =
                                ((npy_short *)data0 + 2*2)[1] +
                                ((npy_short *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_short *)data_out + 2*3)[0] =
                                ((npy_short *)data0 + 2*3)[0] +
                                ((npy_short *)data_out + 2*3)[0];
        ((npy_short *)data_out + 2*3)[1] =
                                ((npy_short *)data0 + 2*3)[1] +
                                ((npy_short *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_short *)data_out + 2*4)[0] =
                                ((npy_short *)data0 + 2*4)[0] +
                                ((npy_short *)data_out + 2*4)[0];
        ((npy_short *)data_out + 2*4)[1] =
                                ((npy_short *)data0 + 2*4)[1] +
                                ((npy_short *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_short *)data_out + 2*5)[0] =
                                ((npy_short *)data0 + 2*5)[0] +
                                ((npy_short *)data_out + 2*5)[0];
        ((npy_short *)data_out + 2*5)[1] =
                                ((npy_short *)data0 + 2*5)[1] +
                                ((npy_short *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_short *)data_out + 2*6)[0] =
                                ((npy_short *)data0 + 2*6)[0] +
                                ((npy_short *)data_out + 2*6)[0];
        ((npy_short *)data_out + 2*6)[1] =
                                ((npy_short *)data0 + 2*6)[1] +
                                ((npy_short *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_short *)data_out + 2*7)[0] =
                                ((npy_short *)data0 + 2*7)[0] +
                                ((npy_short *)data_out + 2*7)[0];
        ((npy_short *)data_out + 2*7)[1] =
                                ((npy_short *)data0 + 2*7)[1] +
                                ((npy_short *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
short_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
short_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
short_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short *data_out = (npy_short *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short value0 = (*(npy_short *)dataptr[0]);
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
short_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short value1 = (*(npy_short *)dataptr[1]);
    npy_short accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_short *)dataptr[2] = ((*(npy_short *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
short_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_short *data0 = (npy_short *)dataptr[0];
    npy_short *data1 = (npy_short *)dataptr[1];
    npy_short *data2 = (npy_short *)dataptr[2];
    npy_short *data_out = (npy_short *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
short_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        *(npy_short *)dataptr[nop] = (temp +
                                           (*(npy_short *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_short *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[0];
        ((npy_short *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_short *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_short);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
short_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#else
    npy_short accum = 0;
    npy_short *data0 = (npy_short *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_short *)dataptr[1])[0] += accum_re;
            ((npy_short *)dataptr[1])[1] += accum_im;
#else
            *((npy_short *)dataptr[1]) = (accum +
                                    (*((npy_short *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
short_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_short accum_re = 0, accum_im = 0;
#else
    npy_short accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("short_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_short *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_short *)data0) *
                 (*(npy_short *)data1) *
                 (*(npy_short *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_short temp = (*(npy_short *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_short *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_short *)data0)[0];
        accum_im += ((npy_short *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_short re, im, tmp;
        int i;
        re = ((npy_short *)dataptr[0])[0];
        im = ((npy_short *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_short *)dataptr[i])[0] -
                  im * ((npy_short *)dataptr[i])[1];
            im = re * ((npy_short *)dataptr[i])[1] +
                 im * ((npy_short *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_short *)dataptr[1000])[0] += accum_re;
    ((npy_short *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_short *)dataptr[nop])[0] += accum_re;
    ((npy_short *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_short *)dataptr[1000]) = (accum +
                                    (*((npy_short *)dataptr[1000])));
#  else
    *((npy_short *)dataptr[nop]) = (accum +
                                    (*((npy_short *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
int_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_int *)data_out = ((*(npy_int *)data0) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) *
                                         (*(npy_int *)data2) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_int *)data_out)[0] = ((npy_int *)data0)[0] +
                                         ((npy_int *)data_out)[0];
        ((npy_int *)data_out)[1] = ((npy_int *)data0)[1] +
                                         ((npy_int *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
int_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data_out = (npy_int *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_int *)data_out + 2*6)[0] =
                                    ((npy_int *)data0 + 2*6)[0] +
                                    ((npy_int *)data_out + 2*6)[0];
            ((npy_int *)data_out + 2*6)[1] =
                                    ((npy_int *)data0 + 2*6)[1] +
                                    ((npy_int *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_int *)data_out + 2*5)[0] =
                                    ((npy_int *)data0 + 2*5)[0] +
                                    ((npy_int *)data_out + 2*5)[0];
            ((npy_int *)data_out + 2*5)[1] =
                                    ((npy_int *)data0 + 2*5)[1] +
                                    ((npy_int *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_int *)data_out + 2*4)[0] =
                                    ((npy_int *)data0 + 2*4)[0] +
                                    ((npy_int *)data_out + 2*4)[0];
            ((npy_int *)data_out + 2*4)[1] =
                                    ((npy_int *)data0 + 2*4)[1] +
                                    ((npy_int *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_int *)data_out + 2*3)[0] =
                                    ((npy_int *)data0 + 2*3)[0] +
                                    ((npy_int *)data_out + 2*3)[0];
            ((npy_int *)data_out + 2*3)[1] =
                                    ((npy_int *)data0 + 2*3)[1] +
                                    ((npy_int *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_int *)data_out + 2*2)[0] =
                                    ((npy_int *)data0 + 2*2)[0] +
                                    ((npy_int *)data_out + 2*2)[0];
            ((npy_int *)data_out + 2*2)[1] =
                                    ((npy_int *)data0 + 2*2)[1] +
                                    ((npy_int *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_int *)data_out + 2*1)[0] =
                                    ((npy_int *)data0 + 2*1)[0] +
                                    ((npy_int *)data_out + 2*1)[0];
            ((npy_int *)data_out + 2*1)[1] =
                                    ((npy_int *)data0 + 2*1)[1] +
                                    ((npy_int *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_int *)data_out + 2*0)[0] =
                                    ((npy_int *)data0 + 2*0)[0] +
                                    ((npy_int *)data_out + 2*0)[0];
            ((npy_int *)data_out + 2*0)[1] =
                                    ((npy_int *)data0 + 2*0)[1] +
                                    ((npy_int *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_int *)data_out + 2*0)[0] =
                                ((npy_int *)data0 + 2*0)[0] +
                                ((npy_int *)data_out + 2*0)[0];
        ((npy_int *)data_out + 2*0)[1] =
                                ((npy_int *)data0 + 2*0)[1] +
                                ((npy_int *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_int *)data_out + 2*1)[0] =
                                ((npy_int *)data0 + 2*1)[0] +
                                ((npy_int *)data_out + 2*1)[0];
        ((npy_int *)data_out + 2*1)[1] =
                                ((npy_int *)data0 + 2*1)[1] +
                                ((npy_int *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_int *)data_out + 2*2)[0] =
                                ((npy_int *)data0 + 2*2)[0] +
                                ((npy_int *)data_out + 2*2)[0];
        ((npy_int *)data_out + 2*2)[1] =
                                ((npy_int *)data0 + 2*2)[1] +
                                ((npy_int *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_int *)data_out + 2*3)[0] =
                                ((npy_int *)data0 + 2*3)[0] +
                                ((npy_int *)data_out + 2*3)[0];
        ((npy_int *)data_out + 2*3)[1] =
                                ((npy_int *)data0 + 2*3)[1] +
                                ((npy_int *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_int *)data_out + 2*4)[0] =
                                ((npy_int *)data0 + 2*4)[0] +
                                ((npy_int *)data_out + 2*4)[0];
        ((npy_int *)data_out + 2*4)[1] =
                                ((npy_int *)data0 + 2*4)[1] +
                                ((npy_int *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_int *)data_out + 2*5)[0] =
                                ((npy_int *)data0 + 2*5)[0] +
                                ((npy_int *)data_out + 2*5)[0];
        ((npy_int *)data_out + 2*5)[1] =
                                ((npy_int *)data0 + 2*5)[1] +
                                ((npy_int *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_int *)data_out + 2*6)[0] =
                                ((npy_int *)data0 + 2*6)[0] +
                                ((npy_int *)data_out + 2*6)[0];
        ((npy_int *)data_out + 2*6)[1] =
                                ((npy_int *)data0 + 2*6)[1] +
                                ((npy_int *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_int *)data_out + 2*7)[0] =
                                ((npy_int *)data0 + 2*7)[0] +
                                ((npy_int *)data_out + 2*7)[0];
        ((npy_int *)data_out + 2*7)[1] =
                                ((npy_int *)data0 + 2*7)[1] +
                                ((npy_int *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
int_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
int_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
int_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
int_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data2 = (npy_int *)dataptr[2];
    npy_int *data_out = (npy_int *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
int_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
int_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#else
    npy_int accum = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_int *)dataptr[1])[0] += accum_re;
            ((npy_int *)dataptr[1])[1] += accum_im;
#else
            *((npy_int *)dataptr[1]) = (accum +
                                    (*((npy_int *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
int_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
#else
    npy_int accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_int *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1) *
                 (*(npy_int *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_int *)data0)[0];
        accum_im += ((npy_int *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_int *)dataptr[1])[0] += accum_re;
    ((npy_int *)dataptr[1])[1] += accum_im;
#  else
    ((npy_int *)dataptr[nop])[0] += accum_re;
    ((npy_int *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_int *)dataptr[1]) = (accum +
                                    (*((npy_int *)dataptr[1])));
#  else
    *((npy_int *)dataptr[nop]) = (accum +
                                    (*((npy_int *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
int_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_int *)data_out = ((*(npy_int *)data0) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) *
                                         (*(npy_int *)data2) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_int *)data_out)[0] = ((npy_int *)data0)[0] +
                                         ((npy_int *)data_out)[0];
        ((npy_int *)data_out)[1] = ((npy_int *)data0)[1] +
                                         ((npy_int *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
int_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data_out = (npy_int *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_int *)data_out + 2*6)[0] =
                                    ((npy_int *)data0 + 2*6)[0] +
                                    ((npy_int *)data_out + 2*6)[0];
            ((npy_int *)data_out + 2*6)[1] =
                                    ((npy_int *)data0 + 2*6)[1] +
                                    ((npy_int *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_int *)data_out + 2*5)[0] =
                                    ((npy_int *)data0 + 2*5)[0] +
                                    ((npy_int *)data_out + 2*5)[0];
            ((npy_int *)data_out + 2*5)[1] =
                                    ((npy_int *)data0 + 2*5)[1] +
                                    ((npy_int *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_int *)data_out + 2*4)[0] =
                                    ((npy_int *)data0 + 2*4)[0] +
                                    ((npy_int *)data_out + 2*4)[0];
            ((npy_int *)data_out + 2*4)[1] =
                                    ((npy_int *)data0 + 2*4)[1] +
                                    ((npy_int *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_int *)data_out + 2*3)[0] =
                                    ((npy_int *)data0 + 2*3)[0] +
                                    ((npy_int *)data_out + 2*3)[0];
            ((npy_int *)data_out + 2*3)[1] =
                                    ((npy_int *)data0 + 2*3)[1] +
                                    ((npy_int *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_int *)data_out + 2*2)[0] =
                                    ((npy_int *)data0 + 2*2)[0] +
                                    ((npy_int *)data_out + 2*2)[0];
            ((npy_int *)data_out + 2*2)[1] =
                                    ((npy_int *)data0 + 2*2)[1] +
                                    ((npy_int *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_int *)data_out + 2*1)[0] =
                                    ((npy_int *)data0 + 2*1)[0] +
                                    ((npy_int *)data_out + 2*1)[0];
            ((npy_int *)data_out + 2*1)[1] =
                                    ((npy_int *)data0 + 2*1)[1] +
                                    ((npy_int *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_int *)data_out + 2*0)[0] =
                                    ((npy_int *)data0 + 2*0)[0] +
                                    ((npy_int *)data_out + 2*0)[0];
            ((npy_int *)data_out + 2*0)[1] =
                                    ((npy_int *)data0 + 2*0)[1] +
                                    ((npy_int *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_int *)data_out + 2*0)[0] =
                                ((npy_int *)data0 + 2*0)[0] +
                                ((npy_int *)data_out + 2*0)[0];
        ((npy_int *)data_out + 2*0)[1] =
                                ((npy_int *)data0 + 2*0)[1] +
                                ((npy_int *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_int *)data_out + 2*1)[0] =
                                ((npy_int *)data0 + 2*1)[0] +
                                ((npy_int *)data_out + 2*1)[0];
        ((npy_int *)data_out + 2*1)[1] =
                                ((npy_int *)data0 + 2*1)[1] +
                                ((npy_int *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_int *)data_out + 2*2)[0] =
                                ((npy_int *)data0 + 2*2)[0] +
                                ((npy_int *)data_out + 2*2)[0];
        ((npy_int *)data_out + 2*2)[1] =
                                ((npy_int *)data0 + 2*2)[1] +
                                ((npy_int *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_int *)data_out + 2*3)[0] =
                                ((npy_int *)data0 + 2*3)[0] +
                                ((npy_int *)data_out + 2*3)[0];
        ((npy_int *)data_out + 2*3)[1] =
                                ((npy_int *)data0 + 2*3)[1] +
                                ((npy_int *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_int *)data_out + 2*4)[0] =
                                ((npy_int *)data0 + 2*4)[0] +
                                ((npy_int *)data_out + 2*4)[0];
        ((npy_int *)data_out + 2*4)[1] =
                                ((npy_int *)data0 + 2*4)[1] +
                                ((npy_int *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_int *)data_out + 2*5)[0] =
                                ((npy_int *)data0 + 2*5)[0] +
                                ((npy_int *)data_out + 2*5)[0];
        ((npy_int *)data_out + 2*5)[1] =
                                ((npy_int *)data0 + 2*5)[1] +
                                ((npy_int *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_int *)data_out + 2*6)[0] =
                                ((npy_int *)data0 + 2*6)[0] +
                                ((npy_int *)data_out + 2*6)[0];
        ((npy_int *)data_out + 2*6)[1] =
                                ((npy_int *)data0 + 2*6)[1] +
                                ((npy_int *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_int *)data_out + 2*7)[0] =
                                ((npy_int *)data0 + 2*7)[0] +
                                ((npy_int *)data_out + 2*7)[0];
        ((npy_int *)data_out + 2*7)[1] =
                                ((npy_int *)data0 + 2*7)[1] +
                                ((npy_int *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
int_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
int_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
int_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
int_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data2 = (npy_int *)dataptr[2];
    npy_int *data_out = (npy_int *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
int_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
int_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#else
    npy_int accum = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_int *)dataptr[1])[0] += accum_re;
            ((npy_int *)dataptr[1])[1] += accum_im;
#else
            *((npy_int *)dataptr[1]) = (accum +
                                    (*((npy_int *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
int_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
#else
    npy_int accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_int *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1) *
                 (*(npy_int *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_int *)data0)[0];
        accum_im += ((npy_int *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_int *)dataptr[2])[0] += accum_re;
    ((npy_int *)dataptr[2])[1] += accum_im;
#  else
    ((npy_int *)dataptr[nop])[0] += accum_re;
    ((npy_int *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_int *)dataptr[2]) = (accum +
                                    (*((npy_int *)dataptr[2])));
#  else
    *((npy_int *)dataptr[nop]) = (accum +
                                    (*((npy_int *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
int_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_int *)data_out = ((*(npy_int *)data0) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) *
                                         (*(npy_int *)data2) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_int *)data_out)[0] = ((npy_int *)data0)[0] +
                                         ((npy_int *)data_out)[0];
        ((npy_int *)data_out)[1] = ((npy_int *)data0)[1] +
                                         ((npy_int *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
int_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data_out = (npy_int *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_int *)data_out + 2*6)[0] =
                                    ((npy_int *)data0 + 2*6)[0] +
                                    ((npy_int *)data_out + 2*6)[0];
            ((npy_int *)data_out + 2*6)[1] =
                                    ((npy_int *)data0 + 2*6)[1] +
                                    ((npy_int *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_int *)data_out + 2*5)[0] =
                                    ((npy_int *)data0 + 2*5)[0] +
                                    ((npy_int *)data_out + 2*5)[0];
            ((npy_int *)data_out + 2*5)[1] =
                                    ((npy_int *)data0 + 2*5)[1] +
                                    ((npy_int *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_int *)data_out + 2*4)[0] =
                                    ((npy_int *)data0 + 2*4)[0] +
                                    ((npy_int *)data_out + 2*4)[0];
            ((npy_int *)data_out + 2*4)[1] =
                                    ((npy_int *)data0 + 2*4)[1] +
                                    ((npy_int *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_int *)data_out + 2*3)[0] =
                                    ((npy_int *)data0 + 2*3)[0] +
                                    ((npy_int *)data_out + 2*3)[0];
            ((npy_int *)data_out + 2*3)[1] =
                                    ((npy_int *)data0 + 2*3)[1] +
                                    ((npy_int *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_int *)data_out + 2*2)[0] =
                                    ((npy_int *)data0 + 2*2)[0] +
                                    ((npy_int *)data_out + 2*2)[0];
            ((npy_int *)data_out + 2*2)[1] =
                                    ((npy_int *)data0 + 2*2)[1] +
                                    ((npy_int *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_int *)data_out + 2*1)[0] =
                                    ((npy_int *)data0 + 2*1)[0] +
                                    ((npy_int *)data_out + 2*1)[0];
            ((npy_int *)data_out + 2*1)[1] =
                                    ((npy_int *)data0 + 2*1)[1] +
                                    ((npy_int *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_int *)data_out + 2*0)[0] =
                                    ((npy_int *)data0 + 2*0)[0] +
                                    ((npy_int *)data_out + 2*0)[0];
            ((npy_int *)data_out + 2*0)[1] =
                                    ((npy_int *)data0 + 2*0)[1] +
                                    ((npy_int *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_int *)data_out + 2*0)[0] =
                                ((npy_int *)data0 + 2*0)[0] +
                                ((npy_int *)data_out + 2*0)[0];
        ((npy_int *)data_out + 2*0)[1] =
                                ((npy_int *)data0 + 2*0)[1] +
                                ((npy_int *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_int *)data_out + 2*1)[0] =
                                ((npy_int *)data0 + 2*1)[0] +
                                ((npy_int *)data_out + 2*1)[0];
        ((npy_int *)data_out + 2*1)[1] =
                                ((npy_int *)data0 + 2*1)[1] +
                                ((npy_int *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_int *)data_out + 2*2)[0] =
                                ((npy_int *)data0 + 2*2)[0] +
                                ((npy_int *)data_out + 2*2)[0];
        ((npy_int *)data_out + 2*2)[1] =
                                ((npy_int *)data0 + 2*2)[1] +
                                ((npy_int *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_int *)data_out + 2*3)[0] =
                                ((npy_int *)data0 + 2*3)[0] +
                                ((npy_int *)data_out + 2*3)[0];
        ((npy_int *)data_out + 2*3)[1] =
                                ((npy_int *)data0 + 2*3)[1] +
                                ((npy_int *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_int *)data_out + 2*4)[0] =
                                ((npy_int *)data0 + 2*4)[0] +
                                ((npy_int *)data_out + 2*4)[0];
        ((npy_int *)data_out + 2*4)[1] =
                                ((npy_int *)data0 + 2*4)[1] +
                                ((npy_int *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_int *)data_out + 2*5)[0] =
                                ((npy_int *)data0 + 2*5)[0] +
                                ((npy_int *)data_out + 2*5)[0];
        ((npy_int *)data_out + 2*5)[1] =
                                ((npy_int *)data0 + 2*5)[1] +
                                ((npy_int *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_int *)data_out + 2*6)[0] =
                                ((npy_int *)data0 + 2*6)[0] +
                                ((npy_int *)data_out + 2*6)[0];
        ((npy_int *)data_out + 2*6)[1] =
                                ((npy_int *)data0 + 2*6)[1] +
                                ((npy_int *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_int *)data_out + 2*7)[0] =
                                ((npy_int *)data0 + 2*7)[0] +
                                ((npy_int *)data_out + 2*7)[0];
        ((npy_int *)data_out + 2*7)[1] =
                                ((npy_int *)data0 + 2*7)[1] +
                                ((npy_int *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
int_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
int_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
int_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
int_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data2 = (npy_int *)dataptr[2];
    npy_int *data_out = (npy_int *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
int_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
int_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#else
    npy_int accum = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_int *)dataptr[1])[0] += accum_re;
            ((npy_int *)dataptr[1])[1] += accum_im;
#else
            *((npy_int *)dataptr[1]) = (accum +
                                    (*((npy_int *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
int_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
#else
    npy_int accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_int *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1) *
                 (*(npy_int *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_int *)data0)[0];
        accum_im += ((npy_int *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_int *)dataptr[3])[0] += accum_re;
    ((npy_int *)dataptr[3])[1] += accum_im;
#  else
    ((npy_int *)dataptr[nop])[0] += accum_re;
    ((npy_int *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_int *)dataptr[3]) = (accum +
                                    (*((npy_int *)dataptr[3])));
#  else
    *((npy_int *)dataptr[nop]) = (accum +
                                    (*((npy_int *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
int_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_int *)data_out = ((*(npy_int *)data0) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_int *)data_out = ((*(npy_int *)data0) *
                                         (*(npy_int *)data1) *
                                         (*(npy_int *)data2) +
                                         (*(npy_int *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_int *)data_out)[0] = ((npy_int *)data0)[0] +
                                         ((npy_int *)data_out)[0];
        ((npy_int *)data_out)[1] = ((npy_int *)data0)[1] +
                                         ((npy_int *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
int_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data_out = (npy_int *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_int *)data_out + 2*6)[0] =
                                    ((npy_int *)data0 + 2*6)[0] +
                                    ((npy_int *)data_out + 2*6)[0];
            ((npy_int *)data_out + 2*6)[1] =
                                    ((npy_int *)data0 + 2*6)[1] +
                                    ((npy_int *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_int *)data_out + 2*5)[0] =
                                    ((npy_int *)data0 + 2*5)[0] +
                                    ((npy_int *)data_out + 2*5)[0];
            ((npy_int *)data_out + 2*5)[1] =
                                    ((npy_int *)data0 + 2*5)[1] +
                                    ((npy_int *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_int *)data_out + 2*4)[0] =
                                    ((npy_int *)data0 + 2*4)[0] +
                                    ((npy_int *)data_out + 2*4)[0];
            ((npy_int *)data_out + 2*4)[1] =
                                    ((npy_int *)data0 + 2*4)[1] +
                                    ((npy_int *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_int *)data_out + 2*3)[0] =
                                    ((npy_int *)data0 + 2*3)[0] +
                                    ((npy_int *)data_out + 2*3)[0];
            ((npy_int *)data_out + 2*3)[1] =
                                    ((npy_int *)data0 + 2*3)[1] +
                                    ((npy_int *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_int *)data_out + 2*2)[0] =
                                    ((npy_int *)data0 + 2*2)[0] +
                                    ((npy_int *)data_out + 2*2)[0];
            ((npy_int *)data_out + 2*2)[1] =
                                    ((npy_int *)data0 + 2*2)[1] +
                                    ((npy_int *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_int *)data_out + 2*1)[0] =
                                    ((npy_int *)data0 + 2*1)[0] +
                                    ((npy_int *)data_out + 2*1)[0];
            ((npy_int *)data_out + 2*1)[1] =
                                    ((npy_int *)data0 + 2*1)[1] +
                                    ((npy_int *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_int *)data_out + 2*0)[0] =
                                    ((npy_int *)data0 + 2*0)[0] +
                                    ((npy_int *)data_out + 2*0)[0];
            ((npy_int *)data_out + 2*0)[1] =
                                    ((npy_int *)data0 + 2*0)[1] +
                                    ((npy_int *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_int *)data_out + 2*0)[0] =
                                ((npy_int *)data0 + 2*0)[0] +
                                ((npy_int *)data_out + 2*0)[0];
        ((npy_int *)data_out + 2*0)[1] =
                                ((npy_int *)data0 + 2*0)[1] +
                                ((npy_int *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_int *)data_out + 2*1)[0] =
                                ((npy_int *)data0 + 2*1)[0] +
                                ((npy_int *)data_out + 2*1)[0];
        ((npy_int *)data_out + 2*1)[1] =
                                ((npy_int *)data0 + 2*1)[1] +
                                ((npy_int *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_int *)data_out + 2*2)[0] =
                                ((npy_int *)data0 + 2*2)[0] +
                                ((npy_int *)data_out + 2*2)[0];
        ((npy_int *)data_out + 2*2)[1] =
                                ((npy_int *)data0 + 2*2)[1] +
                                ((npy_int *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_int *)data_out + 2*3)[0] =
                                ((npy_int *)data0 + 2*3)[0] +
                                ((npy_int *)data_out + 2*3)[0];
        ((npy_int *)data_out + 2*3)[1] =
                                ((npy_int *)data0 + 2*3)[1] +
                                ((npy_int *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_int *)data_out + 2*4)[0] =
                                ((npy_int *)data0 + 2*4)[0] +
                                ((npy_int *)data_out + 2*4)[0];
        ((npy_int *)data_out + 2*4)[1] =
                                ((npy_int *)data0 + 2*4)[1] +
                                ((npy_int *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_int *)data_out + 2*5)[0] =
                                ((npy_int *)data0 + 2*5)[0] +
                                ((npy_int *)data_out + 2*5)[0];
        ((npy_int *)data_out + 2*5)[1] =
                                ((npy_int *)data0 + 2*5)[1] +
                                ((npy_int *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_int *)data_out + 2*6)[0] =
                                ((npy_int *)data0 + 2*6)[0] +
                                ((npy_int *)data_out + 2*6)[0];
        ((npy_int *)data_out + 2*6)[1] =
                                ((npy_int *)data0 + 2*6)[1] +
                                ((npy_int *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_int *)data_out + 2*7)[0] =
                                ((npy_int *)data0 + 2*7)[0] +
                                ((npy_int *)data_out + 2*7)[0];
        ((npy_int *)data_out + 2*7)[1] =
                                ((npy_int *)data0 + 2*7)[1] +
                                ((npy_int *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
int_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
int_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
int_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int *data_out = (npy_int *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int value0 = (*(npy_int *)dataptr[0]);
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
int_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int value1 = (*(npy_int *)dataptr[1]);
    npy_int accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_int *)dataptr[2] = ((*(npy_int *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
int_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_int *data0 = (npy_int *)dataptr[0];
    npy_int *data1 = (npy_int *)dataptr[1];
    npy_int *data2 = (npy_int *)dataptr[2];
    npy_int *data_out = (npy_int *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
int_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        *(npy_int *)dataptr[nop] = (temp +
                                           (*(npy_int *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_int *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[0];
        ((npy_int *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_int *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_int);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
int_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#else
    npy_int accum = 0;
    npy_int *data0 = (npy_int *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_int *)dataptr[1])[0] += accum_re;
            ((npy_int *)dataptr[1])[1] += accum_im;
#else
            *((npy_int *)dataptr[1]) = (accum +
                                    (*((npy_int *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
int_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_int accum_re = 0, accum_im = 0;
#else
    npy_int accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("int_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_int *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_int *)data0) *
                 (*(npy_int *)data1) *
                 (*(npy_int *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_int temp = (*(npy_int *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_int *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_int *)data0)[0];
        accum_im += ((npy_int *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_int re, im, tmp;
        int i;
        re = ((npy_int *)dataptr[0])[0];
        im = ((npy_int *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_int *)dataptr[i])[0] -
                  im * ((npy_int *)dataptr[i])[1];
            im = re * ((npy_int *)dataptr[i])[1] +
                 im * ((npy_int *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_int *)dataptr[1000])[0] += accum_re;
    ((npy_int *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_int *)dataptr[nop])[0] += accum_re;
    ((npy_int *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_int *)dataptr[1000]) = (accum +
                                    (*((npy_int *)dataptr[1000])));
#  else
    *((npy_int *)dataptr[nop]) = (accum +
                                    (*((npy_int *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
long_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_long *)data_out = ((*(npy_long *)data0) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) *
                                         (*(npy_long *)data2) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_long *)data_out)[0] = ((npy_long *)data0)[0] +
                                         ((npy_long *)data_out)[0];
        ((npy_long *)data_out)[1] = ((npy_long *)data0)[1] +
                                         ((npy_long *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
long_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data_out = (npy_long *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_long *)data_out + 2*6)[0] =
                                    ((npy_long *)data0 + 2*6)[0] +
                                    ((npy_long *)data_out + 2*6)[0];
            ((npy_long *)data_out + 2*6)[1] =
                                    ((npy_long *)data0 + 2*6)[1] +
                                    ((npy_long *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_long *)data_out + 2*5)[0] =
                                    ((npy_long *)data0 + 2*5)[0] +
                                    ((npy_long *)data_out + 2*5)[0];
            ((npy_long *)data_out + 2*5)[1] =
                                    ((npy_long *)data0 + 2*5)[1] +
                                    ((npy_long *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_long *)data_out + 2*4)[0] =
                                    ((npy_long *)data0 + 2*4)[0] +
                                    ((npy_long *)data_out + 2*4)[0];
            ((npy_long *)data_out + 2*4)[1] =
                                    ((npy_long *)data0 + 2*4)[1] +
                                    ((npy_long *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_long *)data_out + 2*3)[0] =
                                    ((npy_long *)data0 + 2*3)[0] +
                                    ((npy_long *)data_out + 2*3)[0];
            ((npy_long *)data_out + 2*3)[1] =
                                    ((npy_long *)data0 + 2*3)[1] +
                                    ((npy_long *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_long *)data_out + 2*2)[0] =
                                    ((npy_long *)data0 + 2*2)[0] +
                                    ((npy_long *)data_out + 2*2)[0];
            ((npy_long *)data_out + 2*2)[1] =
                                    ((npy_long *)data0 + 2*2)[1] +
                                    ((npy_long *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_long *)data_out + 2*1)[0] =
                                    ((npy_long *)data0 + 2*1)[0] +
                                    ((npy_long *)data_out + 2*1)[0];
            ((npy_long *)data_out + 2*1)[1] =
                                    ((npy_long *)data0 + 2*1)[1] +
                                    ((npy_long *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_long *)data_out + 2*0)[0] =
                                    ((npy_long *)data0 + 2*0)[0] +
                                    ((npy_long *)data_out + 2*0)[0];
            ((npy_long *)data_out + 2*0)[1] =
                                    ((npy_long *)data0 + 2*0)[1] +
                                    ((npy_long *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_long *)data_out + 2*0)[0] =
                                ((npy_long *)data0 + 2*0)[0] +
                                ((npy_long *)data_out + 2*0)[0];
        ((npy_long *)data_out + 2*0)[1] =
                                ((npy_long *)data0 + 2*0)[1] +
                                ((npy_long *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_long *)data_out + 2*1)[0] =
                                ((npy_long *)data0 + 2*1)[0] +
                                ((npy_long *)data_out + 2*1)[0];
        ((npy_long *)data_out + 2*1)[1] =
                                ((npy_long *)data0 + 2*1)[1] +
                                ((npy_long *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_long *)data_out + 2*2)[0] =
                                ((npy_long *)data0 + 2*2)[0] +
                                ((npy_long *)data_out + 2*2)[0];
        ((npy_long *)data_out + 2*2)[1] =
                                ((npy_long *)data0 + 2*2)[1] +
                                ((npy_long *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_long *)data_out + 2*3)[0] =
                                ((npy_long *)data0 + 2*3)[0] +
                                ((npy_long *)data_out + 2*3)[0];
        ((npy_long *)data_out + 2*3)[1] =
                                ((npy_long *)data0 + 2*3)[1] +
                                ((npy_long *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_long *)data_out + 2*4)[0] =
                                ((npy_long *)data0 + 2*4)[0] +
                                ((npy_long *)data_out + 2*4)[0];
        ((npy_long *)data_out + 2*4)[1] =
                                ((npy_long *)data0 + 2*4)[1] +
                                ((npy_long *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_long *)data_out + 2*5)[0] =
                                ((npy_long *)data0 + 2*5)[0] +
                                ((npy_long *)data_out + 2*5)[0];
        ((npy_long *)data_out + 2*5)[1] =
                                ((npy_long *)data0 + 2*5)[1] +
                                ((npy_long *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_long *)data_out + 2*6)[0] =
                                ((npy_long *)data0 + 2*6)[0] +
                                ((npy_long *)data_out + 2*6)[0];
        ((npy_long *)data_out + 2*6)[1] =
                                ((npy_long *)data0 + 2*6)[1] +
                                ((npy_long *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_long *)data_out + 2*7)[0] =
                                ((npy_long *)data0 + 2*7)[0] +
                                ((npy_long *)data_out + 2*7)[0];
        ((npy_long *)data_out + 2*7)[1] =
                                ((npy_long *)data0 + 2*7)[1] +
                                ((npy_long *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
long_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
long_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
long_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
long_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data2 = (npy_long *)dataptr[2];
    npy_long *data_out = (npy_long *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
long_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
long_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#else
    npy_long accum = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_long *)dataptr[1])[0] += accum_re;
            ((npy_long *)dataptr[1])[1] += accum_im;
#else
            *((npy_long *)dataptr[1]) = (accum +
                                    (*((npy_long *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
long_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
#else
    npy_long accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_long *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1) *
                 (*(npy_long *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_long *)data0)[0];
        accum_im += ((npy_long *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_long *)dataptr[1])[0] += accum_re;
    ((npy_long *)dataptr[1])[1] += accum_im;
#  else
    ((npy_long *)dataptr[nop])[0] += accum_re;
    ((npy_long *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_long *)dataptr[1]) = (accum +
                                    (*((npy_long *)dataptr[1])));
#  else
    *((npy_long *)dataptr[nop]) = (accum +
                                    (*((npy_long *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
long_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_long *)data_out = ((*(npy_long *)data0) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) *
                                         (*(npy_long *)data2) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_long *)data_out)[0] = ((npy_long *)data0)[0] +
                                         ((npy_long *)data_out)[0];
        ((npy_long *)data_out)[1] = ((npy_long *)data0)[1] +
                                         ((npy_long *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
long_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data_out = (npy_long *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_long *)data_out + 2*6)[0] =
                                    ((npy_long *)data0 + 2*6)[0] +
                                    ((npy_long *)data_out + 2*6)[0];
            ((npy_long *)data_out + 2*6)[1] =
                                    ((npy_long *)data0 + 2*6)[1] +
                                    ((npy_long *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_long *)data_out + 2*5)[0] =
                                    ((npy_long *)data0 + 2*5)[0] +
                                    ((npy_long *)data_out + 2*5)[0];
            ((npy_long *)data_out + 2*5)[1] =
                                    ((npy_long *)data0 + 2*5)[1] +
                                    ((npy_long *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_long *)data_out + 2*4)[0] =
                                    ((npy_long *)data0 + 2*4)[0] +
                                    ((npy_long *)data_out + 2*4)[0];
            ((npy_long *)data_out + 2*4)[1] =
                                    ((npy_long *)data0 + 2*4)[1] +
                                    ((npy_long *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_long *)data_out + 2*3)[0] =
                                    ((npy_long *)data0 + 2*3)[0] +
                                    ((npy_long *)data_out + 2*3)[0];
            ((npy_long *)data_out + 2*3)[1] =
                                    ((npy_long *)data0 + 2*3)[1] +
                                    ((npy_long *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_long *)data_out + 2*2)[0] =
                                    ((npy_long *)data0 + 2*2)[0] +
                                    ((npy_long *)data_out + 2*2)[0];
            ((npy_long *)data_out + 2*2)[1] =
                                    ((npy_long *)data0 + 2*2)[1] +
                                    ((npy_long *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_long *)data_out + 2*1)[0] =
                                    ((npy_long *)data0 + 2*1)[0] +
                                    ((npy_long *)data_out + 2*1)[0];
            ((npy_long *)data_out + 2*1)[1] =
                                    ((npy_long *)data0 + 2*1)[1] +
                                    ((npy_long *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_long *)data_out + 2*0)[0] =
                                    ((npy_long *)data0 + 2*0)[0] +
                                    ((npy_long *)data_out + 2*0)[0];
            ((npy_long *)data_out + 2*0)[1] =
                                    ((npy_long *)data0 + 2*0)[1] +
                                    ((npy_long *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_long *)data_out + 2*0)[0] =
                                ((npy_long *)data0 + 2*0)[0] +
                                ((npy_long *)data_out + 2*0)[0];
        ((npy_long *)data_out + 2*0)[1] =
                                ((npy_long *)data0 + 2*0)[1] +
                                ((npy_long *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_long *)data_out + 2*1)[0] =
                                ((npy_long *)data0 + 2*1)[0] +
                                ((npy_long *)data_out + 2*1)[0];
        ((npy_long *)data_out + 2*1)[1] =
                                ((npy_long *)data0 + 2*1)[1] +
                                ((npy_long *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_long *)data_out + 2*2)[0] =
                                ((npy_long *)data0 + 2*2)[0] +
                                ((npy_long *)data_out + 2*2)[0];
        ((npy_long *)data_out + 2*2)[1] =
                                ((npy_long *)data0 + 2*2)[1] +
                                ((npy_long *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_long *)data_out + 2*3)[0] =
                                ((npy_long *)data0 + 2*3)[0] +
                                ((npy_long *)data_out + 2*3)[0];
        ((npy_long *)data_out + 2*3)[1] =
                                ((npy_long *)data0 + 2*3)[1] +
                                ((npy_long *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_long *)data_out + 2*4)[0] =
                                ((npy_long *)data0 + 2*4)[0] +
                                ((npy_long *)data_out + 2*4)[0];
        ((npy_long *)data_out + 2*4)[1] =
                                ((npy_long *)data0 + 2*4)[1] +
                                ((npy_long *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_long *)data_out + 2*5)[0] =
                                ((npy_long *)data0 + 2*5)[0] +
                                ((npy_long *)data_out + 2*5)[0];
        ((npy_long *)data_out + 2*5)[1] =
                                ((npy_long *)data0 + 2*5)[1] +
                                ((npy_long *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_long *)data_out + 2*6)[0] =
                                ((npy_long *)data0 + 2*6)[0] +
                                ((npy_long *)data_out + 2*6)[0];
        ((npy_long *)data_out + 2*6)[1] =
                                ((npy_long *)data0 + 2*6)[1] +
                                ((npy_long *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_long *)data_out + 2*7)[0] =
                                ((npy_long *)data0 + 2*7)[0] +
                                ((npy_long *)data_out + 2*7)[0];
        ((npy_long *)data_out + 2*7)[1] =
                                ((npy_long *)data0 + 2*7)[1] +
                                ((npy_long *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
long_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
long_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
long_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
long_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data2 = (npy_long *)dataptr[2];
    npy_long *data_out = (npy_long *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
long_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
long_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#else
    npy_long accum = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_long *)dataptr[1])[0] += accum_re;
            ((npy_long *)dataptr[1])[1] += accum_im;
#else
            *((npy_long *)dataptr[1]) = (accum +
                                    (*((npy_long *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
long_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
#else
    npy_long accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_long *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1) *
                 (*(npy_long *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_long *)data0)[0];
        accum_im += ((npy_long *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_long *)dataptr[2])[0] += accum_re;
    ((npy_long *)dataptr[2])[1] += accum_im;
#  else
    ((npy_long *)dataptr[nop])[0] += accum_re;
    ((npy_long *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_long *)dataptr[2]) = (accum +
                                    (*((npy_long *)dataptr[2])));
#  else
    *((npy_long *)dataptr[nop]) = (accum +
                                    (*((npy_long *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
long_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_long *)data_out = ((*(npy_long *)data0) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) *
                                         (*(npy_long *)data2) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_long *)data_out)[0] = ((npy_long *)data0)[0] +
                                         ((npy_long *)data_out)[0];
        ((npy_long *)data_out)[1] = ((npy_long *)data0)[1] +
                                         ((npy_long *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
long_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data_out = (npy_long *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_long *)data_out + 2*6)[0] =
                                    ((npy_long *)data0 + 2*6)[0] +
                                    ((npy_long *)data_out + 2*6)[0];
            ((npy_long *)data_out + 2*6)[1] =
                                    ((npy_long *)data0 + 2*6)[1] +
                                    ((npy_long *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_long *)data_out + 2*5)[0] =
                                    ((npy_long *)data0 + 2*5)[0] +
                                    ((npy_long *)data_out + 2*5)[0];
            ((npy_long *)data_out + 2*5)[1] =
                                    ((npy_long *)data0 + 2*5)[1] +
                                    ((npy_long *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_long *)data_out + 2*4)[0] =
                                    ((npy_long *)data0 + 2*4)[0] +
                                    ((npy_long *)data_out + 2*4)[0];
            ((npy_long *)data_out + 2*4)[1] =
                                    ((npy_long *)data0 + 2*4)[1] +
                                    ((npy_long *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_long *)data_out + 2*3)[0] =
                                    ((npy_long *)data0 + 2*3)[0] +
                                    ((npy_long *)data_out + 2*3)[0];
            ((npy_long *)data_out + 2*3)[1] =
                                    ((npy_long *)data0 + 2*3)[1] +
                                    ((npy_long *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_long *)data_out + 2*2)[0] =
                                    ((npy_long *)data0 + 2*2)[0] +
                                    ((npy_long *)data_out + 2*2)[0];
            ((npy_long *)data_out + 2*2)[1] =
                                    ((npy_long *)data0 + 2*2)[1] +
                                    ((npy_long *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_long *)data_out + 2*1)[0] =
                                    ((npy_long *)data0 + 2*1)[0] +
                                    ((npy_long *)data_out + 2*1)[0];
            ((npy_long *)data_out + 2*1)[1] =
                                    ((npy_long *)data0 + 2*1)[1] +
                                    ((npy_long *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_long *)data_out + 2*0)[0] =
                                    ((npy_long *)data0 + 2*0)[0] +
                                    ((npy_long *)data_out + 2*0)[0];
            ((npy_long *)data_out + 2*0)[1] =
                                    ((npy_long *)data0 + 2*0)[1] +
                                    ((npy_long *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_long *)data_out + 2*0)[0] =
                                ((npy_long *)data0 + 2*0)[0] +
                                ((npy_long *)data_out + 2*0)[0];
        ((npy_long *)data_out + 2*0)[1] =
                                ((npy_long *)data0 + 2*0)[1] +
                                ((npy_long *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_long *)data_out + 2*1)[0] =
                                ((npy_long *)data0 + 2*1)[0] +
                                ((npy_long *)data_out + 2*1)[0];
        ((npy_long *)data_out + 2*1)[1] =
                                ((npy_long *)data0 + 2*1)[1] +
                                ((npy_long *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_long *)data_out + 2*2)[0] =
                                ((npy_long *)data0 + 2*2)[0] +
                                ((npy_long *)data_out + 2*2)[0];
        ((npy_long *)data_out + 2*2)[1] =
                                ((npy_long *)data0 + 2*2)[1] +
                                ((npy_long *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_long *)data_out + 2*3)[0] =
                                ((npy_long *)data0 + 2*3)[0] +
                                ((npy_long *)data_out + 2*3)[0];
        ((npy_long *)data_out + 2*3)[1] =
                                ((npy_long *)data0 + 2*3)[1] +
                                ((npy_long *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_long *)data_out + 2*4)[0] =
                                ((npy_long *)data0 + 2*4)[0] +
                                ((npy_long *)data_out + 2*4)[0];
        ((npy_long *)data_out + 2*4)[1] =
                                ((npy_long *)data0 + 2*4)[1] +
                                ((npy_long *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_long *)data_out + 2*5)[0] =
                                ((npy_long *)data0 + 2*5)[0] +
                                ((npy_long *)data_out + 2*5)[0];
        ((npy_long *)data_out + 2*5)[1] =
                                ((npy_long *)data0 + 2*5)[1] +
                                ((npy_long *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_long *)data_out + 2*6)[0] =
                                ((npy_long *)data0 + 2*6)[0] +
                                ((npy_long *)data_out + 2*6)[0];
        ((npy_long *)data_out + 2*6)[1] =
                                ((npy_long *)data0 + 2*6)[1] +
                                ((npy_long *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_long *)data_out + 2*7)[0] =
                                ((npy_long *)data0 + 2*7)[0] +
                                ((npy_long *)data_out + 2*7)[0];
        ((npy_long *)data_out + 2*7)[1] =
                                ((npy_long *)data0 + 2*7)[1] +
                                ((npy_long *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
long_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
long_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
long_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
long_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data2 = (npy_long *)dataptr[2];
    npy_long *data_out = (npy_long *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
long_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
long_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#else
    npy_long accum = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_long *)dataptr[1])[0] += accum_re;
            ((npy_long *)dataptr[1])[1] += accum_im;
#else
            *((npy_long *)dataptr[1]) = (accum +
                                    (*((npy_long *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
long_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
#else
    npy_long accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_long *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1) *
                 (*(npy_long *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_long *)data0)[0];
        accum_im += ((npy_long *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_long *)dataptr[3])[0] += accum_re;
    ((npy_long *)dataptr[3])[1] += accum_im;
#  else
    ((npy_long *)dataptr[nop])[0] += accum_re;
    ((npy_long *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_long *)dataptr[3]) = (accum +
                                    (*((npy_long *)dataptr[3])));
#  else
    *((npy_long *)dataptr[nop]) = (accum +
                                    (*((npy_long *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
long_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_long *)data_out = ((*(npy_long *)data0) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_long *)data_out = ((*(npy_long *)data0) *
                                         (*(npy_long *)data1) *
                                         (*(npy_long *)data2) +
                                         (*(npy_long *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_long *)data_out)[0] = ((npy_long *)data0)[0] +
                                         ((npy_long *)data_out)[0];
        ((npy_long *)data_out)[1] = ((npy_long *)data0)[1] +
                                         ((npy_long *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
long_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data_out = (npy_long *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_long *)data_out + 2*6)[0] =
                                    ((npy_long *)data0 + 2*6)[0] +
                                    ((npy_long *)data_out + 2*6)[0];
            ((npy_long *)data_out + 2*6)[1] =
                                    ((npy_long *)data0 + 2*6)[1] +
                                    ((npy_long *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_long *)data_out + 2*5)[0] =
                                    ((npy_long *)data0 + 2*5)[0] +
                                    ((npy_long *)data_out + 2*5)[0];
            ((npy_long *)data_out + 2*5)[1] =
                                    ((npy_long *)data0 + 2*5)[1] +
                                    ((npy_long *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_long *)data_out + 2*4)[0] =
                                    ((npy_long *)data0 + 2*4)[0] +
                                    ((npy_long *)data_out + 2*4)[0];
            ((npy_long *)data_out + 2*4)[1] =
                                    ((npy_long *)data0 + 2*4)[1] +
                                    ((npy_long *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_long *)data_out + 2*3)[0] =
                                    ((npy_long *)data0 + 2*3)[0] +
                                    ((npy_long *)data_out + 2*3)[0];
            ((npy_long *)data_out + 2*3)[1] =
                                    ((npy_long *)data0 + 2*3)[1] +
                                    ((npy_long *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_long *)data_out + 2*2)[0] =
                                    ((npy_long *)data0 + 2*2)[0] +
                                    ((npy_long *)data_out + 2*2)[0];
            ((npy_long *)data_out + 2*2)[1] =
                                    ((npy_long *)data0 + 2*2)[1] +
                                    ((npy_long *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_long *)data_out + 2*1)[0] =
                                    ((npy_long *)data0 + 2*1)[0] +
                                    ((npy_long *)data_out + 2*1)[0];
            ((npy_long *)data_out + 2*1)[1] =
                                    ((npy_long *)data0 + 2*1)[1] +
                                    ((npy_long *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_long *)data_out + 2*0)[0] =
                                    ((npy_long *)data0 + 2*0)[0] +
                                    ((npy_long *)data_out + 2*0)[0];
            ((npy_long *)data_out + 2*0)[1] =
                                    ((npy_long *)data0 + 2*0)[1] +
                                    ((npy_long *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_long *)data_out + 2*0)[0] =
                                ((npy_long *)data0 + 2*0)[0] +
                                ((npy_long *)data_out + 2*0)[0];
        ((npy_long *)data_out + 2*0)[1] =
                                ((npy_long *)data0 + 2*0)[1] +
                                ((npy_long *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_long *)data_out + 2*1)[0] =
                                ((npy_long *)data0 + 2*1)[0] +
                                ((npy_long *)data_out + 2*1)[0];
        ((npy_long *)data_out + 2*1)[1] =
                                ((npy_long *)data0 + 2*1)[1] +
                                ((npy_long *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_long *)data_out + 2*2)[0] =
                                ((npy_long *)data0 + 2*2)[0] +
                                ((npy_long *)data_out + 2*2)[0];
        ((npy_long *)data_out + 2*2)[1] =
                                ((npy_long *)data0 + 2*2)[1] +
                                ((npy_long *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_long *)data_out + 2*3)[0] =
                                ((npy_long *)data0 + 2*3)[0] +
                                ((npy_long *)data_out + 2*3)[0];
        ((npy_long *)data_out + 2*3)[1] =
                                ((npy_long *)data0 + 2*3)[1] +
                                ((npy_long *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_long *)data_out + 2*4)[0] =
                                ((npy_long *)data0 + 2*4)[0] +
                                ((npy_long *)data_out + 2*4)[0];
        ((npy_long *)data_out + 2*4)[1] =
                                ((npy_long *)data0 + 2*4)[1] +
                                ((npy_long *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_long *)data_out + 2*5)[0] =
                                ((npy_long *)data0 + 2*5)[0] +
                                ((npy_long *)data_out + 2*5)[0];
        ((npy_long *)data_out + 2*5)[1] =
                                ((npy_long *)data0 + 2*5)[1] +
                                ((npy_long *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_long *)data_out + 2*6)[0] =
                                ((npy_long *)data0 + 2*6)[0] +
                                ((npy_long *)data_out + 2*6)[0];
        ((npy_long *)data_out + 2*6)[1] =
                                ((npy_long *)data0 + 2*6)[1] +
                                ((npy_long *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_long *)data_out + 2*7)[0] =
                                ((npy_long *)data0 + 2*7)[0] +
                                ((npy_long *)data_out + 2*7)[0];
        ((npy_long *)data_out + 2*7)[1] =
                                ((npy_long *)data0 + 2*7)[1] +
                                ((npy_long *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
long_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
long_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
long_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long *data_out = (npy_long *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long value0 = (*(npy_long *)dataptr[0]);
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
long_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long value1 = (*(npy_long *)dataptr[1]);
    npy_long accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_long *)dataptr[2] = ((*(npy_long *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
long_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_long *data0 = (npy_long *)dataptr[0];
    npy_long *data1 = (npy_long *)dataptr[1];
    npy_long *data2 = (npy_long *)dataptr[2];
    npy_long *data_out = (npy_long *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
long_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        *(npy_long *)dataptr[nop] = (temp +
                                           (*(npy_long *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_long *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[0];
        ((npy_long *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_long *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_long);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
long_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#else
    npy_long accum = 0;
    npy_long *data0 = (npy_long *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_long *)dataptr[1])[0] += accum_re;
            ((npy_long *)dataptr[1])[1] += accum_im;
#else
            *((npy_long *)dataptr[1]) = (accum +
                                    (*((npy_long *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
long_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_long accum_re = 0, accum_im = 0;
#else
    npy_long accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("long_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_long *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_long *)data0) *
                 (*(npy_long *)data1) *
                 (*(npy_long *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_long temp = (*(npy_long *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_long *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_long *)data0)[0];
        accum_im += ((npy_long *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_long re, im, tmp;
        int i;
        re = ((npy_long *)dataptr[0])[0];
        im = ((npy_long *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_long *)dataptr[i])[0] -
                  im * ((npy_long *)dataptr[i])[1];
            im = re * ((npy_long *)dataptr[i])[1] +
                 im * ((npy_long *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_long *)dataptr[1000])[0] += accum_re;
    ((npy_long *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_long *)dataptr[nop])[0] += accum_re;
    ((npy_long *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_long *)dataptr[1000]) = (accum +
                                    (*((npy_long *)dataptr[1000])));
#  else
    *((npy_long *)dataptr[nop]) = (accum +
                                    (*((npy_long *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
longlong_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) *
                                         (*(npy_longlong *)data2) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_longlong *)data_out)[0] = ((npy_longlong *)data0)[0] +
                                         ((npy_longlong *)data_out)[0];
        ((npy_longlong *)data_out)[1] = ((npy_longlong *)data0)[1] +
                                         ((npy_longlong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
longlong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data_out = (npy_longlong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longlong *)data_out + 2*6)[0] =
                                    ((npy_longlong *)data0 + 2*6)[0] +
                                    ((npy_longlong *)data_out + 2*6)[0];
            ((npy_longlong *)data_out + 2*6)[1] =
                                    ((npy_longlong *)data0 + 2*6)[1] +
                                    ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longlong *)data_out + 2*5)[0] =
                                    ((npy_longlong *)data0 + 2*5)[0] +
                                    ((npy_longlong *)data_out + 2*5)[0];
            ((npy_longlong *)data_out + 2*5)[1] =
                                    ((npy_longlong *)data0 + 2*5)[1] +
                                    ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longlong *)data_out + 2*4)[0] =
                                    ((npy_longlong *)data0 + 2*4)[0] +
                                    ((npy_longlong *)data_out + 2*4)[0];
            ((npy_longlong *)data_out + 2*4)[1] =
                                    ((npy_longlong *)data0 + 2*4)[1] +
                                    ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longlong *)data_out + 2*3)[0] =
                                    ((npy_longlong *)data0 + 2*3)[0] +
                                    ((npy_longlong *)data_out + 2*3)[0];
            ((npy_longlong *)data_out + 2*3)[1] =
                                    ((npy_longlong *)data0 + 2*3)[1] +
                                    ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longlong *)data_out + 2*2)[0] =
                                    ((npy_longlong *)data0 + 2*2)[0] +
                                    ((npy_longlong *)data_out + 2*2)[0];
            ((npy_longlong *)data_out + 2*2)[1] =
                                    ((npy_longlong *)data0 + 2*2)[1] +
                                    ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longlong *)data_out + 2*1)[0] =
                                    ((npy_longlong *)data0 + 2*1)[0] +
                                    ((npy_longlong *)data_out + 2*1)[0];
            ((npy_longlong *)data_out + 2*1)[1] =
                                    ((npy_longlong *)data0 + 2*1)[1] +
                                    ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longlong *)data_out + 2*0)[0] =
                                    ((npy_longlong *)data0 + 2*0)[0] +
                                    ((npy_longlong *)data_out + 2*0)[0];
            ((npy_longlong *)data_out + 2*0)[1] =
                                    ((npy_longlong *)data0 + 2*0)[1] +
                                    ((npy_longlong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longlong *)data_out + 2*0)[0] =
                                ((npy_longlong *)data0 + 2*0)[0] +
                                ((npy_longlong *)data_out + 2*0)[0];
        ((npy_longlong *)data_out + 2*0)[1] =
                                ((npy_longlong *)data0 + 2*0)[1] +
                                ((npy_longlong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longlong *)data_out + 2*1)[0] =
                                ((npy_longlong *)data0 + 2*1)[0] +
                                ((npy_longlong *)data_out + 2*1)[0];
        ((npy_longlong *)data_out + 2*1)[1] =
                                ((npy_longlong *)data0 + 2*1)[1] +
                                ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longlong *)data_out + 2*2)[0] =
                                ((npy_longlong *)data0 + 2*2)[0] +
                                ((npy_longlong *)data_out + 2*2)[0];
        ((npy_longlong *)data_out + 2*2)[1] =
                                ((npy_longlong *)data0 + 2*2)[1] +
                                ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longlong *)data_out + 2*3)[0] =
                                ((npy_longlong *)data0 + 2*3)[0] +
                                ((npy_longlong *)data_out + 2*3)[0];
        ((npy_longlong *)data_out + 2*3)[1] =
                                ((npy_longlong *)data0 + 2*3)[1] +
                                ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longlong *)data_out + 2*4)[0] =
                                ((npy_longlong *)data0 + 2*4)[0] +
                                ((npy_longlong *)data_out + 2*4)[0];
        ((npy_longlong *)data_out + 2*4)[1] =
                                ((npy_longlong *)data0 + 2*4)[1] +
                                ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longlong *)data_out + 2*5)[0] =
                                ((npy_longlong *)data0 + 2*5)[0] +
                                ((npy_longlong *)data_out + 2*5)[0];
        ((npy_longlong *)data_out + 2*5)[1] =
                                ((npy_longlong *)data0 + 2*5)[1] +
                                ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longlong *)data_out + 2*6)[0] =
                                ((npy_longlong *)data0 + 2*6)[0] +
                                ((npy_longlong *)data_out + 2*6)[0];
        ((npy_longlong *)data_out + 2*6)[1] =
                                ((npy_longlong *)data0 + 2*6)[1] +
                                ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longlong *)data_out + 2*7)[0] =
                                ((npy_longlong *)data0 + 2*7)[0] +
                                ((npy_longlong *)data_out + 2*7)[0];
        ((npy_longlong *)data_out + 2*7)[1] =
                                ((npy_longlong *)data0 + 2*7)[1] +
                                ((npy_longlong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
longlong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longlong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longlong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
longlong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data2 = (npy_longlong *)dataptr[2];
    npy_longlong *data_out = (npy_longlong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
longlong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
longlong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#else
    npy_longlong accum = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longlong *)dataptr[1])[0] += accum_re;
            ((npy_longlong *)dataptr[1])[1] += accum_im;
#else
            *((npy_longlong *)dataptr[1]) = (accum +
                                    (*((npy_longlong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
longlong_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
#else
    npy_longlong accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_longlong *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1) *
                 (*(npy_longlong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_longlong *)data0)[0];
        accum_im += ((npy_longlong *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_longlong *)dataptr[1])[0] += accum_re;
    ((npy_longlong *)dataptr[1])[1] += accum_im;
#  else
    ((npy_longlong *)dataptr[nop])[0] += accum_re;
    ((npy_longlong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_longlong *)dataptr[1]) = (accum +
                                    (*((npy_longlong *)dataptr[1])));
#  else
    *((npy_longlong *)dataptr[nop]) = (accum +
                                    (*((npy_longlong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longlong_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) *
                                         (*(npy_longlong *)data2) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_longlong *)data_out)[0] = ((npy_longlong *)data0)[0] +
                                         ((npy_longlong *)data_out)[0];
        ((npy_longlong *)data_out)[1] = ((npy_longlong *)data0)[1] +
                                         ((npy_longlong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
longlong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data_out = (npy_longlong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longlong *)data_out + 2*6)[0] =
                                    ((npy_longlong *)data0 + 2*6)[0] +
                                    ((npy_longlong *)data_out + 2*6)[0];
            ((npy_longlong *)data_out + 2*6)[1] =
                                    ((npy_longlong *)data0 + 2*6)[1] +
                                    ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longlong *)data_out + 2*5)[0] =
                                    ((npy_longlong *)data0 + 2*5)[0] +
                                    ((npy_longlong *)data_out + 2*5)[0];
            ((npy_longlong *)data_out + 2*5)[1] =
                                    ((npy_longlong *)data0 + 2*5)[1] +
                                    ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longlong *)data_out + 2*4)[0] =
                                    ((npy_longlong *)data0 + 2*4)[0] +
                                    ((npy_longlong *)data_out + 2*4)[0];
            ((npy_longlong *)data_out + 2*4)[1] =
                                    ((npy_longlong *)data0 + 2*4)[1] +
                                    ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longlong *)data_out + 2*3)[0] =
                                    ((npy_longlong *)data0 + 2*3)[0] +
                                    ((npy_longlong *)data_out + 2*3)[0];
            ((npy_longlong *)data_out + 2*3)[1] =
                                    ((npy_longlong *)data0 + 2*3)[1] +
                                    ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longlong *)data_out + 2*2)[0] =
                                    ((npy_longlong *)data0 + 2*2)[0] +
                                    ((npy_longlong *)data_out + 2*2)[0];
            ((npy_longlong *)data_out + 2*2)[1] =
                                    ((npy_longlong *)data0 + 2*2)[1] +
                                    ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longlong *)data_out + 2*1)[0] =
                                    ((npy_longlong *)data0 + 2*1)[0] +
                                    ((npy_longlong *)data_out + 2*1)[0];
            ((npy_longlong *)data_out + 2*1)[1] =
                                    ((npy_longlong *)data0 + 2*1)[1] +
                                    ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longlong *)data_out + 2*0)[0] =
                                    ((npy_longlong *)data0 + 2*0)[0] +
                                    ((npy_longlong *)data_out + 2*0)[0];
            ((npy_longlong *)data_out + 2*0)[1] =
                                    ((npy_longlong *)data0 + 2*0)[1] +
                                    ((npy_longlong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longlong *)data_out + 2*0)[0] =
                                ((npy_longlong *)data0 + 2*0)[0] +
                                ((npy_longlong *)data_out + 2*0)[0];
        ((npy_longlong *)data_out + 2*0)[1] =
                                ((npy_longlong *)data0 + 2*0)[1] +
                                ((npy_longlong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longlong *)data_out + 2*1)[0] =
                                ((npy_longlong *)data0 + 2*1)[0] +
                                ((npy_longlong *)data_out + 2*1)[0];
        ((npy_longlong *)data_out + 2*1)[1] =
                                ((npy_longlong *)data0 + 2*1)[1] +
                                ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longlong *)data_out + 2*2)[0] =
                                ((npy_longlong *)data0 + 2*2)[0] +
                                ((npy_longlong *)data_out + 2*2)[0];
        ((npy_longlong *)data_out + 2*2)[1] =
                                ((npy_longlong *)data0 + 2*2)[1] +
                                ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longlong *)data_out + 2*3)[0] =
                                ((npy_longlong *)data0 + 2*3)[0] +
                                ((npy_longlong *)data_out + 2*3)[0];
        ((npy_longlong *)data_out + 2*3)[1] =
                                ((npy_longlong *)data0 + 2*3)[1] +
                                ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longlong *)data_out + 2*4)[0] =
                                ((npy_longlong *)data0 + 2*4)[0] +
                                ((npy_longlong *)data_out + 2*4)[0];
        ((npy_longlong *)data_out + 2*4)[1] =
                                ((npy_longlong *)data0 + 2*4)[1] +
                                ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longlong *)data_out + 2*5)[0] =
                                ((npy_longlong *)data0 + 2*5)[0] +
                                ((npy_longlong *)data_out + 2*5)[0];
        ((npy_longlong *)data_out + 2*5)[1] =
                                ((npy_longlong *)data0 + 2*5)[1] +
                                ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longlong *)data_out + 2*6)[0] =
                                ((npy_longlong *)data0 + 2*6)[0] +
                                ((npy_longlong *)data_out + 2*6)[0];
        ((npy_longlong *)data_out + 2*6)[1] =
                                ((npy_longlong *)data0 + 2*6)[1] +
                                ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longlong *)data_out + 2*7)[0] =
                                ((npy_longlong *)data0 + 2*7)[0] +
                                ((npy_longlong *)data_out + 2*7)[0];
        ((npy_longlong *)data_out + 2*7)[1] =
                                ((npy_longlong *)data0 + 2*7)[1] +
                                ((npy_longlong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
longlong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longlong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longlong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
longlong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data2 = (npy_longlong *)dataptr[2];
    npy_longlong *data_out = (npy_longlong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
longlong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
longlong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#else
    npy_longlong accum = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longlong *)dataptr[1])[0] += accum_re;
            ((npy_longlong *)dataptr[1])[1] += accum_im;
#else
            *((npy_longlong *)dataptr[1]) = (accum +
                                    (*((npy_longlong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
longlong_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
#else
    npy_longlong accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_longlong *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1) *
                 (*(npy_longlong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_longlong *)data0)[0];
        accum_im += ((npy_longlong *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_longlong *)dataptr[2])[0] += accum_re;
    ((npy_longlong *)dataptr[2])[1] += accum_im;
#  else
    ((npy_longlong *)dataptr[nop])[0] += accum_re;
    ((npy_longlong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_longlong *)dataptr[2]) = (accum +
                                    (*((npy_longlong *)dataptr[2])));
#  else
    *((npy_longlong *)dataptr[nop]) = (accum +
                                    (*((npy_longlong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longlong_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) *
                                         (*(npy_longlong *)data2) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_longlong *)data_out)[0] = ((npy_longlong *)data0)[0] +
                                         ((npy_longlong *)data_out)[0];
        ((npy_longlong *)data_out)[1] = ((npy_longlong *)data0)[1] +
                                         ((npy_longlong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
longlong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data_out = (npy_longlong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longlong *)data_out + 2*6)[0] =
                                    ((npy_longlong *)data0 + 2*6)[0] +
                                    ((npy_longlong *)data_out + 2*6)[0];
            ((npy_longlong *)data_out + 2*6)[1] =
                                    ((npy_longlong *)data0 + 2*6)[1] +
                                    ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longlong *)data_out + 2*5)[0] =
                                    ((npy_longlong *)data0 + 2*5)[0] +
                                    ((npy_longlong *)data_out + 2*5)[0];
            ((npy_longlong *)data_out + 2*5)[1] =
                                    ((npy_longlong *)data0 + 2*5)[1] +
                                    ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longlong *)data_out + 2*4)[0] =
                                    ((npy_longlong *)data0 + 2*4)[0] +
                                    ((npy_longlong *)data_out + 2*4)[0];
            ((npy_longlong *)data_out + 2*4)[1] =
                                    ((npy_longlong *)data0 + 2*4)[1] +
                                    ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longlong *)data_out + 2*3)[0] =
                                    ((npy_longlong *)data0 + 2*3)[0] +
                                    ((npy_longlong *)data_out + 2*3)[0];
            ((npy_longlong *)data_out + 2*3)[1] =
                                    ((npy_longlong *)data0 + 2*3)[1] +
                                    ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longlong *)data_out + 2*2)[0] =
                                    ((npy_longlong *)data0 + 2*2)[0] +
                                    ((npy_longlong *)data_out + 2*2)[0];
            ((npy_longlong *)data_out + 2*2)[1] =
                                    ((npy_longlong *)data0 + 2*2)[1] +
                                    ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longlong *)data_out + 2*1)[0] =
                                    ((npy_longlong *)data0 + 2*1)[0] +
                                    ((npy_longlong *)data_out + 2*1)[0];
            ((npy_longlong *)data_out + 2*1)[1] =
                                    ((npy_longlong *)data0 + 2*1)[1] +
                                    ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longlong *)data_out + 2*0)[0] =
                                    ((npy_longlong *)data0 + 2*0)[0] +
                                    ((npy_longlong *)data_out + 2*0)[0];
            ((npy_longlong *)data_out + 2*0)[1] =
                                    ((npy_longlong *)data0 + 2*0)[1] +
                                    ((npy_longlong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longlong *)data_out + 2*0)[0] =
                                ((npy_longlong *)data0 + 2*0)[0] +
                                ((npy_longlong *)data_out + 2*0)[0];
        ((npy_longlong *)data_out + 2*0)[1] =
                                ((npy_longlong *)data0 + 2*0)[1] +
                                ((npy_longlong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longlong *)data_out + 2*1)[0] =
                                ((npy_longlong *)data0 + 2*1)[0] +
                                ((npy_longlong *)data_out + 2*1)[0];
        ((npy_longlong *)data_out + 2*1)[1] =
                                ((npy_longlong *)data0 + 2*1)[1] +
                                ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longlong *)data_out + 2*2)[0] =
                                ((npy_longlong *)data0 + 2*2)[0] +
                                ((npy_longlong *)data_out + 2*2)[0];
        ((npy_longlong *)data_out + 2*2)[1] =
                                ((npy_longlong *)data0 + 2*2)[1] +
                                ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longlong *)data_out + 2*3)[0] =
                                ((npy_longlong *)data0 + 2*3)[0] +
                                ((npy_longlong *)data_out + 2*3)[0];
        ((npy_longlong *)data_out + 2*3)[1] =
                                ((npy_longlong *)data0 + 2*3)[1] +
                                ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longlong *)data_out + 2*4)[0] =
                                ((npy_longlong *)data0 + 2*4)[0] +
                                ((npy_longlong *)data_out + 2*4)[0];
        ((npy_longlong *)data_out + 2*4)[1] =
                                ((npy_longlong *)data0 + 2*4)[1] +
                                ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longlong *)data_out + 2*5)[0] =
                                ((npy_longlong *)data0 + 2*5)[0] +
                                ((npy_longlong *)data_out + 2*5)[0];
        ((npy_longlong *)data_out + 2*5)[1] =
                                ((npy_longlong *)data0 + 2*5)[1] +
                                ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longlong *)data_out + 2*6)[0] =
                                ((npy_longlong *)data0 + 2*6)[0] +
                                ((npy_longlong *)data_out + 2*6)[0];
        ((npy_longlong *)data_out + 2*6)[1] =
                                ((npy_longlong *)data0 + 2*6)[1] +
                                ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longlong *)data_out + 2*7)[0] =
                                ((npy_longlong *)data0 + 2*7)[0] +
                                ((npy_longlong *)data_out + 2*7)[0];
        ((npy_longlong *)data_out + 2*7)[1] =
                                ((npy_longlong *)data0 + 2*7)[1] +
                                ((npy_longlong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
longlong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longlong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longlong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
longlong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data2 = (npy_longlong *)dataptr[2];
    npy_longlong *data_out = (npy_longlong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
longlong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
longlong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#else
    npy_longlong accum = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longlong *)dataptr[1])[0] += accum_re;
            ((npy_longlong *)dataptr[1])[1] += accum_im;
#else
            *((npy_longlong *)dataptr[1]) = (accum +
                                    (*((npy_longlong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
longlong_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
#else
    npy_longlong accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_longlong *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1) *
                 (*(npy_longlong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_longlong *)data0)[0];
        accum_im += ((npy_longlong *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_longlong *)dataptr[3])[0] += accum_re;
    ((npy_longlong *)dataptr[3])[1] += accum_im;
#  else
    ((npy_longlong *)dataptr[nop])[0] += accum_re;
    ((npy_longlong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_longlong *)dataptr[3]) = (accum +
                                    (*((npy_longlong *)dataptr[3])));
#  else
    *((npy_longlong *)dataptr[nop]) = (accum +
                                    (*((npy_longlong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longlong_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_longlong *)data_out = ((*(npy_longlong *)data0) *
                                         (*(npy_longlong *)data1) *
                                         (*(npy_longlong *)data2) +
                                         (*(npy_longlong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_longlong *)data_out)[0] = ((npy_longlong *)data0)[0] +
                                         ((npy_longlong *)data_out)[0];
        ((npy_longlong *)data_out)[1] = ((npy_longlong *)data0)[1] +
                                         ((npy_longlong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
longlong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data_out = (npy_longlong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longlong *)data_out + 2*6)[0] =
                                    ((npy_longlong *)data0 + 2*6)[0] +
                                    ((npy_longlong *)data_out + 2*6)[0];
            ((npy_longlong *)data_out + 2*6)[1] =
                                    ((npy_longlong *)data0 + 2*6)[1] +
                                    ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longlong *)data_out + 2*5)[0] =
                                    ((npy_longlong *)data0 + 2*5)[0] +
                                    ((npy_longlong *)data_out + 2*5)[0];
            ((npy_longlong *)data_out + 2*5)[1] =
                                    ((npy_longlong *)data0 + 2*5)[1] +
                                    ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longlong *)data_out + 2*4)[0] =
                                    ((npy_longlong *)data0 + 2*4)[0] +
                                    ((npy_longlong *)data_out + 2*4)[0];
            ((npy_longlong *)data_out + 2*4)[1] =
                                    ((npy_longlong *)data0 + 2*4)[1] +
                                    ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longlong *)data_out + 2*3)[0] =
                                    ((npy_longlong *)data0 + 2*3)[0] +
                                    ((npy_longlong *)data_out + 2*3)[0];
            ((npy_longlong *)data_out + 2*3)[1] =
                                    ((npy_longlong *)data0 + 2*3)[1] +
                                    ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longlong *)data_out + 2*2)[0] =
                                    ((npy_longlong *)data0 + 2*2)[0] +
                                    ((npy_longlong *)data_out + 2*2)[0];
            ((npy_longlong *)data_out + 2*2)[1] =
                                    ((npy_longlong *)data0 + 2*2)[1] +
                                    ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longlong *)data_out + 2*1)[0] =
                                    ((npy_longlong *)data0 + 2*1)[0] +
                                    ((npy_longlong *)data_out + 2*1)[0];
            ((npy_longlong *)data_out + 2*1)[1] =
                                    ((npy_longlong *)data0 + 2*1)[1] +
                                    ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longlong *)data_out + 2*0)[0] =
                                    ((npy_longlong *)data0 + 2*0)[0] +
                                    ((npy_longlong *)data_out + 2*0)[0];
            ((npy_longlong *)data_out + 2*0)[1] =
                                    ((npy_longlong *)data0 + 2*0)[1] +
                                    ((npy_longlong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longlong *)data_out + 2*0)[0] =
                                ((npy_longlong *)data0 + 2*0)[0] +
                                ((npy_longlong *)data_out + 2*0)[0];
        ((npy_longlong *)data_out + 2*0)[1] =
                                ((npy_longlong *)data0 + 2*0)[1] +
                                ((npy_longlong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longlong *)data_out + 2*1)[0] =
                                ((npy_longlong *)data0 + 2*1)[0] +
                                ((npy_longlong *)data_out + 2*1)[0];
        ((npy_longlong *)data_out + 2*1)[1] =
                                ((npy_longlong *)data0 + 2*1)[1] +
                                ((npy_longlong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longlong *)data_out + 2*2)[0] =
                                ((npy_longlong *)data0 + 2*2)[0] +
                                ((npy_longlong *)data_out + 2*2)[0];
        ((npy_longlong *)data_out + 2*2)[1] =
                                ((npy_longlong *)data0 + 2*2)[1] +
                                ((npy_longlong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longlong *)data_out + 2*3)[0] =
                                ((npy_longlong *)data0 + 2*3)[0] +
                                ((npy_longlong *)data_out + 2*3)[0];
        ((npy_longlong *)data_out + 2*3)[1] =
                                ((npy_longlong *)data0 + 2*3)[1] +
                                ((npy_longlong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longlong *)data_out + 2*4)[0] =
                                ((npy_longlong *)data0 + 2*4)[0] +
                                ((npy_longlong *)data_out + 2*4)[0];
        ((npy_longlong *)data_out + 2*4)[1] =
                                ((npy_longlong *)data0 + 2*4)[1] +
                                ((npy_longlong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longlong *)data_out + 2*5)[0] =
                                ((npy_longlong *)data0 + 2*5)[0] +
                                ((npy_longlong *)data_out + 2*5)[0];
        ((npy_longlong *)data_out + 2*5)[1] =
                                ((npy_longlong *)data0 + 2*5)[1] +
                                ((npy_longlong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longlong *)data_out + 2*6)[0] =
                                ((npy_longlong *)data0 + 2*6)[0] +
                                ((npy_longlong *)data_out + 2*6)[0];
        ((npy_longlong *)data_out + 2*6)[1] =
                                ((npy_longlong *)data0 + 2*6)[1] +
                                ((npy_longlong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longlong *)data_out + 2*7)[0] =
                                ((npy_longlong *)data0 + 2*7)[0] +
                                ((npy_longlong *)data_out + 2*7)[0];
        ((npy_longlong *)data_out + 2*7)[1] =
                                ((npy_longlong *)data0 + 2*7)[1] +
                                ((npy_longlong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
longlong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longlong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longlong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong *data_out = (npy_longlong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong value0 = (*(npy_longlong *)dataptr[0]);
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longlong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong value1 = (*(npy_longlong *)dataptr[1]);
    npy_longlong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longlong *)dataptr[2] = ((*(npy_longlong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
longlong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
    npy_longlong *data1 = (npy_longlong *)dataptr[1];
    npy_longlong *data2 = (npy_longlong *)dataptr[2];
    npy_longlong *data_out = (npy_longlong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
longlong_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        *(npy_longlong *)dataptr[nop] = (temp +
                                           (*(npy_longlong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longlong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longlong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longlong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
longlong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#else
    npy_longlong accum = 0;
    npy_longlong *data0 = (npy_longlong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longlong *)dataptr[1])[0] += accum_re;
            ((npy_longlong *)dataptr[1])[1] += accum_im;
#else
            *((npy_longlong *)dataptr[1]) = (accum +
                                    (*((npy_longlong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
longlong_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longlong accum_re = 0, accum_im = 0;
#else
    npy_longlong accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longlong_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_longlong *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_longlong *)data0) *
                 (*(npy_longlong *)data1) *
                 (*(npy_longlong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longlong temp = (*(npy_longlong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longlong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_longlong *)data0)[0];
        accum_im += ((npy_longlong *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longlong re, im, tmp;
        int i;
        re = ((npy_longlong *)dataptr[0])[0];
        im = ((npy_longlong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longlong *)dataptr[i])[0] -
                  im * ((npy_longlong *)dataptr[i])[1];
            im = re * ((npy_longlong *)dataptr[i])[1] +
                 im * ((npy_longlong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_longlong *)dataptr[1000])[0] += accum_re;
    ((npy_longlong *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_longlong *)dataptr[nop])[0] += accum_re;
    ((npy_longlong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_longlong *)dataptr[1000]) = (accum +
                                    (*((npy_longlong *)dataptr[1000])));
#  else
    *((npy_longlong *)dataptr[nop]) = (accum +
                                    (*((npy_longlong *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
ubyte_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) *
                                         (*(npy_ubyte *)data2) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_ubyte *)data_out)[0] = ((npy_ubyte *)data0)[0] +
                                         ((npy_ubyte *)data_out)[0];
        ((npy_ubyte *)data_out)[1] = ((npy_ubyte *)data0)[1] +
                                         ((npy_ubyte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
ubyte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ubyte *)data_out + 2*6)[0] =
                                    ((npy_ubyte *)data0 + 2*6)[0] +
                                    ((npy_ubyte *)data_out + 2*6)[0];
            ((npy_ubyte *)data_out + 2*6)[1] =
                                    ((npy_ubyte *)data0 + 2*6)[1] +
                                    ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ubyte *)data_out + 2*5)[0] =
                                    ((npy_ubyte *)data0 + 2*5)[0] +
                                    ((npy_ubyte *)data_out + 2*5)[0];
            ((npy_ubyte *)data_out + 2*5)[1] =
                                    ((npy_ubyte *)data0 + 2*5)[1] +
                                    ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ubyte *)data_out + 2*4)[0] =
                                    ((npy_ubyte *)data0 + 2*4)[0] +
                                    ((npy_ubyte *)data_out + 2*4)[0];
            ((npy_ubyte *)data_out + 2*4)[1] =
                                    ((npy_ubyte *)data0 + 2*4)[1] +
                                    ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ubyte *)data_out + 2*3)[0] =
                                    ((npy_ubyte *)data0 + 2*3)[0] +
                                    ((npy_ubyte *)data_out + 2*3)[0];
            ((npy_ubyte *)data_out + 2*3)[1] =
                                    ((npy_ubyte *)data0 + 2*3)[1] +
                                    ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ubyte *)data_out + 2*2)[0] =
                                    ((npy_ubyte *)data0 + 2*2)[0] +
                                    ((npy_ubyte *)data_out + 2*2)[0];
            ((npy_ubyte *)data_out + 2*2)[1] =
                                    ((npy_ubyte *)data0 + 2*2)[1] +
                                    ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ubyte *)data_out + 2*1)[0] =
                                    ((npy_ubyte *)data0 + 2*1)[0] +
                                    ((npy_ubyte *)data_out + 2*1)[0];
            ((npy_ubyte *)data_out + 2*1)[1] =
                                    ((npy_ubyte *)data0 + 2*1)[1] +
                                    ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ubyte *)data_out + 2*0)[0] =
                                    ((npy_ubyte *)data0 + 2*0)[0] +
                                    ((npy_ubyte *)data_out + 2*0)[0];
            ((npy_ubyte *)data_out + 2*0)[1] =
                                    ((npy_ubyte *)data0 + 2*0)[1] +
                                    ((npy_ubyte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*0)[0] =
                                ((npy_ubyte *)data0 + 2*0)[0] +
                                ((npy_ubyte *)data_out + 2*0)[0];
        ((npy_ubyte *)data_out + 2*0)[1] =
                                ((npy_ubyte *)data0 + 2*0)[1] +
                                ((npy_ubyte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*1)[0] =
                                ((npy_ubyte *)data0 + 2*1)[0] +
                                ((npy_ubyte *)data_out + 2*1)[0];
        ((npy_ubyte *)data_out + 2*1)[1] =
                                ((npy_ubyte *)data0 + 2*1)[1] +
                                ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*2)[0] =
                                ((npy_ubyte *)data0 + 2*2)[0] +
                                ((npy_ubyte *)data_out + 2*2)[0];
        ((npy_ubyte *)data_out + 2*2)[1] =
                                ((npy_ubyte *)data0 + 2*2)[1] +
                                ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*3)[0] =
                                ((npy_ubyte *)data0 + 2*3)[0] +
                                ((npy_ubyte *)data_out + 2*3)[0];
        ((npy_ubyte *)data_out + 2*3)[1] =
                                ((npy_ubyte *)data0 + 2*3)[1] +
                                ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*4)[0] =
                                ((npy_ubyte *)data0 + 2*4)[0] +
                                ((npy_ubyte *)data_out + 2*4)[0];
        ((npy_ubyte *)data_out + 2*4)[1] =
                                ((npy_ubyte *)data0 + 2*4)[1] +
                                ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*5)[0] =
                                ((npy_ubyte *)data0 + 2*5)[0] +
                                ((npy_ubyte *)data_out + 2*5)[0];
        ((npy_ubyte *)data_out + 2*5)[1] =
                                ((npy_ubyte *)data0 + 2*5)[1] +
                                ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*6)[0] =
                                ((npy_ubyte *)data0 + 2*6)[0] +
                                ((npy_ubyte *)data_out + 2*6)[0];
        ((npy_ubyte *)data_out + 2*6)[1] =
                                ((npy_ubyte *)data0 + 2*6)[1] +
                                ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*7)[0] =
                                ((npy_ubyte *)data0 + 2*7)[0] +
                                ((npy_ubyte *)data_out + 2*7)[0];
        ((npy_ubyte *)data_out + 2*7)[1] =
                                ((npy_ubyte *)data0 + 2*7)[1] +
                                ((npy_ubyte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
ubyte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ubyte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ubyte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
ubyte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data2 = (npy_ubyte *)dataptr[2];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
ubyte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
ubyte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#else
    npy_ubyte accum = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ubyte *)dataptr[1])[0] += accum_re;
            ((npy_ubyte *)dataptr[1])[1] += accum_im;
#else
            *((npy_ubyte *)dataptr[1]) = (accum +
                                    (*((npy_ubyte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
ubyte_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
#else
    npy_ubyte accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_ubyte *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1) *
                 (*(npy_ubyte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_ubyte *)data0)[0];
        accum_im += ((npy_ubyte *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_ubyte *)dataptr[1])[0] += accum_re;
    ((npy_ubyte *)dataptr[1])[1] += accum_im;
#  else
    ((npy_ubyte *)dataptr[nop])[0] += accum_re;
    ((npy_ubyte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_ubyte *)dataptr[1]) = (accum +
                                    (*((npy_ubyte *)dataptr[1])));
#  else
    *((npy_ubyte *)dataptr[nop]) = (accum +
                                    (*((npy_ubyte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ubyte_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) *
                                         (*(npy_ubyte *)data2) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_ubyte *)data_out)[0] = ((npy_ubyte *)data0)[0] +
                                         ((npy_ubyte *)data_out)[0];
        ((npy_ubyte *)data_out)[1] = ((npy_ubyte *)data0)[1] +
                                         ((npy_ubyte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
ubyte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ubyte *)data_out + 2*6)[0] =
                                    ((npy_ubyte *)data0 + 2*6)[0] +
                                    ((npy_ubyte *)data_out + 2*6)[0];
            ((npy_ubyte *)data_out + 2*6)[1] =
                                    ((npy_ubyte *)data0 + 2*6)[1] +
                                    ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ubyte *)data_out + 2*5)[0] =
                                    ((npy_ubyte *)data0 + 2*5)[0] +
                                    ((npy_ubyte *)data_out + 2*5)[0];
            ((npy_ubyte *)data_out + 2*5)[1] =
                                    ((npy_ubyte *)data0 + 2*5)[1] +
                                    ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ubyte *)data_out + 2*4)[0] =
                                    ((npy_ubyte *)data0 + 2*4)[0] +
                                    ((npy_ubyte *)data_out + 2*4)[0];
            ((npy_ubyte *)data_out + 2*4)[1] =
                                    ((npy_ubyte *)data0 + 2*4)[1] +
                                    ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ubyte *)data_out + 2*3)[0] =
                                    ((npy_ubyte *)data0 + 2*3)[0] +
                                    ((npy_ubyte *)data_out + 2*3)[0];
            ((npy_ubyte *)data_out + 2*3)[1] =
                                    ((npy_ubyte *)data0 + 2*3)[1] +
                                    ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ubyte *)data_out + 2*2)[0] =
                                    ((npy_ubyte *)data0 + 2*2)[0] +
                                    ((npy_ubyte *)data_out + 2*2)[0];
            ((npy_ubyte *)data_out + 2*2)[1] =
                                    ((npy_ubyte *)data0 + 2*2)[1] +
                                    ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ubyte *)data_out + 2*1)[0] =
                                    ((npy_ubyte *)data0 + 2*1)[0] +
                                    ((npy_ubyte *)data_out + 2*1)[0];
            ((npy_ubyte *)data_out + 2*1)[1] =
                                    ((npy_ubyte *)data0 + 2*1)[1] +
                                    ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ubyte *)data_out + 2*0)[0] =
                                    ((npy_ubyte *)data0 + 2*0)[0] +
                                    ((npy_ubyte *)data_out + 2*0)[0];
            ((npy_ubyte *)data_out + 2*0)[1] =
                                    ((npy_ubyte *)data0 + 2*0)[1] +
                                    ((npy_ubyte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*0)[0] =
                                ((npy_ubyte *)data0 + 2*0)[0] +
                                ((npy_ubyte *)data_out + 2*0)[0];
        ((npy_ubyte *)data_out + 2*0)[1] =
                                ((npy_ubyte *)data0 + 2*0)[1] +
                                ((npy_ubyte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*1)[0] =
                                ((npy_ubyte *)data0 + 2*1)[0] +
                                ((npy_ubyte *)data_out + 2*1)[0];
        ((npy_ubyte *)data_out + 2*1)[1] =
                                ((npy_ubyte *)data0 + 2*1)[1] +
                                ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*2)[0] =
                                ((npy_ubyte *)data0 + 2*2)[0] +
                                ((npy_ubyte *)data_out + 2*2)[0];
        ((npy_ubyte *)data_out + 2*2)[1] =
                                ((npy_ubyte *)data0 + 2*2)[1] +
                                ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*3)[0] =
                                ((npy_ubyte *)data0 + 2*3)[0] +
                                ((npy_ubyte *)data_out + 2*3)[0];
        ((npy_ubyte *)data_out + 2*3)[1] =
                                ((npy_ubyte *)data0 + 2*3)[1] +
                                ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*4)[0] =
                                ((npy_ubyte *)data0 + 2*4)[0] +
                                ((npy_ubyte *)data_out + 2*4)[0];
        ((npy_ubyte *)data_out + 2*4)[1] =
                                ((npy_ubyte *)data0 + 2*4)[1] +
                                ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*5)[0] =
                                ((npy_ubyte *)data0 + 2*5)[0] +
                                ((npy_ubyte *)data_out + 2*5)[0];
        ((npy_ubyte *)data_out + 2*5)[1] =
                                ((npy_ubyte *)data0 + 2*5)[1] +
                                ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*6)[0] =
                                ((npy_ubyte *)data0 + 2*6)[0] +
                                ((npy_ubyte *)data_out + 2*6)[0];
        ((npy_ubyte *)data_out + 2*6)[1] =
                                ((npy_ubyte *)data0 + 2*6)[1] +
                                ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*7)[0] =
                                ((npy_ubyte *)data0 + 2*7)[0] +
                                ((npy_ubyte *)data_out + 2*7)[0];
        ((npy_ubyte *)data_out + 2*7)[1] =
                                ((npy_ubyte *)data0 + 2*7)[1] +
                                ((npy_ubyte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
ubyte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ubyte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ubyte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
ubyte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data2 = (npy_ubyte *)dataptr[2];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
ubyte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
ubyte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#else
    npy_ubyte accum = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ubyte *)dataptr[1])[0] += accum_re;
            ((npy_ubyte *)dataptr[1])[1] += accum_im;
#else
            *((npy_ubyte *)dataptr[1]) = (accum +
                                    (*((npy_ubyte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
ubyte_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
#else
    npy_ubyte accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_ubyte *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1) *
                 (*(npy_ubyte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_ubyte *)data0)[0];
        accum_im += ((npy_ubyte *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_ubyte *)dataptr[2])[0] += accum_re;
    ((npy_ubyte *)dataptr[2])[1] += accum_im;
#  else
    ((npy_ubyte *)dataptr[nop])[0] += accum_re;
    ((npy_ubyte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_ubyte *)dataptr[2]) = (accum +
                                    (*((npy_ubyte *)dataptr[2])));
#  else
    *((npy_ubyte *)dataptr[nop]) = (accum +
                                    (*((npy_ubyte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ubyte_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) *
                                         (*(npy_ubyte *)data2) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_ubyte *)data_out)[0] = ((npy_ubyte *)data0)[0] +
                                         ((npy_ubyte *)data_out)[0];
        ((npy_ubyte *)data_out)[1] = ((npy_ubyte *)data0)[1] +
                                         ((npy_ubyte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
ubyte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ubyte *)data_out + 2*6)[0] =
                                    ((npy_ubyte *)data0 + 2*6)[0] +
                                    ((npy_ubyte *)data_out + 2*6)[0];
            ((npy_ubyte *)data_out + 2*6)[1] =
                                    ((npy_ubyte *)data0 + 2*6)[1] +
                                    ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ubyte *)data_out + 2*5)[0] =
                                    ((npy_ubyte *)data0 + 2*5)[0] +
                                    ((npy_ubyte *)data_out + 2*5)[0];
            ((npy_ubyte *)data_out + 2*5)[1] =
                                    ((npy_ubyte *)data0 + 2*5)[1] +
                                    ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ubyte *)data_out + 2*4)[0] =
                                    ((npy_ubyte *)data0 + 2*4)[0] +
                                    ((npy_ubyte *)data_out + 2*4)[0];
            ((npy_ubyte *)data_out + 2*4)[1] =
                                    ((npy_ubyte *)data0 + 2*4)[1] +
                                    ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ubyte *)data_out + 2*3)[0] =
                                    ((npy_ubyte *)data0 + 2*3)[0] +
                                    ((npy_ubyte *)data_out + 2*3)[0];
            ((npy_ubyte *)data_out + 2*3)[1] =
                                    ((npy_ubyte *)data0 + 2*3)[1] +
                                    ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ubyte *)data_out + 2*2)[0] =
                                    ((npy_ubyte *)data0 + 2*2)[0] +
                                    ((npy_ubyte *)data_out + 2*2)[0];
            ((npy_ubyte *)data_out + 2*2)[1] =
                                    ((npy_ubyte *)data0 + 2*2)[1] +
                                    ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ubyte *)data_out + 2*1)[0] =
                                    ((npy_ubyte *)data0 + 2*1)[0] +
                                    ((npy_ubyte *)data_out + 2*1)[0];
            ((npy_ubyte *)data_out + 2*1)[1] =
                                    ((npy_ubyte *)data0 + 2*1)[1] +
                                    ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ubyte *)data_out + 2*0)[0] =
                                    ((npy_ubyte *)data0 + 2*0)[0] +
                                    ((npy_ubyte *)data_out + 2*0)[0];
            ((npy_ubyte *)data_out + 2*0)[1] =
                                    ((npy_ubyte *)data0 + 2*0)[1] +
                                    ((npy_ubyte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*0)[0] =
                                ((npy_ubyte *)data0 + 2*0)[0] +
                                ((npy_ubyte *)data_out + 2*0)[0];
        ((npy_ubyte *)data_out + 2*0)[1] =
                                ((npy_ubyte *)data0 + 2*0)[1] +
                                ((npy_ubyte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*1)[0] =
                                ((npy_ubyte *)data0 + 2*1)[0] +
                                ((npy_ubyte *)data_out + 2*1)[0];
        ((npy_ubyte *)data_out + 2*1)[1] =
                                ((npy_ubyte *)data0 + 2*1)[1] +
                                ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*2)[0] =
                                ((npy_ubyte *)data0 + 2*2)[0] +
                                ((npy_ubyte *)data_out + 2*2)[0];
        ((npy_ubyte *)data_out + 2*2)[1] =
                                ((npy_ubyte *)data0 + 2*2)[1] +
                                ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*3)[0] =
                                ((npy_ubyte *)data0 + 2*3)[0] +
                                ((npy_ubyte *)data_out + 2*3)[0];
        ((npy_ubyte *)data_out + 2*3)[1] =
                                ((npy_ubyte *)data0 + 2*3)[1] +
                                ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*4)[0] =
                                ((npy_ubyte *)data0 + 2*4)[0] +
                                ((npy_ubyte *)data_out + 2*4)[0];
        ((npy_ubyte *)data_out + 2*4)[1] =
                                ((npy_ubyte *)data0 + 2*4)[1] +
                                ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*5)[0] =
                                ((npy_ubyte *)data0 + 2*5)[0] +
                                ((npy_ubyte *)data_out + 2*5)[0];
        ((npy_ubyte *)data_out + 2*5)[1] =
                                ((npy_ubyte *)data0 + 2*5)[1] +
                                ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*6)[0] =
                                ((npy_ubyte *)data0 + 2*6)[0] +
                                ((npy_ubyte *)data_out + 2*6)[0];
        ((npy_ubyte *)data_out + 2*6)[1] =
                                ((npy_ubyte *)data0 + 2*6)[1] +
                                ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*7)[0] =
                                ((npy_ubyte *)data0 + 2*7)[0] +
                                ((npy_ubyte *)data_out + 2*7)[0];
        ((npy_ubyte *)data_out + 2*7)[1] =
                                ((npy_ubyte *)data0 + 2*7)[1] +
                                ((npy_ubyte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
ubyte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ubyte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ubyte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
ubyte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data2 = (npy_ubyte *)dataptr[2];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
ubyte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
ubyte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#else
    npy_ubyte accum = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ubyte *)dataptr[1])[0] += accum_re;
            ((npy_ubyte *)dataptr[1])[1] += accum_im;
#else
            *((npy_ubyte *)dataptr[1]) = (accum +
                                    (*((npy_ubyte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
ubyte_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
#else
    npy_ubyte accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_ubyte *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1) *
                 (*(npy_ubyte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_ubyte *)data0)[0];
        accum_im += ((npy_ubyte *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_ubyte *)dataptr[3])[0] += accum_re;
    ((npy_ubyte *)dataptr[3])[1] += accum_im;
#  else
    ((npy_ubyte *)dataptr[nop])[0] += accum_re;
    ((npy_ubyte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_ubyte *)dataptr[3]) = (accum +
                                    (*((npy_ubyte *)dataptr[3])));
#  else
    *((npy_ubyte *)dataptr[nop]) = (accum +
                                    (*((npy_ubyte *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ubyte_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_ubyte *)data_out = ((*(npy_ubyte *)data0) *
                                         (*(npy_ubyte *)data1) *
                                         (*(npy_ubyte *)data2) +
                                         (*(npy_ubyte *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_ubyte *)data_out)[0] = ((npy_ubyte *)data0)[0] +
                                         ((npy_ubyte *)data_out)[0];
        ((npy_ubyte *)data_out)[1] = ((npy_ubyte *)data0)[1] +
                                         ((npy_ubyte *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
ubyte_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ubyte *)data_out + 2*6)[0] =
                                    ((npy_ubyte *)data0 + 2*6)[0] +
                                    ((npy_ubyte *)data_out + 2*6)[0];
            ((npy_ubyte *)data_out + 2*6)[1] =
                                    ((npy_ubyte *)data0 + 2*6)[1] +
                                    ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ubyte *)data_out + 2*5)[0] =
                                    ((npy_ubyte *)data0 + 2*5)[0] +
                                    ((npy_ubyte *)data_out + 2*5)[0];
            ((npy_ubyte *)data_out + 2*5)[1] =
                                    ((npy_ubyte *)data0 + 2*5)[1] +
                                    ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ubyte *)data_out + 2*4)[0] =
                                    ((npy_ubyte *)data0 + 2*4)[0] +
                                    ((npy_ubyte *)data_out + 2*4)[0];
            ((npy_ubyte *)data_out + 2*4)[1] =
                                    ((npy_ubyte *)data0 + 2*4)[1] +
                                    ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ubyte *)data_out + 2*3)[0] =
                                    ((npy_ubyte *)data0 + 2*3)[0] +
                                    ((npy_ubyte *)data_out + 2*3)[0];
            ((npy_ubyte *)data_out + 2*3)[1] =
                                    ((npy_ubyte *)data0 + 2*3)[1] +
                                    ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ubyte *)data_out + 2*2)[0] =
                                    ((npy_ubyte *)data0 + 2*2)[0] +
                                    ((npy_ubyte *)data_out + 2*2)[0];
            ((npy_ubyte *)data_out + 2*2)[1] =
                                    ((npy_ubyte *)data0 + 2*2)[1] +
                                    ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ubyte *)data_out + 2*1)[0] =
                                    ((npy_ubyte *)data0 + 2*1)[0] +
                                    ((npy_ubyte *)data_out + 2*1)[0];
            ((npy_ubyte *)data_out + 2*1)[1] =
                                    ((npy_ubyte *)data0 + 2*1)[1] +
                                    ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ubyte *)data_out + 2*0)[0] =
                                    ((npy_ubyte *)data0 + 2*0)[0] +
                                    ((npy_ubyte *)data_out + 2*0)[0];
            ((npy_ubyte *)data_out + 2*0)[1] =
                                    ((npy_ubyte *)data0 + 2*0)[1] +
                                    ((npy_ubyte *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*0)[0] =
                                ((npy_ubyte *)data0 + 2*0)[0] +
                                ((npy_ubyte *)data_out + 2*0)[0];
        ((npy_ubyte *)data_out + 2*0)[1] =
                                ((npy_ubyte *)data0 + 2*0)[1] +
                                ((npy_ubyte *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*1)[0] =
                                ((npy_ubyte *)data0 + 2*1)[0] +
                                ((npy_ubyte *)data_out + 2*1)[0];
        ((npy_ubyte *)data_out + 2*1)[1] =
                                ((npy_ubyte *)data0 + 2*1)[1] +
                                ((npy_ubyte *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*2)[0] =
                                ((npy_ubyte *)data0 + 2*2)[0] +
                                ((npy_ubyte *)data_out + 2*2)[0];
        ((npy_ubyte *)data_out + 2*2)[1] =
                                ((npy_ubyte *)data0 + 2*2)[1] +
                                ((npy_ubyte *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*3)[0] =
                                ((npy_ubyte *)data0 + 2*3)[0] +
                                ((npy_ubyte *)data_out + 2*3)[0];
        ((npy_ubyte *)data_out + 2*3)[1] =
                                ((npy_ubyte *)data0 + 2*3)[1] +
                                ((npy_ubyte *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*4)[0] =
                                ((npy_ubyte *)data0 + 2*4)[0] +
                                ((npy_ubyte *)data_out + 2*4)[0];
        ((npy_ubyte *)data_out + 2*4)[1] =
                                ((npy_ubyte *)data0 + 2*4)[1] +
                                ((npy_ubyte *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*5)[0] =
                                ((npy_ubyte *)data0 + 2*5)[0] +
                                ((npy_ubyte *)data_out + 2*5)[0];
        ((npy_ubyte *)data_out + 2*5)[1] =
                                ((npy_ubyte *)data0 + 2*5)[1] +
                                ((npy_ubyte *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*6)[0] =
                                ((npy_ubyte *)data0 + 2*6)[0] +
                                ((npy_ubyte *)data_out + 2*6)[0];
        ((npy_ubyte *)data_out + 2*6)[1] =
                                ((npy_ubyte *)data0 + 2*6)[1] +
                                ((npy_ubyte *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ubyte *)data_out + 2*7)[0] =
                                ((npy_ubyte *)data0 + 2*7)[0] +
                                ((npy_ubyte *)data_out + 2*7)[0];
        ((npy_ubyte *)data_out + 2*7)[1] =
                                ((npy_ubyte *)data0 + 2*7)[1] +
                                ((npy_ubyte *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
ubyte_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ubyte_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ubyte_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte *data_out = (npy_ubyte *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte value0 = (*(npy_ubyte *)dataptr[0]);
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ubyte_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte value1 = (*(npy_ubyte *)dataptr[1]);
    npy_ubyte accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ubyte *)dataptr[2] = ((*(npy_ubyte *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
ubyte_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
    npy_ubyte *data1 = (npy_ubyte *)dataptr[1];
    npy_ubyte *data2 = (npy_ubyte *)dataptr[2];
    npy_ubyte *data_out = (npy_ubyte *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
ubyte_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        *(npy_ubyte *)dataptr[nop] = (temp +
                                           (*(npy_ubyte *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ubyte *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ubyte);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
ubyte_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#else
    npy_ubyte accum = 0;
    npy_ubyte *data0 = (npy_ubyte *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ubyte *)dataptr[1])[0] += accum_re;
            ((npy_ubyte *)dataptr[1])[1] += accum_im;
#else
            *((npy_ubyte *)dataptr[1]) = (accum +
                                    (*((npy_ubyte *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
ubyte_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ubyte accum_re = 0, accum_im = 0;
#else
    npy_ubyte accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ubyte_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_ubyte *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_ubyte *)data0) *
                 (*(npy_ubyte *)data1) *
                 (*(npy_ubyte *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ubyte temp = (*(npy_ubyte *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ubyte *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_ubyte *)data0)[0];
        accum_im += ((npy_ubyte *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ubyte re, im, tmp;
        int i;
        re = ((npy_ubyte *)dataptr[0])[0];
        im = ((npy_ubyte *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ubyte *)dataptr[i])[0] -
                  im * ((npy_ubyte *)dataptr[i])[1];
            im = re * ((npy_ubyte *)dataptr[i])[1] +
                 im * ((npy_ubyte *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_ubyte *)dataptr[1000])[0] += accum_re;
    ((npy_ubyte *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_ubyte *)dataptr[nop])[0] += accum_re;
    ((npy_ubyte *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_ubyte *)dataptr[1000]) = (accum +
                                    (*((npy_ubyte *)dataptr[1000])));
#  else
    *((npy_ubyte *)dataptr[nop]) = (accum +
                                    (*((npy_ubyte *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
ushort_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) *
                                         (*(npy_ushort *)data2) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_ushort *)data_out)[0] = ((npy_ushort *)data0)[0] +
                                         ((npy_ushort *)data_out)[0];
        ((npy_ushort *)data_out)[1] = ((npy_ushort *)data0)[1] +
                                         ((npy_ushort *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
ushort_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data_out = (npy_ushort *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ushort *)data_out + 2*6)[0] =
                                    ((npy_ushort *)data0 + 2*6)[0] +
                                    ((npy_ushort *)data_out + 2*6)[0];
            ((npy_ushort *)data_out + 2*6)[1] =
                                    ((npy_ushort *)data0 + 2*6)[1] +
                                    ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ushort *)data_out + 2*5)[0] =
                                    ((npy_ushort *)data0 + 2*5)[0] +
                                    ((npy_ushort *)data_out + 2*5)[0];
            ((npy_ushort *)data_out + 2*5)[1] =
                                    ((npy_ushort *)data0 + 2*5)[1] +
                                    ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ushort *)data_out + 2*4)[0] =
                                    ((npy_ushort *)data0 + 2*4)[0] +
                                    ((npy_ushort *)data_out + 2*4)[0];
            ((npy_ushort *)data_out + 2*4)[1] =
                                    ((npy_ushort *)data0 + 2*4)[1] +
                                    ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ushort *)data_out + 2*3)[0] =
                                    ((npy_ushort *)data0 + 2*3)[0] +
                                    ((npy_ushort *)data_out + 2*3)[0];
            ((npy_ushort *)data_out + 2*3)[1] =
                                    ((npy_ushort *)data0 + 2*3)[1] +
                                    ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ushort *)data_out + 2*2)[0] =
                                    ((npy_ushort *)data0 + 2*2)[0] +
                                    ((npy_ushort *)data_out + 2*2)[0];
            ((npy_ushort *)data_out + 2*2)[1] =
                                    ((npy_ushort *)data0 + 2*2)[1] +
                                    ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ushort *)data_out + 2*1)[0] =
                                    ((npy_ushort *)data0 + 2*1)[0] +
                                    ((npy_ushort *)data_out + 2*1)[0];
            ((npy_ushort *)data_out + 2*1)[1] =
                                    ((npy_ushort *)data0 + 2*1)[1] +
                                    ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ushort *)data_out + 2*0)[0] =
                                    ((npy_ushort *)data0 + 2*0)[0] +
                                    ((npy_ushort *)data_out + 2*0)[0];
            ((npy_ushort *)data_out + 2*0)[1] =
                                    ((npy_ushort *)data0 + 2*0)[1] +
                                    ((npy_ushort *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ushort *)data_out + 2*0)[0] =
                                ((npy_ushort *)data0 + 2*0)[0] +
                                ((npy_ushort *)data_out + 2*0)[0];
        ((npy_ushort *)data_out + 2*0)[1] =
                                ((npy_ushort *)data0 + 2*0)[1] +
                                ((npy_ushort *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ushort *)data_out + 2*1)[0] =
                                ((npy_ushort *)data0 + 2*1)[0] +
                                ((npy_ushort *)data_out + 2*1)[0];
        ((npy_ushort *)data_out + 2*1)[1] =
                                ((npy_ushort *)data0 + 2*1)[1] +
                                ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ushort *)data_out + 2*2)[0] =
                                ((npy_ushort *)data0 + 2*2)[0] +
                                ((npy_ushort *)data_out + 2*2)[0];
        ((npy_ushort *)data_out + 2*2)[1] =
                                ((npy_ushort *)data0 + 2*2)[1] +
                                ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ushort *)data_out + 2*3)[0] =
                                ((npy_ushort *)data0 + 2*3)[0] +
                                ((npy_ushort *)data_out + 2*3)[0];
        ((npy_ushort *)data_out + 2*3)[1] =
                                ((npy_ushort *)data0 + 2*3)[1] +
                                ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ushort *)data_out + 2*4)[0] =
                                ((npy_ushort *)data0 + 2*4)[0] +
                                ((npy_ushort *)data_out + 2*4)[0];
        ((npy_ushort *)data_out + 2*4)[1] =
                                ((npy_ushort *)data0 + 2*4)[1] +
                                ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ushort *)data_out + 2*5)[0] =
                                ((npy_ushort *)data0 + 2*5)[0] +
                                ((npy_ushort *)data_out + 2*5)[0];
        ((npy_ushort *)data_out + 2*5)[1] =
                                ((npy_ushort *)data0 + 2*5)[1] +
                                ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ushort *)data_out + 2*6)[0] =
                                ((npy_ushort *)data0 + 2*6)[0] +
                                ((npy_ushort *)data_out + 2*6)[0];
        ((npy_ushort *)data_out + 2*6)[1] =
                                ((npy_ushort *)data0 + 2*6)[1] +
                                ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ushort *)data_out + 2*7)[0] =
                                ((npy_ushort *)data0 + 2*7)[0] +
                                ((npy_ushort *)data_out + 2*7)[0];
        ((npy_ushort *)data_out + 2*7)[1] =
                                ((npy_ushort *)data0 + 2*7)[1] +
                                ((npy_ushort *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
ushort_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ushort_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ushort_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
ushort_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data2 = (npy_ushort *)dataptr[2];
    npy_ushort *data_out = (npy_ushort *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
ushort_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
ushort_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#else
    npy_ushort accum = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ushort *)dataptr[1])[0] += accum_re;
            ((npy_ushort *)dataptr[1])[1] += accum_im;
#else
            *((npy_ushort *)dataptr[1]) = (accum +
                                    (*((npy_ushort *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
ushort_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
#else
    npy_ushort accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_ushort *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1) *
                 (*(npy_ushort *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_ushort *)data0)[0];
        accum_im += ((npy_ushort *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_ushort *)dataptr[1])[0] += accum_re;
    ((npy_ushort *)dataptr[1])[1] += accum_im;
#  else
    ((npy_ushort *)dataptr[nop])[0] += accum_re;
    ((npy_ushort *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_ushort *)dataptr[1]) = (accum +
                                    (*((npy_ushort *)dataptr[1])));
#  else
    *((npy_ushort *)dataptr[nop]) = (accum +
                                    (*((npy_ushort *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ushort_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) *
                                         (*(npy_ushort *)data2) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_ushort *)data_out)[0] = ((npy_ushort *)data0)[0] +
                                         ((npy_ushort *)data_out)[0];
        ((npy_ushort *)data_out)[1] = ((npy_ushort *)data0)[1] +
                                         ((npy_ushort *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
ushort_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data_out = (npy_ushort *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ushort *)data_out + 2*6)[0] =
                                    ((npy_ushort *)data0 + 2*6)[0] +
                                    ((npy_ushort *)data_out + 2*6)[0];
            ((npy_ushort *)data_out + 2*6)[1] =
                                    ((npy_ushort *)data0 + 2*6)[1] +
                                    ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ushort *)data_out + 2*5)[0] =
                                    ((npy_ushort *)data0 + 2*5)[0] +
                                    ((npy_ushort *)data_out + 2*5)[0];
            ((npy_ushort *)data_out + 2*5)[1] =
                                    ((npy_ushort *)data0 + 2*5)[1] +
                                    ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ushort *)data_out + 2*4)[0] =
                                    ((npy_ushort *)data0 + 2*4)[0] +
                                    ((npy_ushort *)data_out + 2*4)[0];
            ((npy_ushort *)data_out + 2*4)[1] =
                                    ((npy_ushort *)data0 + 2*4)[1] +
                                    ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ushort *)data_out + 2*3)[0] =
                                    ((npy_ushort *)data0 + 2*3)[0] +
                                    ((npy_ushort *)data_out + 2*3)[0];
            ((npy_ushort *)data_out + 2*3)[1] =
                                    ((npy_ushort *)data0 + 2*3)[1] +
                                    ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ushort *)data_out + 2*2)[0] =
                                    ((npy_ushort *)data0 + 2*2)[0] +
                                    ((npy_ushort *)data_out + 2*2)[0];
            ((npy_ushort *)data_out + 2*2)[1] =
                                    ((npy_ushort *)data0 + 2*2)[1] +
                                    ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ushort *)data_out + 2*1)[0] =
                                    ((npy_ushort *)data0 + 2*1)[0] +
                                    ((npy_ushort *)data_out + 2*1)[0];
            ((npy_ushort *)data_out + 2*1)[1] =
                                    ((npy_ushort *)data0 + 2*1)[1] +
                                    ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ushort *)data_out + 2*0)[0] =
                                    ((npy_ushort *)data0 + 2*0)[0] +
                                    ((npy_ushort *)data_out + 2*0)[0];
            ((npy_ushort *)data_out + 2*0)[1] =
                                    ((npy_ushort *)data0 + 2*0)[1] +
                                    ((npy_ushort *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ushort *)data_out + 2*0)[0] =
                                ((npy_ushort *)data0 + 2*0)[0] +
                                ((npy_ushort *)data_out + 2*0)[0];
        ((npy_ushort *)data_out + 2*0)[1] =
                                ((npy_ushort *)data0 + 2*0)[1] +
                                ((npy_ushort *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ushort *)data_out + 2*1)[0] =
                                ((npy_ushort *)data0 + 2*1)[0] +
                                ((npy_ushort *)data_out + 2*1)[0];
        ((npy_ushort *)data_out + 2*1)[1] =
                                ((npy_ushort *)data0 + 2*1)[1] +
                                ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ushort *)data_out + 2*2)[0] =
                                ((npy_ushort *)data0 + 2*2)[0] +
                                ((npy_ushort *)data_out + 2*2)[0];
        ((npy_ushort *)data_out + 2*2)[1] =
                                ((npy_ushort *)data0 + 2*2)[1] +
                                ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ushort *)data_out + 2*3)[0] =
                                ((npy_ushort *)data0 + 2*3)[0] +
                                ((npy_ushort *)data_out + 2*3)[0];
        ((npy_ushort *)data_out + 2*3)[1] =
                                ((npy_ushort *)data0 + 2*3)[1] +
                                ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ushort *)data_out + 2*4)[0] =
                                ((npy_ushort *)data0 + 2*4)[0] +
                                ((npy_ushort *)data_out + 2*4)[0];
        ((npy_ushort *)data_out + 2*4)[1] =
                                ((npy_ushort *)data0 + 2*4)[1] +
                                ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ushort *)data_out + 2*5)[0] =
                                ((npy_ushort *)data0 + 2*5)[0] +
                                ((npy_ushort *)data_out + 2*5)[0];
        ((npy_ushort *)data_out + 2*5)[1] =
                                ((npy_ushort *)data0 + 2*5)[1] +
                                ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ushort *)data_out + 2*6)[0] =
                                ((npy_ushort *)data0 + 2*6)[0] +
                                ((npy_ushort *)data_out + 2*6)[0];
        ((npy_ushort *)data_out + 2*6)[1] =
                                ((npy_ushort *)data0 + 2*6)[1] +
                                ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ushort *)data_out + 2*7)[0] =
                                ((npy_ushort *)data0 + 2*7)[0] +
                                ((npy_ushort *)data_out + 2*7)[0];
        ((npy_ushort *)data_out + 2*7)[1] =
                                ((npy_ushort *)data0 + 2*7)[1] +
                                ((npy_ushort *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
ushort_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ushort_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ushort_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
ushort_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data2 = (npy_ushort *)dataptr[2];
    npy_ushort *data_out = (npy_ushort *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
ushort_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
ushort_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#else
    npy_ushort accum = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ushort *)dataptr[1])[0] += accum_re;
            ((npy_ushort *)dataptr[1])[1] += accum_im;
#else
            *((npy_ushort *)dataptr[1]) = (accum +
                                    (*((npy_ushort *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
ushort_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
#else
    npy_ushort accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_ushort *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1) *
                 (*(npy_ushort *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_ushort *)data0)[0];
        accum_im += ((npy_ushort *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_ushort *)dataptr[2])[0] += accum_re;
    ((npy_ushort *)dataptr[2])[1] += accum_im;
#  else
    ((npy_ushort *)dataptr[nop])[0] += accum_re;
    ((npy_ushort *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_ushort *)dataptr[2]) = (accum +
                                    (*((npy_ushort *)dataptr[2])));
#  else
    *((npy_ushort *)dataptr[nop]) = (accum +
                                    (*((npy_ushort *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ushort_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) *
                                         (*(npy_ushort *)data2) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_ushort *)data_out)[0] = ((npy_ushort *)data0)[0] +
                                         ((npy_ushort *)data_out)[0];
        ((npy_ushort *)data_out)[1] = ((npy_ushort *)data0)[1] +
                                         ((npy_ushort *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
ushort_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data_out = (npy_ushort *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ushort *)data_out + 2*6)[0] =
                                    ((npy_ushort *)data0 + 2*6)[0] +
                                    ((npy_ushort *)data_out + 2*6)[0];
            ((npy_ushort *)data_out + 2*6)[1] =
                                    ((npy_ushort *)data0 + 2*6)[1] +
                                    ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ushort *)data_out + 2*5)[0] =
                                    ((npy_ushort *)data0 + 2*5)[0] +
                                    ((npy_ushort *)data_out + 2*5)[0];
            ((npy_ushort *)data_out + 2*5)[1] =
                                    ((npy_ushort *)data0 + 2*5)[1] +
                                    ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ushort *)data_out + 2*4)[0] =
                                    ((npy_ushort *)data0 + 2*4)[0] +
                                    ((npy_ushort *)data_out + 2*4)[0];
            ((npy_ushort *)data_out + 2*4)[1] =
                                    ((npy_ushort *)data0 + 2*4)[1] +
                                    ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ushort *)data_out + 2*3)[0] =
                                    ((npy_ushort *)data0 + 2*3)[0] +
                                    ((npy_ushort *)data_out + 2*3)[0];
            ((npy_ushort *)data_out + 2*3)[1] =
                                    ((npy_ushort *)data0 + 2*3)[1] +
                                    ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ushort *)data_out + 2*2)[0] =
                                    ((npy_ushort *)data0 + 2*2)[0] +
                                    ((npy_ushort *)data_out + 2*2)[0];
            ((npy_ushort *)data_out + 2*2)[1] =
                                    ((npy_ushort *)data0 + 2*2)[1] +
                                    ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ushort *)data_out + 2*1)[0] =
                                    ((npy_ushort *)data0 + 2*1)[0] +
                                    ((npy_ushort *)data_out + 2*1)[0];
            ((npy_ushort *)data_out + 2*1)[1] =
                                    ((npy_ushort *)data0 + 2*1)[1] +
                                    ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ushort *)data_out + 2*0)[0] =
                                    ((npy_ushort *)data0 + 2*0)[0] +
                                    ((npy_ushort *)data_out + 2*0)[0];
            ((npy_ushort *)data_out + 2*0)[1] =
                                    ((npy_ushort *)data0 + 2*0)[1] +
                                    ((npy_ushort *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ushort *)data_out + 2*0)[0] =
                                ((npy_ushort *)data0 + 2*0)[0] +
                                ((npy_ushort *)data_out + 2*0)[0];
        ((npy_ushort *)data_out + 2*0)[1] =
                                ((npy_ushort *)data0 + 2*0)[1] +
                                ((npy_ushort *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ushort *)data_out + 2*1)[0] =
                                ((npy_ushort *)data0 + 2*1)[0] +
                                ((npy_ushort *)data_out + 2*1)[0];
        ((npy_ushort *)data_out + 2*1)[1] =
                                ((npy_ushort *)data0 + 2*1)[1] +
                                ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ushort *)data_out + 2*2)[0] =
                                ((npy_ushort *)data0 + 2*2)[0] +
                                ((npy_ushort *)data_out + 2*2)[0];
        ((npy_ushort *)data_out + 2*2)[1] =
                                ((npy_ushort *)data0 + 2*2)[1] +
                                ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ushort *)data_out + 2*3)[0] =
                                ((npy_ushort *)data0 + 2*3)[0] +
                                ((npy_ushort *)data_out + 2*3)[0];
        ((npy_ushort *)data_out + 2*3)[1] =
                                ((npy_ushort *)data0 + 2*3)[1] +
                                ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ushort *)data_out + 2*4)[0] =
                                ((npy_ushort *)data0 + 2*4)[0] +
                                ((npy_ushort *)data_out + 2*4)[0];
        ((npy_ushort *)data_out + 2*4)[1] =
                                ((npy_ushort *)data0 + 2*4)[1] +
                                ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ushort *)data_out + 2*5)[0] =
                                ((npy_ushort *)data0 + 2*5)[0] +
                                ((npy_ushort *)data_out + 2*5)[0];
        ((npy_ushort *)data_out + 2*5)[1] =
                                ((npy_ushort *)data0 + 2*5)[1] +
                                ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ushort *)data_out + 2*6)[0] =
                                ((npy_ushort *)data0 + 2*6)[0] +
                                ((npy_ushort *)data_out + 2*6)[0];
        ((npy_ushort *)data_out + 2*6)[1] =
                                ((npy_ushort *)data0 + 2*6)[1] +
                                ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ushort *)data_out + 2*7)[0] =
                                ((npy_ushort *)data0 + 2*7)[0] +
                                ((npy_ushort *)data_out + 2*7)[0];
        ((npy_ushort *)data_out + 2*7)[1] =
                                ((npy_ushort *)data0 + 2*7)[1] +
                                ((npy_ushort *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
ushort_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ushort_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ushort_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
ushort_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data2 = (npy_ushort *)dataptr[2];
    npy_ushort *data_out = (npy_ushort *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
ushort_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
ushort_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#else
    npy_ushort accum = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ushort *)dataptr[1])[0] += accum_re;
            ((npy_ushort *)dataptr[1])[1] += accum_im;
#else
            *((npy_ushort *)dataptr[1]) = (accum +
                                    (*((npy_ushort *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
ushort_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
#else
    npy_ushort accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_ushort *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1) *
                 (*(npy_ushort *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_ushort *)data0)[0];
        accum_im += ((npy_ushort *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_ushort *)dataptr[3])[0] += accum_re;
    ((npy_ushort *)dataptr[3])[1] += accum_im;
#  else
    ((npy_ushort *)dataptr[nop])[0] += accum_re;
    ((npy_ushort *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_ushort *)dataptr[3]) = (accum +
                                    (*((npy_ushort *)dataptr[3])));
#  else
    *((npy_ushort *)dataptr[nop]) = (accum +
                                    (*((npy_ushort *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ushort_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_ushort *)data_out = ((*(npy_ushort *)data0) *
                                         (*(npy_ushort *)data1) *
                                         (*(npy_ushort *)data2) +
                                         (*(npy_ushort *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_ushort *)data_out)[0] = ((npy_ushort *)data0)[0] +
                                         ((npy_ushort *)data_out)[0];
        ((npy_ushort *)data_out)[1] = ((npy_ushort *)data0)[1] +
                                         ((npy_ushort *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
ushort_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data_out = (npy_ushort *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ushort *)data_out + 2*6)[0] =
                                    ((npy_ushort *)data0 + 2*6)[0] +
                                    ((npy_ushort *)data_out + 2*6)[0];
            ((npy_ushort *)data_out + 2*6)[1] =
                                    ((npy_ushort *)data0 + 2*6)[1] +
                                    ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ushort *)data_out + 2*5)[0] =
                                    ((npy_ushort *)data0 + 2*5)[0] +
                                    ((npy_ushort *)data_out + 2*5)[0];
            ((npy_ushort *)data_out + 2*5)[1] =
                                    ((npy_ushort *)data0 + 2*5)[1] +
                                    ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ushort *)data_out + 2*4)[0] =
                                    ((npy_ushort *)data0 + 2*4)[0] +
                                    ((npy_ushort *)data_out + 2*4)[0];
            ((npy_ushort *)data_out + 2*4)[1] =
                                    ((npy_ushort *)data0 + 2*4)[1] +
                                    ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ushort *)data_out + 2*3)[0] =
                                    ((npy_ushort *)data0 + 2*3)[0] +
                                    ((npy_ushort *)data_out + 2*3)[0];
            ((npy_ushort *)data_out + 2*3)[1] =
                                    ((npy_ushort *)data0 + 2*3)[1] +
                                    ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ushort *)data_out + 2*2)[0] =
                                    ((npy_ushort *)data0 + 2*2)[0] +
                                    ((npy_ushort *)data_out + 2*2)[0];
            ((npy_ushort *)data_out + 2*2)[1] =
                                    ((npy_ushort *)data0 + 2*2)[1] +
                                    ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ushort *)data_out + 2*1)[0] =
                                    ((npy_ushort *)data0 + 2*1)[0] +
                                    ((npy_ushort *)data_out + 2*1)[0];
            ((npy_ushort *)data_out + 2*1)[1] =
                                    ((npy_ushort *)data0 + 2*1)[1] +
                                    ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ushort *)data_out + 2*0)[0] =
                                    ((npy_ushort *)data0 + 2*0)[0] +
                                    ((npy_ushort *)data_out + 2*0)[0];
            ((npy_ushort *)data_out + 2*0)[1] =
                                    ((npy_ushort *)data0 + 2*0)[1] +
                                    ((npy_ushort *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ushort *)data_out + 2*0)[0] =
                                ((npy_ushort *)data0 + 2*0)[0] +
                                ((npy_ushort *)data_out + 2*0)[0];
        ((npy_ushort *)data_out + 2*0)[1] =
                                ((npy_ushort *)data0 + 2*0)[1] +
                                ((npy_ushort *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ushort *)data_out + 2*1)[0] =
                                ((npy_ushort *)data0 + 2*1)[0] +
                                ((npy_ushort *)data_out + 2*1)[0];
        ((npy_ushort *)data_out + 2*1)[1] =
                                ((npy_ushort *)data0 + 2*1)[1] +
                                ((npy_ushort *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ushort *)data_out + 2*2)[0] =
                                ((npy_ushort *)data0 + 2*2)[0] +
                                ((npy_ushort *)data_out + 2*2)[0];
        ((npy_ushort *)data_out + 2*2)[1] =
                                ((npy_ushort *)data0 + 2*2)[1] +
                                ((npy_ushort *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ushort *)data_out + 2*3)[0] =
                                ((npy_ushort *)data0 + 2*3)[0] +
                                ((npy_ushort *)data_out + 2*3)[0];
        ((npy_ushort *)data_out + 2*3)[1] =
                                ((npy_ushort *)data0 + 2*3)[1] +
                                ((npy_ushort *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ushort *)data_out + 2*4)[0] =
                                ((npy_ushort *)data0 + 2*4)[0] +
                                ((npy_ushort *)data_out + 2*4)[0];
        ((npy_ushort *)data_out + 2*4)[1] =
                                ((npy_ushort *)data0 + 2*4)[1] +
                                ((npy_ushort *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ushort *)data_out + 2*5)[0] =
                                ((npy_ushort *)data0 + 2*5)[0] +
                                ((npy_ushort *)data_out + 2*5)[0];
        ((npy_ushort *)data_out + 2*5)[1] =
                                ((npy_ushort *)data0 + 2*5)[1] +
                                ((npy_ushort *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ushort *)data_out + 2*6)[0] =
                                ((npy_ushort *)data0 + 2*6)[0] +
                                ((npy_ushort *)data_out + 2*6)[0];
        ((npy_ushort *)data_out + 2*6)[1] =
                                ((npy_ushort *)data0 + 2*6)[1] +
                                ((npy_ushort *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ushort *)data_out + 2*7)[0] =
                                ((npy_ushort *)data0 + 2*7)[0] +
                                ((npy_ushort *)data_out + 2*7)[0];
        ((npy_ushort *)data_out + 2*7)[1] =
                                ((npy_ushort *)data0 + 2*7)[1] +
                                ((npy_ushort *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
ushort_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ushort_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ushort_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort *data_out = (npy_ushort *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort value0 = (*(npy_ushort *)dataptr[0]);
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ushort_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort value1 = (*(npy_ushort *)dataptr[1]);
    npy_ushort accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ushort *)dataptr[2] = ((*(npy_ushort *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
ushort_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
    npy_ushort *data1 = (npy_ushort *)dataptr[1];
    npy_ushort *data2 = (npy_ushort *)dataptr[2];
    npy_ushort *data_out = (npy_ushort *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
ushort_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        *(npy_ushort *)dataptr[nop] = (temp +
                                           (*(npy_ushort *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ushort *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ushort *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ushort);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
ushort_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#else
    npy_ushort accum = 0;
    npy_ushort *data0 = (npy_ushort *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ushort *)dataptr[1])[0] += accum_re;
            ((npy_ushort *)dataptr[1])[1] += accum_im;
#else
            *((npy_ushort *)dataptr[1]) = (accum +
                                    (*((npy_ushort *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
ushort_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ushort accum_re = 0, accum_im = 0;
#else
    npy_ushort accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ushort_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_ushort *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_ushort *)data0) *
                 (*(npy_ushort *)data1) *
                 (*(npy_ushort *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ushort temp = (*(npy_ushort *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ushort *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_ushort *)data0)[0];
        accum_im += ((npy_ushort *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ushort re, im, tmp;
        int i;
        re = ((npy_ushort *)dataptr[0])[0];
        im = ((npy_ushort *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ushort *)dataptr[i])[0] -
                  im * ((npy_ushort *)dataptr[i])[1];
            im = re * ((npy_ushort *)dataptr[i])[1] +
                 im * ((npy_ushort *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_ushort *)dataptr[1000])[0] += accum_re;
    ((npy_ushort *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_ushort *)dataptr[nop])[0] += accum_re;
    ((npy_ushort *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_ushort *)dataptr[1000]) = (accum +
                                    (*((npy_ushort *)dataptr[1000])));
#  else
    *((npy_ushort *)dataptr[nop]) = (accum +
                                    (*((npy_ushort *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
uint_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_uint *)data_out = ((*(npy_uint *)data0) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) *
                                         (*(npy_uint *)data2) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_uint *)data_out)[0] = ((npy_uint *)data0)[0] +
                                         ((npy_uint *)data_out)[0];
        ((npy_uint *)data_out)[1] = ((npy_uint *)data0)[1] +
                                         ((npy_uint *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
uint_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data_out = (npy_uint *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_uint *)data_out + 2*6)[0] =
                                    ((npy_uint *)data0 + 2*6)[0] +
                                    ((npy_uint *)data_out + 2*6)[0];
            ((npy_uint *)data_out + 2*6)[1] =
                                    ((npy_uint *)data0 + 2*6)[1] +
                                    ((npy_uint *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_uint *)data_out + 2*5)[0] =
                                    ((npy_uint *)data0 + 2*5)[0] +
                                    ((npy_uint *)data_out + 2*5)[0];
            ((npy_uint *)data_out + 2*5)[1] =
                                    ((npy_uint *)data0 + 2*5)[1] +
                                    ((npy_uint *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_uint *)data_out + 2*4)[0] =
                                    ((npy_uint *)data0 + 2*4)[0] +
                                    ((npy_uint *)data_out + 2*4)[0];
            ((npy_uint *)data_out + 2*4)[1] =
                                    ((npy_uint *)data0 + 2*4)[1] +
                                    ((npy_uint *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_uint *)data_out + 2*3)[0] =
                                    ((npy_uint *)data0 + 2*3)[0] +
                                    ((npy_uint *)data_out + 2*3)[0];
            ((npy_uint *)data_out + 2*3)[1] =
                                    ((npy_uint *)data0 + 2*3)[1] +
                                    ((npy_uint *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_uint *)data_out + 2*2)[0] =
                                    ((npy_uint *)data0 + 2*2)[0] +
                                    ((npy_uint *)data_out + 2*2)[0];
            ((npy_uint *)data_out + 2*2)[1] =
                                    ((npy_uint *)data0 + 2*2)[1] +
                                    ((npy_uint *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_uint *)data_out + 2*1)[0] =
                                    ((npy_uint *)data0 + 2*1)[0] +
                                    ((npy_uint *)data_out + 2*1)[0];
            ((npy_uint *)data_out + 2*1)[1] =
                                    ((npy_uint *)data0 + 2*1)[1] +
                                    ((npy_uint *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_uint *)data_out + 2*0)[0] =
                                    ((npy_uint *)data0 + 2*0)[0] +
                                    ((npy_uint *)data_out + 2*0)[0];
            ((npy_uint *)data_out + 2*0)[1] =
                                    ((npy_uint *)data0 + 2*0)[1] +
                                    ((npy_uint *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_uint *)data_out + 2*0)[0] =
                                ((npy_uint *)data0 + 2*0)[0] +
                                ((npy_uint *)data_out + 2*0)[0];
        ((npy_uint *)data_out + 2*0)[1] =
                                ((npy_uint *)data0 + 2*0)[1] +
                                ((npy_uint *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_uint *)data_out + 2*1)[0] =
                                ((npy_uint *)data0 + 2*1)[0] +
                                ((npy_uint *)data_out + 2*1)[0];
        ((npy_uint *)data_out + 2*1)[1] =
                                ((npy_uint *)data0 + 2*1)[1] +
                                ((npy_uint *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_uint *)data_out + 2*2)[0] =
                                ((npy_uint *)data0 + 2*2)[0] +
                                ((npy_uint *)data_out + 2*2)[0];
        ((npy_uint *)data_out + 2*2)[1] =
                                ((npy_uint *)data0 + 2*2)[1] +
                                ((npy_uint *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_uint *)data_out + 2*3)[0] =
                                ((npy_uint *)data0 + 2*3)[0] +
                                ((npy_uint *)data_out + 2*3)[0];
        ((npy_uint *)data_out + 2*3)[1] =
                                ((npy_uint *)data0 + 2*3)[1] +
                                ((npy_uint *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_uint *)data_out + 2*4)[0] =
                                ((npy_uint *)data0 + 2*4)[0] +
                                ((npy_uint *)data_out + 2*4)[0];
        ((npy_uint *)data_out + 2*4)[1] =
                                ((npy_uint *)data0 + 2*4)[1] +
                                ((npy_uint *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_uint *)data_out + 2*5)[0] =
                                ((npy_uint *)data0 + 2*5)[0] +
                                ((npy_uint *)data_out + 2*5)[0];
        ((npy_uint *)data_out + 2*5)[1] =
                                ((npy_uint *)data0 + 2*5)[1] +
                                ((npy_uint *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_uint *)data_out + 2*6)[0] =
                                ((npy_uint *)data0 + 2*6)[0] +
                                ((npy_uint *)data_out + 2*6)[0];
        ((npy_uint *)data_out + 2*6)[1] =
                                ((npy_uint *)data0 + 2*6)[1] +
                                ((npy_uint *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_uint *)data_out + 2*7)[0] =
                                ((npy_uint *)data0 + 2*7)[0] +
                                ((npy_uint *)data_out + 2*7)[0];
        ((npy_uint *)data_out + 2*7)[1] =
                                ((npy_uint *)data0 + 2*7)[1] +
                                ((npy_uint *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
uint_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
uint_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
uint_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
uint_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data2 = (npy_uint *)dataptr[2];
    npy_uint *data_out = (npy_uint *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
uint_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
uint_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#else
    npy_uint accum = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_uint *)dataptr[1])[0] += accum_re;
            ((npy_uint *)dataptr[1])[1] += accum_im;
#else
            *((npy_uint *)dataptr[1]) = (accum +
                                    (*((npy_uint *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
uint_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
#else
    npy_uint accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_uint *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1) *
                 (*(npy_uint *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_uint *)data0)[0];
        accum_im += ((npy_uint *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_uint *)dataptr[1])[0] += accum_re;
    ((npy_uint *)dataptr[1])[1] += accum_im;
#  else
    ((npy_uint *)dataptr[nop])[0] += accum_re;
    ((npy_uint *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_uint *)dataptr[1]) = (accum +
                                    (*((npy_uint *)dataptr[1])));
#  else
    *((npy_uint *)dataptr[nop]) = (accum +
                                    (*((npy_uint *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
uint_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_uint *)data_out = ((*(npy_uint *)data0) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) *
                                         (*(npy_uint *)data2) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_uint *)data_out)[0] = ((npy_uint *)data0)[0] +
                                         ((npy_uint *)data_out)[0];
        ((npy_uint *)data_out)[1] = ((npy_uint *)data0)[1] +
                                         ((npy_uint *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
uint_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data_out = (npy_uint *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_uint *)data_out + 2*6)[0] =
                                    ((npy_uint *)data0 + 2*6)[0] +
                                    ((npy_uint *)data_out + 2*6)[0];
            ((npy_uint *)data_out + 2*6)[1] =
                                    ((npy_uint *)data0 + 2*6)[1] +
                                    ((npy_uint *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_uint *)data_out + 2*5)[0] =
                                    ((npy_uint *)data0 + 2*5)[0] +
                                    ((npy_uint *)data_out + 2*5)[0];
            ((npy_uint *)data_out + 2*5)[1] =
                                    ((npy_uint *)data0 + 2*5)[1] +
                                    ((npy_uint *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_uint *)data_out + 2*4)[0] =
                                    ((npy_uint *)data0 + 2*4)[0] +
                                    ((npy_uint *)data_out + 2*4)[0];
            ((npy_uint *)data_out + 2*4)[1] =
                                    ((npy_uint *)data0 + 2*4)[1] +
                                    ((npy_uint *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_uint *)data_out + 2*3)[0] =
                                    ((npy_uint *)data0 + 2*3)[0] +
                                    ((npy_uint *)data_out + 2*3)[0];
            ((npy_uint *)data_out + 2*3)[1] =
                                    ((npy_uint *)data0 + 2*3)[1] +
                                    ((npy_uint *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_uint *)data_out + 2*2)[0] =
                                    ((npy_uint *)data0 + 2*2)[0] +
                                    ((npy_uint *)data_out + 2*2)[0];
            ((npy_uint *)data_out + 2*2)[1] =
                                    ((npy_uint *)data0 + 2*2)[1] +
                                    ((npy_uint *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_uint *)data_out + 2*1)[0] =
                                    ((npy_uint *)data0 + 2*1)[0] +
                                    ((npy_uint *)data_out + 2*1)[0];
            ((npy_uint *)data_out + 2*1)[1] =
                                    ((npy_uint *)data0 + 2*1)[1] +
                                    ((npy_uint *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_uint *)data_out + 2*0)[0] =
                                    ((npy_uint *)data0 + 2*0)[0] +
                                    ((npy_uint *)data_out + 2*0)[0];
            ((npy_uint *)data_out + 2*0)[1] =
                                    ((npy_uint *)data0 + 2*0)[1] +
                                    ((npy_uint *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_uint *)data_out + 2*0)[0] =
                                ((npy_uint *)data0 + 2*0)[0] +
                                ((npy_uint *)data_out + 2*0)[0];
        ((npy_uint *)data_out + 2*0)[1] =
                                ((npy_uint *)data0 + 2*0)[1] +
                                ((npy_uint *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_uint *)data_out + 2*1)[0] =
                                ((npy_uint *)data0 + 2*1)[0] +
                                ((npy_uint *)data_out + 2*1)[0];
        ((npy_uint *)data_out + 2*1)[1] =
                                ((npy_uint *)data0 + 2*1)[1] +
                                ((npy_uint *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_uint *)data_out + 2*2)[0] =
                                ((npy_uint *)data0 + 2*2)[0] +
                                ((npy_uint *)data_out + 2*2)[0];
        ((npy_uint *)data_out + 2*2)[1] =
                                ((npy_uint *)data0 + 2*2)[1] +
                                ((npy_uint *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_uint *)data_out + 2*3)[0] =
                                ((npy_uint *)data0 + 2*3)[0] +
                                ((npy_uint *)data_out + 2*3)[0];
        ((npy_uint *)data_out + 2*3)[1] =
                                ((npy_uint *)data0 + 2*3)[1] +
                                ((npy_uint *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_uint *)data_out + 2*4)[0] =
                                ((npy_uint *)data0 + 2*4)[0] +
                                ((npy_uint *)data_out + 2*4)[0];
        ((npy_uint *)data_out + 2*4)[1] =
                                ((npy_uint *)data0 + 2*4)[1] +
                                ((npy_uint *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_uint *)data_out + 2*5)[0] =
                                ((npy_uint *)data0 + 2*5)[0] +
                                ((npy_uint *)data_out + 2*5)[0];
        ((npy_uint *)data_out + 2*5)[1] =
                                ((npy_uint *)data0 + 2*5)[1] +
                                ((npy_uint *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_uint *)data_out + 2*6)[0] =
                                ((npy_uint *)data0 + 2*6)[0] +
                                ((npy_uint *)data_out + 2*6)[0];
        ((npy_uint *)data_out + 2*6)[1] =
                                ((npy_uint *)data0 + 2*6)[1] +
                                ((npy_uint *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_uint *)data_out + 2*7)[0] =
                                ((npy_uint *)data0 + 2*7)[0] +
                                ((npy_uint *)data_out + 2*7)[0];
        ((npy_uint *)data_out + 2*7)[1] =
                                ((npy_uint *)data0 + 2*7)[1] +
                                ((npy_uint *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
uint_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
uint_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
uint_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
uint_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data2 = (npy_uint *)dataptr[2];
    npy_uint *data_out = (npy_uint *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
uint_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
uint_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#else
    npy_uint accum = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_uint *)dataptr[1])[0] += accum_re;
            ((npy_uint *)dataptr[1])[1] += accum_im;
#else
            *((npy_uint *)dataptr[1]) = (accum +
                                    (*((npy_uint *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
uint_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
#else
    npy_uint accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_uint *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1) *
                 (*(npy_uint *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_uint *)data0)[0];
        accum_im += ((npy_uint *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_uint *)dataptr[2])[0] += accum_re;
    ((npy_uint *)dataptr[2])[1] += accum_im;
#  else
    ((npy_uint *)dataptr[nop])[0] += accum_re;
    ((npy_uint *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_uint *)dataptr[2]) = (accum +
                                    (*((npy_uint *)dataptr[2])));
#  else
    *((npy_uint *)dataptr[nop]) = (accum +
                                    (*((npy_uint *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
uint_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_uint *)data_out = ((*(npy_uint *)data0) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) *
                                         (*(npy_uint *)data2) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_uint *)data_out)[0] = ((npy_uint *)data0)[0] +
                                         ((npy_uint *)data_out)[0];
        ((npy_uint *)data_out)[1] = ((npy_uint *)data0)[1] +
                                         ((npy_uint *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
uint_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data_out = (npy_uint *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_uint *)data_out + 2*6)[0] =
                                    ((npy_uint *)data0 + 2*6)[0] +
                                    ((npy_uint *)data_out + 2*6)[0];
            ((npy_uint *)data_out + 2*6)[1] =
                                    ((npy_uint *)data0 + 2*6)[1] +
                                    ((npy_uint *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_uint *)data_out + 2*5)[0] =
                                    ((npy_uint *)data0 + 2*5)[0] +
                                    ((npy_uint *)data_out + 2*5)[0];
            ((npy_uint *)data_out + 2*5)[1] =
                                    ((npy_uint *)data0 + 2*5)[1] +
                                    ((npy_uint *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_uint *)data_out + 2*4)[0] =
                                    ((npy_uint *)data0 + 2*4)[0] +
                                    ((npy_uint *)data_out + 2*4)[0];
            ((npy_uint *)data_out + 2*4)[1] =
                                    ((npy_uint *)data0 + 2*4)[1] +
                                    ((npy_uint *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_uint *)data_out + 2*3)[0] =
                                    ((npy_uint *)data0 + 2*3)[0] +
                                    ((npy_uint *)data_out + 2*3)[0];
            ((npy_uint *)data_out + 2*3)[1] =
                                    ((npy_uint *)data0 + 2*3)[1] +
                                    ((npy_uint *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_uint *)data_out + 2*2)[0] =
                                    ((npy_uint *)data0 + 2*2)[0] +
                                    ((npy_uint *)data_out + 2*2)[0];
            ((npy_uint *)data_out + 2*2)[1] =
                                    ((npy_uint *)data0 + 2*2)[1] +
                                    ((npy_uint *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_uint *)data_out + 2*1)[0] =
                                    ((npy_uint *)data0 + 2*1)[0] +
                                    ((npy_uint *)data_out + 2*1)[0];
            ((npy_uint *)data_out + 2*1)[1] =
                                    ((npy_uint *)data0 + 2*1)[1] +
                                    ((npy_uint *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_uint *)data_out + 2*0)[0] =
                                    ((npy_uint *)data0 + 2*0)[0] +
                                    ((npy_uint *)data_out + 2*0)[0];
            ((npy_uint *)data_out + 2*0)[1] =
                                    ((npy_uint *)data0 + 2*0)[1] +
                                    ((npy_uint *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_uint *)data_out + 2*0)[0] =
                                ((npy_uint *)data0 + 2*0)[0] +
                                ((npy_uint *)data_out + 2*0)[0];
        ((npy_uint *)data_out + 2*0)[1] =
                                ((npy_uint *)data0 + 2*0)[1] +
                                ((npy_uint *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_uint *)data_out + 2*1)[0] =
                                ((npy_uint *)data0 + 2*1)[0] +
                                ((npy_uint *)data_out + 2*1)[0];
        ((npy_uint *)data_out + 2*1)[1] =
                                ((npy_uint *)data0 + 2*1)[1] +
                                ((npy_uint *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_uint *)data_out + 2*2)[0] =
                                ((npy_uint *)data0 + 2*2)[0] +
                                ((npy_uint *)data_out + 2*2)[0];
        ((npy_uint *)data_out + 2*2)[1] =
                                ((npy_uint *)data0 + 2*2)[1] +
                                ((npy_uint *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_uint *)data_out + 2*3)[0] =
                                ((npy_uint *)data0 + 2*3)[0] +
                                ((npy_uint *)data_out + 2*3)[0];
        ((npy_uint *)data_out + 2*3)[1] =
                                ((npy_uint *)data0 + 2*3)[1] +
                                ((npy_uint *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_uint *)data_out + 2*4)[0] =
                                ((npy_uint *)data0 + 2*4)[0] +
                                ((npy_uint *)data_out + 2*4)[0];
        ((npy_uint *)data_out + 2*4)[1] =
                                ((npy_uint *)data0 + 2*4)[1] +
                                ((npy_uint *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_uint *)data_out + 2*5)[0] =
                                ((npy_uint *)data0 + 2*5)[0] +
                                ((npy_uint *)data_out + 2*5)[0];
        ((npy_uint *)data_out + 2*5)[1] =
                                ((npy_uint *)data0 + 2*5)[1] +
                                ((npy_uint *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_uint *)data_out + 2*6)[0] =
                                ((npy_uint *)data0 + 2*6)[0] +
                                ((npy_uint *)data_out + 2*6)[0];
        ((npy_uint *)data_out + 2*6)[1] =
                                ((npy_uint *)data0 + 2*6)[1] +
                                ((npy_uint *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_uint *)data_out + 2*7)[0] =
                                ((npy_uint *)data0 + 2*7)[0] +
                                ((npy_uint *)data_out + 2*7)[0];
        ((npy_uint *)data_out + 2*7)[1] =
                                ((npy_uint *)data0 + 2*7)[1] +
                                ((npy_uint *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
uint_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
uint_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
uint_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
uint_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data2 = (npy_uint *)dataptr[2];
    npy_uint *data_out = (npy_uint *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
uint_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
uint_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#else
    npy_uint accum = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_uint *)dataptr[1])[0] += accum_re;
            ((npy_uint *)dataptr[1])[1] += accum_im;
#else
            *((npy_uint *)dataptr[1]) = (accum +
                                    (*((npy_uint *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
uint_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
#else
    npy_uint accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_uint *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1) *
                 (*(npy_uint *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_uint *)data0)[0];
        accum_im += ((npy_uint *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_uint *)dataptr[3])[0] += accum_re;
    ((npy_uint *)dataptr[3])[1] += accum_im;
#  else
    ((npy_uint *)dataptr[nop])[0] += accum_re;
    ((npy_uint *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_uint *)dataptr[3]) = (accum +
                                    (*((npy_uint *)dataptr[3])));
#  else
    *((npy_uint *)dataptr[nop]) = (accum +
                                    (*((npy_uint *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
uint_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_uint *)data_out = ((*(npy_uint *)data0) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_uint *)data_out = ((*(npy_uint *)data0) *
                                         (*(npy_uint *)data1) *
                                         (*(npy_uint *)data2) +
                                         (*(npy_uint *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_uint *)data_out)[0] = ((npy_uint *)data0)[0] +
                                         ((npy_uint *)data_out)[0];
        ((npy_uint *)data_out)[1] = ((npy_uint *)data0)[1] +
                                         ((npy_uint *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
uint_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data_out = (npy_uint *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_uint *)data_out + 2*6)[0] =
                                    ((npy_uint *)data0 + 2*6)[0] +
                                    ((npy_uint *)data_out + 2*6)[0];
            ((npy_uint *)data_out + 2*6)[1] =
                                    ((npy_uint *)data0 + 2*6)[1] +
                                    ((npy_uint *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_uint *)data_out + 2*5)[0] =
                                    ((npy_uint *)data0 + 2*5)[0] +
                                    ((npy_uint *)data_out + 2*5)[0];
            ((npy_uint *)data_out + 2*5)[1] =
                                    ((npy_uint *)data0 + 2*5)[1] +
                                    ((npy_uint *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_uint *)data_out + 2*4)[0] =
                                    ((npy_uint *)data0 + 2*4)[0] +
                                    ((npy_uint *)data_out + 2*4)[0];
            ((npy_uint *)data_out + 2*4)[1] =
                                    ((npy_uint *)data0 + 2*4)[1] +
                                    ((npy_uint *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_uint *)data_out + 2*3)[0] =
                                    ((npy_uint *)data0 + 2*3)[0] +
                                    ((npy_uint *)data_out + 2*3)[0];
            ((npy_uint *)data_out + 2*3)[1] =
                                    ((npy_uint *)data0 + 2*3)[1] +
                                    ((npy_uint *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_uint *)data_out + 2*2)[0] =
                                    ((npy_uint *)data0 + 2*2)[0] +
                                    ((npy_uint *)data_out + 2*2)[0];
            ((npy_uint *)data_out + 2*2)[1] =
                                    ((npy_uint *)data0 + 2*2)[1] +
                                    ((npy_uint *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_uint *)data_out + 2*1)[0] =
                                    ((npy_uint *)data0 + 2*1)[0] +
                                    ((npy_uint *)data_out + 2*1)[0];
            ((npy_uint *)data_out + 2*1)[1] =
                                    ((npy_uint *)data0 + 2*1)[1] +
                                    ((npy_uint *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_uint *)data_out + 2*0)[0] =
                                    ((npy_uint *)data0 + 2*0)[0] +
                                    ((npy_uint *)data_out + 2*0)[0];
            ((npy_uint *)data_out + 2*0)[1] =
                                    ((npy_uint *)data0 + 2*0)[1] +
                                    ((npy_uint *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_uint *)data_out + 2*0)[0] =
                                ((npy_uint *)data0 + 2*0)[0] +
                                ((npy_uint *)data_out + 2*0)[0];
        ((npy_uint *)data_out + 2*0)[1] =
                                ((npy_uint *)data0 + 2*0)[1] +
                                ((npy_uint *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_uint *)data_out + 2*1)[0] =
                                ((npy_uint *)data0 + 2*1)[0] +
                                ((npy_uint *)data_out + 2*1)[0];
        ((npy_uint *)data_out + 2*1)[1] =
                                ((npy_uint *)data0 + 2*1)[1] +
                                ((npy_uint *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_uint *)data_out + 2*2)[0] =
                                ((npy_uint *)data0 + 2*2)[0] +
                                ((npy_uint *)data_out + 2*2)[0];
        ((npy_uint *)data_out + 2*2)[1] =
                                ((npy_uint *)data0 + 2*2)[1] +
                                ((npy_uint *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_uint *)data_out + 2*3)[0] =
                                ((npy_uint *)data0 + 2*3)[0] +
                                ((npy_uint *)data_out + 2*3)[0];
        ((npy_uint *)data_out + 2*3)[1] =
                                ((npy_uint *)data0 + 2*3)[1] +
                                ((npy_uint *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_uint *)data_out + 2*4)[0] =
                                ((npy_uint *)data0 + 2*4)[0] +
                                ((npy_uint *)data_out + 2*4)[0];
        ((npy_uint *)data_out + 2*4)[1] =
                                ((npy_uint *)data0 + 2*4)[1] +
                                ((npy_uint *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_uint *)data_out + 2*5)[0] =
                                ((npy_uint *)data0 + 2*5)[0] +
                                ((npy_uint *)data_out + 2*5)[0];
        ((npy_uint *)data_out + 2*5)[1] =
                                ((npy_uint *)data0 + 2*5)[1] +
                                ((npy_uint *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_uint *)data_out + 2*6)[0] =
                                ((npy_uint *)data0 + 2*6)[0] +
                                ((npy_uint *)data_out + 2*6)[0];
        ((npy_uint *)data_out + 2*6)[1] =
                                ((npy_uint *)data0 + 2*6)[1] +
                                ((npy_uint *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_uint *)data_out + 2*7)[0] =
                                ((npy_uint *)data0 + 2*7)[0] +
                                ((npy_uint *)data_out + 2*7)[0];
        ((npy_uint *)data_out + 2*7)[1] =
                                ((npy_uint *)data0 + 2*7)[1] +
                                ((npy_uint *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
uint_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
uint_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
uint_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint *data_out = (npy_uint *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint value0 = (*(npy_uint *)dataptr[0]);
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
uint_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint value1 = (*(npy_uint *)dataptr[1]);
    npy_uint accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_uint *)dataptr[2] = ((*(npy_uint *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
uint_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_uint *data0 = (npy_uint *)dataptr[0];
    npy_uint *data1 = (npy_uint *)dataptr[1];
    npy_uint *data2 = (npy_uint *)dataptr[2];
    npy_uint *data_out = (npy_uint *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
uint_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        *(npy_uint *)dataptr[nop] = (temp +
                                           (*(npy_uint *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_uint *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[0];
        ((npy_uint *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_uint *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_uint);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
uint_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#else
    npy_uint accum = 0;
    npy_uint *data0 = (npy_uint *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_uint *)dataptr[1])[0] += accum_re;
            ((npy_uint *)dataptr[1])[1] += accum_im;
#else
            *((npy_uint *)dataptr[1]) = (accum +
                                    (*((npy_uint *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
uint_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_uint accum_re = 0, accum_im = 0;
#else
    npy_uint accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("uint_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_uint *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_uint *)data0) *
                 (*(npy_uint *)data1) *
                 (*(npy_uint *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_uint temp = (*(npy_uint *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_uint *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_uint *)data0)[0];
        accum_im += ((npy_uint *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_uint re, im, tmp;
        int i;
        re = ((npy_uint *)dataptr[0])[0];
        im = ((npy_uint *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_uint *)dataptr[i])[0] -
                  im * ((npy_uint *)dataptr[i])[1];
            im = re * ((npy_uint *)dataptr[i])[1] +
                 im * ((npy_uint *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_uint *)dataptr[1000])[0] += accum_re;
    ((npy_uint *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_uint *)dataptr[nop])[0] += accum_re;
    ((npy_uint *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_uint *)dataptr[1000]) = (accum +
                                    (*((npy_uint *)dataptr[1000])));
#  else
    *((npy_uint *)dataptr[nop]) = (accum +
                                    (*((npy_uint *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
ulong_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) *
                                         (*(npy_ulong *)data2) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_ulong *)data_out)[0] = ((npy_ulong *)data0)[0] +
                                         ((npy_ulong *)data_out)[0];
        ((npy_ulong *)data_out)[1] = ((npy_ulong *)data0)[1] +
                                         ((npy_ulong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
ulong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data_out = (npy_ulong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulong *)data_out + 2*6)[0] =
                                    ((npy_ulong *)data0 + 2*6)[0] +
                                    ((npy_ulong *)data_out + 2*6)[0];
            ((npy_ulong *)data_out + 2*6)[1] =
                                    ((npy_ulong *)data0 + 2*6)[1] +
                                    ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulong *)data_out + 2*5)[0] =
                                    ((npy_ulong *)data0 + 2*5)[0] +
                                    ((npy_ulong *)data_out + 2*5)[0];
            ((npy_ulong *)data_out + 2*5)[1] =
                                    ((npy_ulong *)data0 + 2*5)[1] +
                                    ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulong *)data_out + 2*4)[0] =
                                    ((npy_ulong *)data0 + 2*4)[0] +
                                    ((npy_ulong *)data_out + 2*4)[0];
            ((npy_ulong *)data_out + 2*4)[1] =
                                    ((npy_ulong *)data0 + 2*4)[1] +
                                    ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulong *)data_out + 2*3)[0] =
                                    ((npy_ulong *)data0 + 2*3)[0] +
                                    ((npy_ulong *)data_out + 2*3)[0];
            ((npy_ulong *)data_out + 2*3)[1] =
                                    ((npy_ulong *)data0 + 2*3)[1] +
                                    ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulong *)data_out + 2*2)[0] =
                                    ((npy_ulong *)data0 + 2*2)[0] +
                                    ((npy_ulong *)data_out + 2*2)[0];
            ((npy_ulong *)data_out + 2*2)[1] =
                                    ((npy_ulong *)data0 + 2*2)[1] +
                                    ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulong *)data_out + 2*1)[0] =
                                    ((npy_ulong *)data0 + 2*1)[0] +
                                    ((npy_ulong *)data_out + 2*1)[0];
            ((npy_ulong *)data_out + 2*1)[1] =
                                    ((npy_ulong *)data0 + 2*1)[1] +
                                    ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulong *)data_out + 2*0)[0] =
                                    ((npy_ulong *)data0 + 2*0)[0] +
                                    ((npy_ulong *)data_out + 2*0)[0];
            ((npy_ulong *)data_out + 2*0)[1] =
                                    ((npy_ulong *)data0 + 2*0)[1] +
                                    ((npy_ulong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulong *)data_out + 2*0)[0] =
                                ((npy_ulong *)data0 + 2*0)[0] +
                                ((npy_ulong *)data_out + 2*0)[0];
        ((npy_ulong *)data_out + 2*0)[1] =
                                ((npy_ulong *)data0 + 2*0)[1] +
                                ((npy_ulong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulong *)data_out + 2*1)[0] =
                                ((npy_ulong *)data0 + 2*1)[0] +
                                ((npy_ulong *)data_out + 2*1)[0];
        ((npy_ulong *)data_out + 2*1)[1] =
                                ((npy_ulong *)data0 + 2*1)[1] +
                                ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulong *)data_out + 2*2)[0] =
                                ((npy_ulong *)data0 + 2*2)[0] +
                                ((npy_ulong *)data_out + 2*2)[0];
        ((npy_ulong *)data_out + 2*2)[1] =
                                ((npy_ulong *)data0 + 2*2)[1] +
                                ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulong *)data_out + 2*3)[0] =
                                ((npy_ulong *)data0 + 2*3)[0] +
                                ((npy_ulong *)data_out + 2*3)[0];
        ((npy_ulong *)data_out + 2*3)[1] =
                                ((npy_ulong *)data0 + 2*3)[1] +
                                ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulong *)data_out + 2*4)[0] =
                                ((npy_ulong *)data0 + 2*4)[0] +
                                ((npy_ulong *)data_out + 2*4)[0];
        ((npy_ulong *)data_out + 2*4)[1] =
                                ((npy_ulong *)data0 + 2*4)[1] +
                                ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulong *)data_out + 2*5)[0] =
                                ((npy_ulong *)data0 + 2*5)[0] +
                                ((npy_ulong *)data_out + 2*5)[0];
        ((npy_ulong *)data_out + 2*5)[1] =
                                ((npy_ulong *)data0 + 2*5)[1] +
                                ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulong *)data_out + 2*6)[0] =
                                ((npy_ulong *)data0 + 2*6)[0] +
                                ((npy_ulong *)data_out + 2*6)[0];
        ((npy_ulong *)data_out + 2*6)[1] =
                                ((npy_ulong *)data0 + 2*6)[1] +
                                ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulong *)data_out + 2*7)[0] =
                                ((npy_ulong *)data0 + 2*7)[0] +
                                ((npy_ulong *)data_out + 2*7)[0];
        ((npy_ulong *)data_out + 2*7)[1] =
                                ((npy_ulong *)data0 + 2*7)[1] +
                                ((npy_ulong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
ulong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
ulong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data2 = (npy_ulong *)dataptr[2];
    npy_ulong *data_out = (npy_ulong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
ulong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
ulong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#else
    npy_ulong accum = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulong *)dataptr[1])[0] += accum_re;
            ((npy_ulong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulong *)dataptr[1]) = (accum +
                                    (*((npy_ulong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
ulong_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
#else
    npy_ulong accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_ulong *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1) *
                 (*(npy_ulong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_ulong *)data0)[0];
        accum_im += ((npy_ulong *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_ulong *)dataptr[1])[0] += accum_re;
    ((npy_ulong *)dataptr[1])[1] += accum_im;
#  else
    ((npy_ulong *)dataptr[nop])[0] += accum_re;
    ((npy_ulong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_ulong *)dataptr[1]) = (accum +
                                    (*((npy_ulong *)dataptr[1])));
#  else
    *((npy_ulong *)dataptr[nop]) = (accum +
                                    (*((npy_ulong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulong_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) *
                                         (*(npy_ulong *)data2) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_ulong *)data_out)[0] = ((npy_ulong *)data0)[0] +
                                         ((npy_ulong *)data_out)[0];
        ((npy_ulong *)data_out)[1] = ((npy_ulong *)data0)[1] +
                                         ((npy_ulong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
ulong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data_out = (npy_ulong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulong *)data_out + 2*6)[0] =
                                    ((npy_ulong *)data0 + 2*6)[0] +
                                    ((npy_ulong *)data_out + 2*6)[0];
            ((npy_ulong *)data_out + 2*6)[1] =
                                    ((npy_ulong *)data0 + 2*6)[1] +
                                    ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulong *)data_out + 2*5)[0] =
                                    ((npy_ulong *)data0 + 2*5)[0] +
                                    ((npy_ulong *)data_out + 2*5)[0];
            ((npy_ulong *)data_out + 2*5)[1] =
                                    ((npy_ulong *)data0 + 2*5)[1] +
                                    ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulong *)data_out + 2*4)[0] =
                                    ((npy_ulong *)data0 + 2*4)[0] +
                                    ((npy_ulong *)data_out + 2*4)[0];
            ((npy_ulong *)data_out + 2*4)[1] =
                                    ((npy_ulong *)data0 + 2*4)[1] +
                                    ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulong *)data_out + 2*3)[0] =
                                    ((npy_ulong *)data0 + 2*3)[0] +
                                    ((npy_ulong *)data_out + 2*3)[0];
            ((npy_ulong *)data_out + 2*3)[1] =
                                    ((npy_ulong *)data0 + 2*3)[1] +
                                    ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulong *)data_out + 2*2)[0] =
                                    ((npy_ulong *)data0 + 2*2)[0] +
                                    ((npy_ulong *)data_out + 2*2)[0];
            ((npy_ulong *)data_out + 2*2)[1] =
                                    ((npy_ulong *)data0 + 2*2)[1] +
                                    ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulong *)data_out + 2*1)[0] =
                                    ((npy_ulong *)data0 + 2*1)[0] +
                                    ((npy_ulong *)data_out + 2*1)[0];
            ((npy_ulong *)data_out + 2*1)[1] =
                                    ((npy_ulong *)data0 + 2*1)[1] +
                                    ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulong *)data_out + 2*0)[0] =
                                    ((npy_ulong *)data0 + 2*0)[0] +
                                    ((npy_ulong *)data_out + 2*0)[0];
            ((npy_ulong *)data_out + 2*0)[1] =
                                    ((npy_ulong *)data0 + 2*0)[1] +
                                    ((npy_ulong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulong *)data_out + 2*0)[0] =
                                ((npy_ulong *)data0 + 2*0)[0] +
                                ((npy_ulong *)data_out + 2*0)[0];
        ((npy_ulong *)data_out + 2*0)[1] =
                                ((npy_ulong *)data0 + 2*0)[1] +
                                ((npy_ulong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulong *)data_out + 2*1)[0] =
                                ((npy_ulong *)data0 + 2*1)[0] +
                                ((npy_ulong *)data_out + 2*1)[0];
        ((npy_ulong *)data_out + 2*1)[1] =
                                ((npy_ulong *)data0 + 2*1)[1] +
                                ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulong *)data_out + 2*2)[0] =
                                ((npy_ulong *)data0 + 2*2)[0] +
                                ((npy_ulong *)data_out + 2*2)[0];
        ((npy_ulong *)data_out + 2*2)[1] =
                                ((npy_ulong *)data0 + 2*2)[1] +
                                ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulong *)data_out + 2*3)[0] =
                                ((npy_ulong *)data0 + 2*3)[0] +
                                ((npy_ulong *)data_out + 2*3)[0];
        ((npy_ulong *)data_out + 2*3)[1] =
                                ((npy_ulong *)data0 + 2*3)[1] +
                                ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulong *)data_out + 2*4)[0] =
                                ((npy_ulong *)data0 + 2*4)[0] +
                                ((npy_ulong *)data_out + 2*4)[0];
        ((npy_ulong *)data_out + 2*4)[1] =
                                ((npy_ulong *)data0 + 2*4)[1] +
                                ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulong *)data_out + 2*5)[0] =
                                ((npy_ulong *)data0 + 2*5)[0] +
                                ((npy_ulong *)data_out + 2*5)[0];
        ((npy_ulong *)data_out + 2*5)[1] =
                                ((npy_ulong *)data0 + 2*5)[1] +
                                ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulong *)data_out + 2*6)[0] =
                                ((npy_ulong *)data0 + 2*6)[0] +
                                ((npy_ulong *)data_out + 2*6)[0];
        ((npy_ulong *)data_out + 2*6)[1] =
                                ((npy_ulong *)data0 + 2*6)[1] +
                                ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulong *)data_out + 2*7)[0] =
                                ((npy_ulong *)data0 + 2*7)[0] +
                                ((npy_ulong *)data_out + 2*7)[0];
        ((npy_ulong *)data_out + 2*7)[1] =
                                ((npy_ulong *)data0 + 2*7)[1] +
                                ((npy_ulong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
ulong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
ulong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data2 = (npy_ulong *)dataptr[2];
    npy_ulong *data_out = (npy_ulong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
ulong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
ulong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#else
    npy_ulong accum = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulong *)dataptr[1])[0] += accum_re;
            ((npy_ulong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulong *)dataptr[1]) = (accum +
                                    (*((npy_ulong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
ulong_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
#else
    npy_ulong accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_ulong *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1) *
                 (*(npy_ulong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_ulong *)data0)[0];
        accum_im += ((npy_ulong *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_ulong *)dataptr[2])[0] += accum_re;
    ((npy_ulong *)dataptr[2])[1] += accum_im;
#  else
    ((npy_ulong *)dataptr[nop])[0] += accum_re;
    ((npy_ulong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_ulong *)dataptr[2]) = (accum +
                                    (*((npy_ulong *)dataptr[2])));
#  else
    *((npy_ulong *)dataptr[nop]) = (accum +
                                    (*((npy_ulong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulong_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) *
                                         (*(npy_ulong *)data2) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_ulong *)data_out)[0] = ((npy_ulong *)data0)[0] +
                                         ((npy_ulong *)data_out)[0];
        ((npy_ulong *)data_out)[1] = ((npy_ulong *)data0)[1] +
                                         ((npy_ulong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
ulong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data_out = (npy_ulong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulong *)data_out + 2*6)[0] =
                                    ((npy_ulong *)data0 + 2*6)[0] +
                                    ((npy_ulong *)data_out + 2*6)[0];
            ((npy_ulong *)data_out + 2*6)[1] =
                                    ((npy_ulong *)data0 + 2*6)[1] +
                                    ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulong *)data_out + 2*5)[0] =
                                    ((npy_ulong *)data0 + 2*5)[0] +
                                    ((npy_ulong *)data_out + 2*5)[0];
            ((npy_ulong *)data_out + 2*5)[1] =
                                    ((npy_ulong *)data0 + 2*5)[1] +
                                    ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulong *)data_out + 2*4)[0] =
                                    ((npy_ulong *)data0 + 2*4)[0] +
                                    ((npy_ulong *)data_out + 2*4)[0];
            ((npy_ulong *)data_out + 2*4)[1] =
                                    ((npy_ulong *)data0 + 2*4)[1] +
                                    ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulong *)data_out + 2*3)[0] =
                                    ((npy_ulong *)data0 + 2*3)[0] +
                                    ((npy_ulong *)data_out + 2*3)[0];
            ((npy_ulong *)data_out + 2*3)[1] =
                                    ((npy_ulong *)data0 + 2*3)[1] +
                                    ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulong *)data_out + 2*2)[0] =
                                    ((npy_ulong *)data0 + 2*2)[0] +
                                    ((npy_ulong *)data_out + 2*2)[0];
            ((npy_ulong *)data_out + 2*2)[1] =
                                    ((npy_ulong *)data0 + 2*2)[1] +
                                    ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulong *)data_out + 2*1)[0] =
                                    ((npy_ulong *)data0 + 2*1)[0] +
                                    ((npy_ulong *)data_out + 2*1)[0];
            ((npy_ulong *)data_out + 2*1)[1] =
                                    ((npy_ulong *)data0 + 2*1)[1] +
                                    ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulong *)data_out + 2*0)[0] =
                                    ((npy_ulong *)data0 + 2*0)[0] +
                                    ((npy_ulong *)data_out + 2*0)[0];
            ((npy_ulong *)data_out + 2*0)[1] =
                                    ((npy_ulong *)data0 + 2*0)[1] +
                                    ((npy_ulong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulong *)data_out + 2*0)[0] =
                                ((npy_ulong *)data0 + 2*0)[0] +
                                ((npy_ulong *)data_out + 2*0)[0];
        ((npy_ulong *)data_out + 2*0)[1] =
                                ((npy_ulong *)data0 + 2*0)[1] +
                                ((npy_ulong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulong *)data_out + 2*1)[0] =
                                ((npy_ulong *)data0 + 2*1)[0] +
                                ((npy_ulong *)data_out + 2*1)[0];
        ((npy_ulong *)data_out + 2*1)[1] =
                                ((npy_ulong *)data0 + 2*1)[1] +
                                ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulong *)data_out + 2*2)[0] =
                                ((npy_ulong *)data0 + 2*2)[0] +
                                ((npy_ulong *)data_out + 2*2)[0];
        ((npy_ulong *)data_out + 2*2)[1] =
                                ((npy_ulong *)data0 + 2*2)[1] +
                                ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulong *)data_out + 2*3)[0] =
                                ((npy_ulong *)data0 + 2*3)[0] +
                                ((npy_ulong *)data_out + 2*3)[0];
        ((npy_ulong *)data_out + 2*3)[1] =
                                ((npy_ulong *)data0 + 2*3)[1] +
                                ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulong *)data_out + 2*4)[0] =
                                ((npy_ulong *)data0 + 2*4)[0] +
                                ((npy_ulong *)data_out + 2*4)[0];
        ((npy_ulong *)data_out + 2*4)[1] =
                                ((npy_ulong *)data0 + 2*4)[1] +
                                ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulong *)data_out + 2*5)[0] =
                                ((npy_ulong *)data0 + 2*5)[0] +
                                ((npy_ulong *)data_out + 2*5)[0];
        ((npy_ulong *)data_out + 2*5)[1] =
                                ((npy_ulong *)data0 + 2*5)[1] +
                                ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulong *)data_out + 2*6)[0] =
                                ((npy_ulong *)data0 + 2*6)[0] +
                                ((npy_ulong *)data_out + 2*6)[0];
        ((npy_ulong *)data_out + 2*6)[1] =
                                ((npy_ulong *)data0 + 2*6)[1] +
                                ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulong *)data_out + 2*7)[0] =
                                ((npy_ulong *)data0 + 2*7)[0] +
                                ((npy_ulong *)data_out + 2*7)[0];
        ((npy_ulong *)data_out + 2*7)[1] =
                                ((npy_ulong *)data0 + 2*7)[1] +
                                ((npy_ulong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
ulong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
ulong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data2 = (npy_ulong *)dataptr[2];
    npy_ulong *data_out = (npy_ulong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
ulong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
ulong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#else
    npy_ulong accum = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulong *)dataptr[1])[0] += accum_re;
            ((npy_ulong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulong *)dataptr[1]) = (accum +
                                    (*((npy_ulong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
ulong_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
#else
    npy_ulong accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_ulong *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1) *
                 (*(npy_ulong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_ulong *)data0)[0];
        accum_im += ((npy_ulong *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_ulong *)dataptr[3])[0] += accum_re;
    ((npy_ulong *)dataptr[3])[1] += accum_im;
#  else
    ((npy_ulong *)dataptr[nop])[0] += accum_re;
    ((npy_ulong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_ulong *)dataptr[3]) = (accum +
                                    (*((npy_ulong *)dataptr[3])));
#  else
    *((npy_ulong *)dataptr[nop]) = (accum +
                                    (*((npy_ulong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulong_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_ulong *)data_out = ((*(npy_ulong *)data0) *
                                         (*(npy_ulong *)data1) *
                                         (*(npy_ulong *)data2) +
                                         (*(npy_ulong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_ulong *)data_out)[0] = ((npy_ulong *)data0)[0] +
                                         ((npy_ulong *)data_out)[0];
        ((npy_ulong *)data_out)[1] = ((npy_ulong *)data0)[1] +
                                         ((npy_ulong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
ulong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data_out = (npy_ulong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulong *)data_out + 2*6)[0] =
                                    ((npy_ulong *)data0 + 2*6)[0] +
                                    ((npy_ulong *)data_out + 2*6)[0];
            ((npy_ulong *)data_out + 2*6)[1] =
                                    ((npy_ulong *)data0 + 2*6)[1] +
                                    ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulong *)data_out + 2*5)[0] =
                                    ((npy_ulong *)data0 + 2*5)[0] +
                                    ((npy_ulong *)data_out + 2*5)[0];
            ((npy_ulong *)data_out + 2*5)[1] =
                                    ((npy_ulong *)data0 + 2*5)[1] +
                                    ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulong *)data_out + 2*4)[0] =
                                    ((npy_ulong *)data0 + 2*4)[0] +
                                    ((npy_ulong *)data_out + 2*4)[0];
            ((npy_ulong *)data_out + 2*4)[1] =
                                    ((npy_ulong *)data0 + 2*4)[1] +
                                    ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulong *)data_out + 2*3)[0] =
                                    ((npy_ulong *)data0 + 2*3)[0] +
                                    ((npy_ulong *)data_out + 2*3)[0];
            ((npy_ulong *)data_out + 2*3)[1] =
                                    ((npy_ulong *)data0 + 2*3)[1] +
                                    ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulong *)data_out + 2*2)[0] =
                                    ((npy_ulong *)data0 + 2*2)[0] +
                                    ((npy_ulong *)data_out + 2*2)[0];
            ((npy_ulong *)data_out + 2*2)[1] =
                                    ((npy_ulong *)data0 + 2*2)[1] +
                                    ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulong *)data_out + 2*1)[0] =
                                    ((npy_ulong *)data0 + 2*1)[0] +
                                    ((npy_ulong *)data_out + 2*1)[0];
            ((npy_ulong *)data_out + 2*1)[1] =
                                    ((npy_ulong *)data0 + 2*1)[1] +
                                    ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulong *)data_out + 2*0)[0] =
                                    ((npy_ulong *)data0 + 2*0)[0] +
                                    ((npy_ulong *)data_out + 2*0)[0];
            ((npy_ulong *)data_out + 2*0)[1] =
                                    ((npy_ulong *)data0 + 2*0)[1] +
                                    ((npy_ulong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulong *)data_out + 2*0)[0] =
                                ((npy_ulong *)data0 + 2*0)[0] +
                                ((npy_ulong *)data_out + 2*0)[0];
        ((npy_ulong *)data_out + 2*0)[1] =
                                ((npy_ulong *)data0 + 2*0)[1] +
                                ((npy_ulong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulong *)data_out + 2*1)[0] =
                                ((npy_ulong *)data0 + 2*1)[0] +
                                ((npy_ulong *)data_out + 2*1)[0];
        ((npy_ulong *)data_out + 2*1)[1] =
                                ((npy_ulong *)data0 + 2*1)[1] +
                                ((npy_ulong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulong *)data_out + 2*2)[0] =
                                ((npy_ulong *)data0 + 2*2)[0] +
                                ((npy_ulong *)data_out + 2*2)[0];
        ((npy_ulong *)data_out + 2*2)[1] =
                                ((npy_ulong *)data0 + 2*2)[1] +
                                ((npy_ulong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulong *)data_out + 2*3)[0] =
                                ((npy_ulong *)data0 + 2*3)[0] +
                                ((npy_ulong *)data_out + 2*3)[0];
        ((npy_ulong *)data_out + 2*3)[1] =
                                ((npy_ulong *)data0 + 2*3)[1] +
                                ((npy_ulong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulong *)data_out + 2*4)[0] =
                                ((npy_ulong *)data0 + 2*4)[0] +
                                ((npy_ulong *)data_out + 2*4)[0];
        ((npy_ulong *)data_out + 2*4)[1] =
                                ((npy_ulong *)data0 + 2*4)[1] +
                                ((npy_ulong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulong *)data_out + 2*5)[0] =
                                ((npy_ulong *)data0 + 2*5)[0] +
                                ((npy_ulong *)data_out + 2*5)[0];
        ((npy_ulong *)data_out + 2*5)[1] =
                                ((npy_ulong *)data0 + 2*5)[1] +
                                ((npy_ulong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulong *)data_out + 2*6)[0] =
                                ((npy_ulong *)data0 + 2*6)[0] +
                                ((npy_ulong *)data_out + 2*6)[0];
        ((npy_ulong *)data_out + 2*6)[1] =
                                ((npy_ulong *)data0 + 2*6)[1] +
                                ((npy_ulong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulong *)data_out + 2*7)[0] =
                                ((npy_ulong *)data0 + 2*7)[0] +
                                ((npy_ulong *)data_out + 2*7)[0];
        ((npy_ulong *)data_out + 2*7)[1] =
                                ((npy_ulong *)data0 + 2*7)[1] +
                                ((npy_ulong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
ulong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong *data_out = (npy_ulong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong value0 = (*(npy_ulong *)dataptr[0]);
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong value1 = (*(npy_ulong *)dataptr[1]);
    npy_ulong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulong *)dataptr[2] = ((*(npy_ulong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
ulong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
    npy_ulong *data1 = (npy_ulong *)dataptr[1];
    npy_ulong *data2 = (npy_ulong *)dataptr[2];
    npy_ulong *data_out = (npy_ulong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
ulong_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        *(npy_ulong *)dataptr[nop] = (temp +
                                           (*(npy_ulong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
ulong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#else
    npy_ulong accum = 0;
    npy_ulong *data0 = (npy_ulong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulong *)dataptr[1])[0] += accum_re;
            ((npy_ulong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulong *)dataptr[1]) = (accum +
                                    (*((npy_ulong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
ulong_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulong accum_re = 0, accum_im = 0;
#else
    npy_ulong accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulong_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_ulong *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_ulong *)data0) *
                 (*(npy_ulong *)data1) *
                 (*(npy_ulong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulong temp = (*(npy_ulong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_ulong *)data0)[0];
        accum_im += ((npy_ulong *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulong re, im, tmp;
        int i;
        re = ((npy_ulong *)dataptr[0])[0];
        im = ((npy_ulong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulong *)dataptr[i])[0] -
                  im * ((npy_ulong *)dataptr[i])[1];
            im = re * ((npy_ulong *)dataptr[i])[1] +
                 im * ((npy_ulong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_ulong *)dataptr[1000])[0] += accum_re;
    ((npy_ulong *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_ulong *)dataptr[nop])[0] += accum_re;
    ((npy_ulong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_ulong *)dataptr[1000]) = (accum +
                                    (*((npy_ulong *)dataptr[1000])));
#  else
    *((npy_ulong *)dataptr[nop]) = (accum +
                                    (*((npy_ulong *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
ulonglong_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) *
                                         (*(npy_ulonglong *)data2) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_ulonglong *)data_out)[0] = ((npy_ulonglong *)data0)[0] +
                                         ((npy_ulonglong *)data_out)[0];
        ((npy_ulonglong *)data_out)[1] = ((npy_ulonglong *)data0)[1] +
                                         ((npy_ulonglong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
ulonglong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulonglong *)data_out + 2*6)[0] =
                                    ((npy_ulonglong *)data0 + 2*6)[0] +
                                    ((npy_ulonglong *)data_out + 2*6)[0];
            ((npy_ulonglong *)data_out + 2*6)[1] =
                                    ((npy_ulonglong *)data0 + 2*6)[1] +
                                    ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulonglong *)data_out + 2*5)[0] =
                                    ((npy_ulonglong *)data0 + 2*5)[0] +
                                    ((npy_ulonglong *)data_out + 2*5)[0];
            ((npy_ulonglong *)data_out + 2*5)[1] =
                                    ((npy_ulonglong *)data0 + 2*5)[1] +
                                    ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulonglong *)data_out + 2*4)[0] =
                                    ((npy_ulonglong *)data0 + 2*4)[0] +
                                    ((npy_ulonglong *)data_out + 2*4)[0];
            ((npy_ulonglong *)data_out + 2*4)[1] =
                                    ((npy_ulonglong *)data0 + 2*4)[1] +
                                    ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulonglong *)data_out + 2*3)[0] =
                                    ((npy_ulonglong *)data0 + 2*3)[0] +
                                    ((npy_ulonglong *)data_out + 2*3)[0];
            ((npy_ulonglong *)data_out + 2*3)[1] =
                                    ((npy_ulonglong *)data0 + 2*3)[1] +
                                    ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulonglong *)data_out + 2*2)[0] =
                                    ((npy_ulonglong *)data0 + 2*2)[0] +
                                    ((npy_ulonglong *)data_out + 2*2)[0];
            ((npy_ulonglong *)data_out + 2*2)[1] =
                                    ((npy_ulonglong *)data0 + 2*2)[1] +
                                    ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulonglong *)data_out + 2*1)[0] =
                                    ((npy_ulonglong *)data0 + 2*1)[0] +
                                    ((npy_ulonglong *)data_out + 2*1)[0];
            ((npy_ulonglong *)data_out + 2*1)[1] =
                                    ((npy_ulonglong *)data0 + 2*1)[1] +
                                    ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulonglong *)data_out + 2*0)[0] =
                                    ((npy_ulonglong *)data0 + 2*0)[0] +
                                    ((npy_ulonglong *)data_out + 2*0)[0];
            ((npy_ulonglong *)data_out + 2*0)[1] =
                                    ((npy_ulonglong *)data0 + 2*0)[1] +
                                    ((npy_ulonglong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*0)[0] =
                                ((npy_ulonglong *)data0 + 2*0)[0] +
                                ((npy_ulonglong *)data_out + 2*0)[0];
        ((npy_ulonglong *)data_out + 2*0)[1] =
                                ((npy_ulonglong *)data0 + 2*0)[1] +
                                ((npy_ulonglong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*1)[0] =
                                ((npy_ulonglong *)data0 + 2*1)[0] +
                                ((npy_ulonglong *)data_out + 2*1)[0];
        ((npy_ulonglong *)data_out + 2*1)[1] =
                                ((npy_ulonglong *)data0 + 2*1)[1] +
                                ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*2)[0] =
                                ((npy_ulonglong *)data0 + 2*2)[0] +
                                ((npy_ulonglong *)data_out + 2*2)[0];
        ((npy_ulonglong *)data_out + 2*2)[1] =
                                ((npy_ulonglong *)data0 + 2*2)[1] +
                                ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*3)[0] =
                                ((npy_ulonglong *)data0 + 2*3)[0] +
                                ((npy_ulonglong *)data_out + 2*3)[0];
        ((npy_ulonglong *)data_out + 2*3)[1] =
                                ((npy_ulonglong *)data0 + 2*3)[1] +
                                ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*4)[0] =
                                ((npy_ulonglong *)data0 + 2*4)[0] +
                                ((npy_ulonglong *)data_out + 2*4)[0];
        ((npy_ulonglong *)data_out + 2*4)[1] =
                                ((npy_ulonglong *)data0 + 2*4)[1] +
                                ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*5)[0] =
                                ((npy_ulonglong *)data0 + 2*5)[0] +
                                ((npy_ulonglong *)data_out + 2*5)[0];
        ((npy_ulonglong *)data_out + 2*5)[1] =
                                ((npy_ulonglong *)data0 + 2*5)[1] +
                                ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*6)[0] =
                                ((npy_ulonglong *)data0 + 2*6)[0] +
                                ((npy_ulonglong *)data_out + 2*6)[0];
        ((npy_ulonglong *)data_out + 2*6)[1] =
                                ((npy_ulonglong *)data0 + 2*6)[1] +
                                ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*7)[0] =
                                ((npy_ulonglong *)data0 + 2*7)[0] +
                                ((npy_ulonglong *)data_out + 2*7)[0];
        ((npy_ulonglong *)data_out + 2*7)[1] =
                                ((npy_ulonglong *)data0 + 2*7)[1] +
                                ((npy_ulonglong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
ulonglong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulonglong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulonglong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
ulonglong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data2 = (npy_ulonglong *)dataptr[2];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
ulonglong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
ulonglong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#else
    npy_ulonglong accum = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulonglong *)dataptr[1])[0] += accum_re;
            ((npy_ulonglong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulonglong *)dataptr[1]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
ulonglong_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
#else
    npy_ulonglong accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_ulonglong *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1) *
                 (*(npy_ulonglong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_ulonglong *)data0)[0];
        accum_im += ((npy_ulonglong *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_ulonglong *)dataptr[1])[0] += accum_re;
    ((npy_ulonglong *)dataptr[1])[1] += accum_im;
#  else
    ((npy_ulonglong *)dataptr[nop])[0] += accum_re;
    ((npy_ulonglong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_ulonglong *)dataptr[1]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1])));
#  else
    *((npy_ulonglong *)dataptr[nop]) = (accum +
                                    (*((npy_ulonglong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulonglong_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) *
                                         (*(npy_ulonglong *)data2) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_ulonglong *)data_out)[0] = ((npy_ulonglong *)data0)[0] +
                                         ((npy_ulonglong *)data_out)[0];
        ((npy_ulonglong *)data_out)[1] = ((npy_ulonglong *)data0)[1] +
                                         ((npy_ulonglong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
ulonglong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulonglong *)data_out + 2*6)[0] =
                                    ((npy_ulonglong *)data0 + 2*6)[0] +
                                    ((npy_ulonglong *)data_out + 2*6)[0];
            ((npy_ulonglong *)data_out + 2*6)[1] =
                                    ((npy_ulonglong *)data0 + 2*6)[1] +
                                    ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulonglong *)data_out + 2*5)[0] =
                                    ((npy_ulonglong *)data0 + 2*5)[0] +
                                    ((npy_ulonglong *)data_out + 2*5)[0];
            ((npy_ulonglong *)data_out + 2*5)[1] =
                                    ((npy_ulonglong *)data0 + 2*5)[1] +
                                    ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulonglong *)data_out + 2*4)[0] =
                                    ((npy_ulonglong *)data0 + 2*4)[0] +
                                    ((npy_ulonglong *)data_out + 2*4)[0];
            ((npy_ulonglong *)data_out + 2*4)[1] =
                                    ((npy_ulonglong *)data0 + 2*4)[1] +
                                    ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulonglong *)data_out + 2*3)[0] =
                                    ((npy_ulonglong *)data0 + 2*3)[0] +
                                    ((npy_ulonglong *)data_out + 2*3)[0];
            ((npy_ulonglong *)data_out + 2*3)[1] =
                                    ((npy_ulonglong *)data0 + 2*3)[1] +
                                    ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulonglong *)data_out + 2*2)[0] =
                                    ((npy_ulonglong *)data0 + 2*2)[0] +
                                    ((npy_ulonglong *)data_out + 2*2)[0];
            ((npy_ulonglong *)data_out + 2*2)[1] =
                                    ((npy_ulonglong *)data0 + 2*2)[1] +
                                    ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulonglong *)data_out + 2*1)[0] =
                                    ((npy_ulonglong *)data0 + 2*1)[0] +
                                    ((npy_ulonglong *)data_out + 2*1)[0];
            ((npy_ulonglong *)data_out + 2*1)[1] =
                                    ((npy_ulonglong *)data0 + 2*1)[1] +
                                    ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulonglong *)data_out + 2*0)[0] =
                                    ((npy_ulonglong *)data0 + 2*0)[0] +
                                    ((npy_ulonglong *)data_out + 2*0)[0];
            ((npy_ulonglong *)data_out + 2*0)[1] =
                                    ((npy_ulonglong *)data0 + 2*0)[1] +
                                    ((npy_ulonglong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*0)[0] =
                                ((npy_ulonglong *)data0 + 2*0)[0] +
                                ((npy_ulonglong *)data_out + 2*0)[0];
        ((npy_ulonglong *)data_out + 2*0)[1] =
                                ((npy_ulonglong *)data0 + 2*0)[1] +
                                ((npy_ulonglong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*1)[0] =
                                ((npy_ulonglong *)data0 + 2*1)[0] +
                                ((npy_ulonglong *)data_out + 2*1)[0];
        ((npy_ulonglong *)data_out + 2*1)[1] =
                                ((npy_ulonglong *)data0 + 2*1)[1] +
                                ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*2)[0] =
                                ((npy_ulonglong *)data0 + 2*2)[0] +
                                ((npy_ulonglong *)data_out + 2*2)[0];
        ((npy_ulonglong *)data_out + 2*2)[1] =
                                ((npy_ulonglong *)data0 + 2*2)[1] +
                                ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*3)[0] =
                                ((npy_ulonglong *)data0 + 2*3)[0] +
                                ((npy_ulonglong *)data_out + 2*3)[0];
        ((npy_ulonglong *)data_out + 2*3)[1] =
                                ((npy_ulonglong *)data0 + 2*3)[1] +
                                ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*4)[0] =
                                ((npy_ulonglong *)data0 + 2*4)[0] +
                                ((npy_ulonglong *)data_out + 2*4)[0];
        ((npy_ulonglong *)data_out + 2*4)[1] =
                                ((npy_ulonglong *)data0 + 2*4)[1] +
                                ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*5)[0] =
                                ((npy_ulonglong *)data0 + 2*5)[0] +
                                ((npy_ulonglong *)data_out + 2*5)[0];
        ((npy_ulonglong *)data_out + 2*5)[1] =
                                ((npy_ulonglong *)data0 + 2*5)[1] +
                                ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*6)[0] =
                                ((npy_ulonglong *)data0 + 2*6)[0] +
                                ((npy_ulonglong *)data_out + 2*6)[0];
        ((npy_ulonglong *)data_out + 2*6)[1] =
                                ((npy_ulonglong *)data0 + 2*6)[1] +
                                ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*7)[0] =
                                ((npy_ulonglong *)data0 + 2*7)[0] +
                                ((npy_ulonglong *)data_out + 2*7)[0];
        ((npy_ulonglong *)data_out + 2*7)[1] =
                                ((npy_ulonglong *)data0 + 2*7)[1] +
                                ((npy_ulonglong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
ulonglong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulonglong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulonglong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
ulonglong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data2 = (npy_ulonglong *)dataptr[2];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
ulonglong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
ulonglong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#else
    npy_ulonglong accum = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulonglong *)dataptr[1])[0] += accum_re;
            ((npy_ulonglong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulonglong *)dataptr[1]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
ulonglong_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
#else
    npy_ulonglong accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_ulonglong *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1) *
                 (*(npy_ulonglong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_ulonglong *)data0)[0];
        accum_im += ((npy_ulonglong *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_ulonglong *)dataptr[2])[0] += accum_re;
    ((npy_ulonglong *)dataptr[2])[1] += accum_im;
#  else
    ((npy_ulonglong *)dataptr[nop])[0] += accum_re;
    ((npy_ulonglong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_ulonglong *)dataptr[2]) = (accum +
                                    (*((npy_ulonglong *)dataptr[2])));
#  else
    *((npy_ulonglong *)dataptr[nop]) = (accum +
                                    (*((npy_ulonglong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulonglong_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) *
                                         (*(npy_ulonglong *)data2) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_ulonglong *)data_out)[0] = ((npy_ulonglong *)data0)[0] +
                                         ((npy_ulonglong *)data_out)[0];
        ((npy_ulonglong *)data_out)[1] = ((npy_ulonglong *)data0)[1] +
                                         ((npy_ulonglong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
ulonglong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulonglong *)data_out + 2*6)[0] =
                                    ((npy_ulonglong *)data0 + 2*6)[0] +
                                    ((npy_ulonglong *)data_out + 2*6)[0];
            ((npy_ulonglong *)data_out + 2*6)[1] =
                                    ((npy_ulonglong *)data0 + 2*6)[1] +
                                    ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulonglong *)data_out + 2*5)[0] =
                                    ((npy_ulonglong *)data0 + 2*5)[0] +
                                    ((npy_ulonglong *)data_out + 2*5)[0];
            ((npy_ulonglong *)data_out + 2*5)[1] =
                                    ((npy_ulonglong *)data0 + 2*5)[1] +
                                    ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulonglong *)data_out + 2*4)[0] =
                                    ((npy_ulonglong *)data0 + 2*4)[0] +
                                    ((npy_ulonglong *)data_out + 2*4)[0];
            ((npy_ulonglong *)data_out + 2*4)[1] =
                                    ((npy_ulonglong *)data0 + 2*4)[1] +
                                    ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulonglong *)data_out + 2*3)[0] =
                                    ((npy_ulonglong *)data0 + 2*3)[0] +
                                    ((npy_ulonglong *)data_out + 2*3)[0];
            ((npy_ulonglong *)data_out + 2*3)[1] =
                                    ((npy_ulonglong *)data0 + 2*3)[1] +
                                    ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulonglong *)data_out + 2*2)[0] =
                                    ((npy_ulonglong *)data0 + 2*2)[0] +
                                    ((npy_ulonglong *)data_out + 2*2)[0];
            ((npy_ulonglong *)data_out + 2*2)[1] =
                                    ((npy_ulonglong *)data0 + 2*2)[1] +
                                    ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulonglong *)data_out + 2*1)[0] =
                                    ((npy_ulonglong *)data0 + 2*1)[0] +
                                    ((npy_ulonglong *)data_out + 2*1)[0];
            ((npy_ulonglong *)data_out + 2*1)[1] =
                                    ((npy_ulonglong *)data0 + 2*1)[1] +
                                    ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulonglong *)data_out + 2*0)[0] =
                                    ((npy_ulonglong *)data0 + 2*0)[0] +
                                    ((npy_ulonglong *)data_out + 2*0)[0];
            ((npy_ulonglong *)data_out + 2*0)[1] =
                                    ((npy_ulonglong *)data0 + 2*0)[1] +
                                    ((npy_ulonglong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*0)[0] =
                                ((npy_ulonglong *)data0 + 2*0)[0] +
                                ((npy_ulonglong *)data_out + 2*0)[0];
        ((npy_ulonglong *)data_out + 2*0)[1] =
                                ((npy_ulonglong *)data0 + 2*0)[1] +
                                ((npy_ulonglong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*1)[0] =
                                ((npy_ulonglong *)data0 + 2*1)[0] +
                                ((npy_ulonglong *)data_out + 2*1)[0];
        ((npy_ulonglong *)data_out + 2*1)[1] =
                                ((npy_ulonglong *)data0 + 2*1)[1] +
                                ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*2)[0] =
                                ((npy_ulonglong *)data0 + 2*2)[0] +
                                ((npy_ulonglong *)data_out + 2*2)[0];
        ((npy_ulonglong *)data_out + 2*2)[1] =
                                ((npy_ulonglong *)data0 + 2*2)[1] +
                                ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*3)[0] =
                                ((npy_ulonglong *)data0 + 2*3)[0] +
                                ((npy_ulonglong *)data_out + 2*3)[0];
        ((npy_ulonglong *)data_out + 2*3)[1] =
                                ((npy_ulonglong *)data0 + 2*3)[1] +
                                ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*4)[0] =
                                ((npy_ulonglong *)data0 + 2*4)[0] +
                                ((npy_ulonglong *)data_out + 2*4)[0];
        ((npy_ulonglong *)data_out + 2*4)[1] =
                                ((npy_ulonglong *)data0 + 2*4)[1] +
                                ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*5)[0] =
                                ((npy_ulonglong *)data0 + 2*5)[0] +
                                ((npy_ulonglong *)data_out + 2*5)[0];
        ((npy_ulonglong *)data_out + 2*5)[1] =
                                ((npy_ulonglong *)data0 + 2*5)[1] +
                                ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*6)[0] =
                                ((npy_ulonglong *)data0 + 2*6)[0] +
                                ((npy_ulonglong *)data_out + 2*6)[0];
        ((npy_ulonglong *)data_out + 2*6)[1] =
                                ((npy_ulonglong *)data0 + 2*6)[1] +
                                ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*7)[0] =
                                ((npy_ulonglong *)data0 + 2*7)[0] +
                                ((npy_ulonglong *)data_out + 2*7)[0];
        ((npy_ulonglong *)data_out + 2*7)[1] =
                                ((npy_ulonglong *)data0 + 2*7)[1] +
                                ((npy_ulonglong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
ulonglong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulonglong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulonglong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
ulonglong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data2 = (npy_ulonglong *)dataptr[2];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
ulonglong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
ulonglong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#else
    npy_ulonglong accum = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulonglong *)dataptr[1])[0] += accum_re;
            ((npy_ulonglong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulonglong *)dataptr[1]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
ulonglong_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
#else
    npy_ulonglong accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_ulonglong *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1) *
                 (*(npy_ulonglong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_ulonglong *)data0)[0];
        accum_im += ((npy_ulonglong *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_ulonglong *)dataptr[3])[0] += accum_re;
    ((npy_ulonglong *)dataptr[3])[1] += accum_im;
#  else
    ((npy_ulonglong *)dataptr[nop])[0] += accum_re;
    ((npy_ulonglong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_ulonglong *)dataptr[3]) = (accum +
                                    (*((npy_ulonglong *)dataptr[3])));
#  else
    *((npy_ulonglong *)dataptr[nop]) = (accum +
                                    (*((npy_ulonglong *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
ulonglong_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_ulonglong *)data_out = ((*(npy_ulonglong *)data0) *
                                         (*(npy_ulonglong *)data1) *
                                         (*(npy_ulonglong *)data2) +
                                         (*(npy_ulonglong *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_ulonglong *)data_out)[0] = ((npy_ulonglong *)data0)[0] +
                                         ((npy_ulonglong *)data_out)[0];
        ((npy_ulonglong *)data_out)[1] = ((npy_ulonglong *)data0)[1] +
                                         ((npy_ulonglong *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
ulonglong_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_ulonglong *)data_out + 2*6)[0] =
                                    ((npy_ulonglong *)data0 + 2*6)[0] +
                                    ((npy_ulonglong *)data_out + 2*6)[0];
            ((npy_ulonglong *)data_out + 2*6)[1] =
                                    ((npy_ulonglong *)data0 + 2*6)[1] +
                                    ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_ulonglong *)data_out + 2*5)[0] =
                                    ((npy_ulonglong *)data0 + 2*5)[0] +
                                    ((npy_ulonglong *)data_out + 2*5)[0];
            ((npy_ulonglong *)data_out + 2*5)[1] =
                                    ((npy_ulonglong *)data0 + 2*5)[1] +
                                    ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_ulonglong *)data_out + 2*4)[0] =
                                    ((npy_ulonglong *)data0 + 2*4)[0] +
                                    ((npy_ulonglong *)data_out + 2*4)[0];
            ((npy_ulonglong *)data_out + 2*4)[1] =
                                    ((npy_ulonglong *)data0 + 2*4)[1] +
                                    ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_ulonglong *)data_out + 2*3)[0] =
                                    ((npy_ulonglong *)data0 + 2*3)[0] +
                                    ((npy_ulonglong *)data_out + 2*3)[0];
            ((npy_ulonglong *)data_out + 2*3)[1] =
                                    ((npy_ulonglong *)data0 + 2*3)[1] +
                                    ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_ulonglong *)data_out + 2*2)[0] =
                                    ((npy_ulonglong *)data0 + 2*2)[0] +
                                    ((npy_ulonglong *)data_out + 2*2)[0];
            ((npy_ulonglong *)data_out + 2*2)[1] =
                                    ((npy_ulonglong *)data0 + 2*2)[1] +
                                    ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_ulonglong *)data_out + 2*1)[0] =
                                    ((npy_ulonglong *)data0 + 2*1)[0] +
                                    ((npy_ulonglong *)data_out + 2*1)[0];
            ((npy_ulonglong *)data_out + 2*1)[1] =
                                    ((npy_ulonglong *)data0 + 2*1)[1] +
                                    ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_ulonglong *)data_out + 2*0)[0] =
                                    ((npy_ulonglong *)data0 + 2*0)[0] +
                                    ((npy_ulonglong *)data_out + 2*0)[0];
            ((npy_ulonglong *)data_out + 2*0)[1] =
                                    ((npy_ulonglong *)data0 + 2*0)[1] +
                                    ((npy_ulonglong *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*0)[0] =
                                ((npy_ulonglong *)data0 + 2*0)[0] +
                                ((npy_ulonglong *)data_out + 2*0)[0];
        ((npy_ulonglong *)data_out + 2*0)[1] =
                                ((npy_ulonglong *)data0 + 2*0)[1] +
                                ((npy_ulonglong *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*1)[0] =
                                ((npy_ulonglong *)data0 + 2*1)[0] +
                                ((npy_ulonglong *)data_out + 2*1)[0];
        ((npy_ulonglong *)data_out + 2*1)[1] =
                                ((npy_ulonglong *)data0 + 2*1)[1] +
                                ((npy_ulonglong *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*2)[0] =
                                ((npy_ulonglong *)data0 + 2*2)[0] +
                                ((npy_ulonglong *)data_out + 2*2)[0];
        ((npy_ulonglong *)data_out + 2*2)[1] =
                                ((npy_ulonglong *)data0 + 2*2)[1] +
                                ((npy_ulonglong *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*3)[0] =
                                ((npy_ulonglong *)data0 + 2*3)[0] +
                                ((npy_ulonglong *)data_out + 2*3)[0];
        ((npy_ulonglong *)data_out + 2*3)[1] =
                                ((npy_ulonglong *)data0 + 2*3)[1] +
                                ((npy_ulonglong *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*4)[0] =
                                ((npy_ulonglong *)data0 + 2*4)[0] +
                                ((npy_ulonglong *)data_out + 2*4)[0];
        ((npy_ulonglong *)data_out + 2*4)[1] =
                                ((npy_ulonglong *)data0 + 2*4)[1] +
                                ((npy_ulonglong *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*5)[0] =
                                ((npy_ulonglong *)data0 + 2*5)[0] +
                                ((npy_ulonglong *)data_out + 2*5)[0];
        ((npy_ulonglong *)data_out + 2*5)[1] =
                                ((npy_ulonglong *)data0 + 2*5)[1] +
                                ((npy_ulonglong *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*6)[0] =
                                ((npy_ulonglong *)data0 + 2*6)[0] +
                                ((npy_ulonglong *)data_out + 2*6)[0];
        ((npy_ulonglong *)data_out + 2*6)[1] =
                                ((npy_ulonglong *)data0 + 2*6)[1] +
                                ((npy_ulonglong *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_ulonglong *)data_out + 2*7)[0] =
                                ((npy_ulonglong *)data0 + 2*7)[0] +
                                ((npy_ulonglong *)data_out + 2*7)[0];
        ((npy_ulonglong *)data_out + 2*7)[1] =
                                ((npy_ulonglong *)data0 + 2*7)[1] +
                                ((npy_ulonglong *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
ulonglong_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
ulonglong_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
ulonglong_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong value0 = (*(npy_ulonglong *)dataptr[0]);
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
ulonglong_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong value1 = (*(npy_ulonglong *)dataptr[1]);
    npy_ulonglong accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_ulonglong *)dataptr[2] = ((*(npy_ulonglong *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
ulonglong_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
    npy_ulonglong *data1 = (npy_ulonglong *)dataptr[1];
    npy_ulonglong *data2 = (npy_ulonglong *)dataptr[2];
    npy_ulonglong *data_out = (npy_ulonglong *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
ulonglong_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        *(npy_ulonglong *)dataptr[nop] = (temp +
                                           (*(npy_ulonglong *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[0];
        ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_ulonglong *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_ulonglong);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
ulonglong_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#else
    npy_ulonglong accum = 0;
    npy_ulonglong *data0 = (npy_ulonglong *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_ulonglong *)dataptr[1])[0] += accum_re;
            ((npy_ulonglong *)dataptr[1])[1] += accum_im;
#else
            *((npy_ulonglong *)dataptr[1]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
ulonglong_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_ulonglong accum_re = 0, accum_im = 0;
#else
    npy_ulonglong accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("ulonglong_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_ulonglong *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_ulonglong *)data0) *
                 (*(npy_ulonglong *)data1) *
                 (*(npy_ulonglong *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_ulonglong temp = (*(npy_ulonglong *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_ulonglong *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_ulonglong *)data0)[0];
        accum_im += ((npy_ulonglong *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_ulonglong re, im, tmp;
        int i;
        re = ((npy_ulonglong *)dataptr[0])[0];
        im = ((npy_ulonglong *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_ulonglong *)dataptr[i])[0] -
                  im * ((npy_ulonglong *)dataptr[i])[1];
            im = re * ((npy_ulonglong *)dataptr[i])[1] +
                 im * ((npy_ulonglong *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_ulonglong *)dataptr[1000])[0] += accum_re;
    ((npy_ulonglong *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_ulonglong *)dataptr[nop])[0] += accum_re;
    ((npy_ulonglong *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_ulonglong *)dataptr[1000]) = (accum +
                                    (*((npy_ulonglong *)dataptr[1000])));
#  else
    *((npy_ulonglong *)dataptr[nop]) = (accum +
                                    (*((npy_ulonglong *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
half_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) *
                                         npy_half_to_float(*(npy_half *)data2) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
half_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data_out = (npy_half *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                                 npy_half_to_float(data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                                 npy_half_to_float(data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                                 npy_half_to_float(data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                                 npy_half_to_float(data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                                 npy_half_to_float(data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                                 npy_half_to_float(data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                                 npy_half_to_float(data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                             npy_half_to_float(data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                             npy_half_to_float(data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                             npy_half_to_float(data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                             npy_half_to_float(data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                             npy_half_to_float(data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                             npy_half_to_float(data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                             npy_half_to_float(data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) +
                             npy_half_to_float(data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
half_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 290
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 290
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 290
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 290
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 290
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 290
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 340
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 340
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 340
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 340
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 340
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 340
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 340
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
half_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 378
        case 5+1:
            data_out[5] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 378
        case 4+1:
            data_out[4] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 378
        case 3+1:
            data_out[3] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 378
        case 2+1:
            data_out[2] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 378
        case 1+1:
            data_out[1] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 378
        case 0+1:
            data_out[0] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 469
        data_out[1] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 469
        data_out[2] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 469
        data_out[3] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 469
        data_out[4] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 469
        data_out[5] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 469
        data_out[6] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 469
        data_out[7] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
half_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                                 value1  +
                                 npy_half_to_float(data_out[6]));

#line 505
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                                 value1  +
                                 npy_half_to_float(data_out[5]));

#line 505
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                                 value1  +
                                 npy_half_to_float(data_out[4]));

#line 505
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                                 value1  +
                                 npy_half_to_float(data_out[3]));

#line 505
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                                 value1  +
                                 npy_half_to_float(data_out[2]));

#line 505
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                                 value1  +
                                 npy_half_to_float(data_out[1]));

#line 505
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                                 value1  +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                             value1  +
                             npy_half_to_float(data_out[0]));

#line 555
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                             value1  +
                             npy_half_to_float(data_out[1]));

#line 555
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                             value1  +
                             npy_half_to_float(data_out[2]));

#line 555
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                             value1  +
                             npy_half_to_float(data_out[3]));

#line 555
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                             value1  +
                             npy_half_to_float(data_out[4]));

#line 555
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                             value1  +
                             npy_half_to_float(data_out[5]));

#line 555
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                             value1  +
                             npy_half_to_float(data_out[6]));

#line 555
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7])*
                             value1  +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 591
        case 5+1:
            accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 591
        case 4+1:
            accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 591
        case 3+1:
            accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 591
        case 2+1:
            accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 591
        case 1+1:
            accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 591
        case 0+1:
            accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

#line 703
        accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 703
        accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 703
        accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 703
        accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 703
        accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 703
        accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 703
        accum += npy_half_to_float(data0[7]) * npy_half_to_float(data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += npy_half_to_float(data1[6]);

#line 749
        case 5+1:
            accum += npy_half_to_float(data1[5]);

#line 749
        case 4+1:
            accum += npy_half_to_float(data1[4]);

#line 749
        case 3+1:
            accum += npy_half_to_float(data1[3]);

#line 749
        case 2+1:
            accum += npy_half_to_float(data1[2]);

#line 749
        case 1+1:
            accum += npy_half_to_float(data1[1]);

#line 749
        case 0+1:
            accum += npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += npy_half_to_float(data1[0]);

#line 808
        accum += npy_half_to_float(data1[1]);

#line 808
        accum += npy_half_to_float(data1[2]);

#line 808
        accum += npy_half_to_float(data1[3]);

#line 808
        accum += npy_half_to_float(data1[4]);

#line 808
        accum += npy_half_to_float(data1[5]);

#line 808
        accum += npy_half_to_float(data1[6]);

#line 808
        accum += npy_half_to_float(data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += npy_half_to_float(data0[6]);

#line 848
        case 5+1:
            accum += npy_half_to_float(data0[5]);

#line 848
        case 4+1:
            accum += npy_half_to_float(data0[4]);

#line 848
        case 3+1:
            accum += npy_half_to_float(data0[3]);

#line 848
        case 2+1:
            accum += npy_half_to_float(data0[2]);

#line 848
        case 1+1:
            accum += npy_half_to_float(data0[1]);

#line 848
        case 0+1:
            accum += npy_half_to_float(data0[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += npy_half_to_float(data0[0]);

#line 907
        accum += npy_half_to_float(data0[1]);

#line 907
        accum += npy_half_to_float(data0[2]);

#line 907
        accum += npy_half_to_float(data0[3]);

#line 907
        accum += npy_half_to_float(data0[4]);

#line 907
        accum += npy_half_to_float(data0[5]);

#line 907
        accum += npy_half_to_float(data0[6]);

#line 907
        accum += npy_half_to_float(data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
half_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data2 = (npy_half *)dataptr[2];
    npy_half *data_out = (npy_half *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) *
                             npy_half_to_float(data2[0]) +
                             npy_half_to_float(data_out[0]));

#line 944
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) *
                             npy_half_to_float(data2[1]) +
                             npy_half_to_float(data_out[1]));

#line 944
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) *
                             npy_half_to_float(data2[2]) +
                             npy_half_to_float(data_out[2]));

#line 944
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) *
                             npy_half_to_float(data2[3]) +
                             npy_half_to_float(data_out[3]));

#line 944
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) *
                             npy_half_to_float(data2[4]) +
                             npy_half_to_float(data_out[4]));

#line 944
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) *
                             npy_half_to_float(data2[5]) +
                             npy_half_to_float(data_out[5]));

#line 944
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) *
                             npy_half_to_float(data2[6]) +
                             npy_half_to_float(data_out[6]));

#line 944
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) *
                             npy_half_to_float(data2[7]) +
                             npy_half_to_float(data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                         npy_half_to_float(data1[0]) *
                         npy_half_to_float(data2[0]) +
                         npy_half_to_float(data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                         npy_half_to_float(data1[1]) *
                         npy_half_to_float(data2[1]) +
                         npy_half_to_float(data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                         npy_half_to_float(data1[2]) *
                         npy_half_to_float(data2[2]) +
                         npy_half_to_float(data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                         npy_half_to_float(data1[3]) *
                         npy_half_to_float(data2[3]) +
                         npy_half_to_float(data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                         npy_half_to_float(data1[4]) *
                         npy_half_to_float(data2[4]) +
                         npy_half_to_float(data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                         npy_half_to_float(data1[5]) *
                         npy_half_to_float(data2[5]) +
                         npy_half_to_float(data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                         npy_half_to_float(data1[6]) *
                         npy_half_to_float(data2[6]) +
                         npy_half_to_float(data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                         npy_half_to_float(data1[7]) *
                         npy_half_to_float(data2[7]) +
                         npy_half_to_float(data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
half_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
half_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_half *data0 = (npy_half *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += npy_half_to_float(data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += npy_half_to_float(data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += npy_half_to_float(data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += npy_half_to_float(data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += npy_half_to_float(data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += npy_half_to_float(data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += npy_half_to_float(data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_half *)dataptr[1]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += npy_half_to_float(data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
half_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += npy_half_to_float(*(npy_half *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1) *
                 npy_half_to_float(*(npy_half *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_float *)dataptr[1])[0] += accum_re;
    ((npy_float *)dataptr[1])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_half *)dataptr[1]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1])));
#  else
    *((npy_half *)dataptr[nop]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
half_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) *
                                         npy_half_to_float(*(npy_half *)data2) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
half_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data_out = (npy_half *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                                 npy_half_to_float(data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                                 npy_half_to_float(data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                                 npy_half_to_float(data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                                 npy_half_to_float(data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                                 npy_half_to_float(data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                                 npy_half_to_float(data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                                 npy_half_to_float(data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                             npy_half_to_float(data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                             npy_half_to_float(data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                             npy_half_to_float(data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                             npy_half_to_float(data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                             npy_half_to_float(data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                             npy_half_to_float(data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                             npy_half_to_float(data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) +
                             npy_half_to_float(data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
half_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 290
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 290
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 290
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 290
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 290
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 290
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 340
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 340
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 340
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 340
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 340
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 340
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 340
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
half_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 378
        case 5+1:
            data_out[5] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 378
        case 4+1:
            data_out[4] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 378
        case 3+1:
            data_out[3] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 378
        case 2+1:
            data_out[2] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 378
        case 1+1:
            data_out[1] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 378
        case 0+1:
            data_out[0] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 469
        data_out[1] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 469
        data_out[2] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 469
        data_out[3] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 469
        data_out[4] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 469
        data_out[5] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 469
        data_out[6] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 469
        data_out[7] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
half_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                                 value1  +
                                 npy_half_to_float(data_out[6]));

#line 505
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                                 value1  +
                                 npy_half_to_float(data_out[5]));

#line 505
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                                 value1  +
                                 npy_half_to_float(data_out[4]));

#line 505
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                                 value1  +
                                 npy_half_to_float(data_out[3]));

#line 505
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                                 value1  +
                                 npy_half_to_float(data_out[2]));

#line 505
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                                 value1  +
                                 npy_half_to_float(data_out[1]));

#line 505
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                                 value1  +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                             value1  +
                             npy_half_to_float(data_out[0]));

#line 555
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                             value1  +
                             npy_half_to_float(data_out[1]));

#line 555
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                             value1  +
                             npy_half_to_float(data_out[2]));

#line 555
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                             value1  +
                             npy_half_to_float(data_out[3]));

#line 555
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                             value1  +
                             npy_half_to_float(data_out[4]));

#line 555
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                             value1  +
                             npy_half_to_float(data_out[5]));

#line 555
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                             value1  +
                             npy_half_to_float(data_out[6]));

#line 555
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7])*
                             value1  +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 591
        case 5+1:
            accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 591
        case 4+1:
            accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 591
        case 3+1:
            accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 591
        case 2+1:
            accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 591
        case 1+1:
            accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 591
        case 0+1:
            accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

#line 703
        accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 703
        accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 703
        accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 703
        accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 703
        accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 703
        accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 703
        accum += npy_half_to_float(data0[7]) * npy_half_to_float(data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += npy_half_to_float(data1[6]);

#line 749
        case 5+1:
            accum += npy_half_to_float(data1[5]);

#line 749
        case 4+1:
            accum += npy_half_to_float(data1[4]);

#line 749
        case 3+1:
            accum += npy_half_to_float(data1[3]);

#line 749
        case 2+1:
            accum += npy_half_to_float(data1[2]);

#line 749
        case 1+1:
            accum += npy_half_to_float(data1[1]);

#line 749
        case 0+1:
            accum += npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += npy_half_to_float(data1[0]);

#line 808
        accum += npy_half_to_float(data1[1]);

#line 808
        accum += npy_half_to_float(data1[2]);

#line 808
        accum += npy_half_to_float(data1[3]);

#line 808
        accum += npy_half_to_float(data1[4]);

#line 808
        accum += npy_half_to_float(data1[5]);

#line 808
        accum += npy_half_to_float(data1[6]);

#line 808
        accum += npy_half_to_float(data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += npy_half_to_float(data0[6]);

#line 848
        case 5+1:
            accum += npy_half_to_float(data0[5]);

#line 848
        case 4+1:
            accum += npy_half_to_float(data0[4]);

#line 848
        case 3+1:
            accum += npy_half_to_float(data0[3]);

#line 848
        case 2+1:
            accum += npy_half_to_float(data0[2]);

#line 848
        case 1+1:
            accum += npy_half_to_float(data0[1]);

#line 848
        case 0+1:
            accum += npy_half_to_float(data0[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += npy_half_to_float(data0[0]);

#line 907
        accum += npy_half_to_float(data0[1]);

#line 907
        accum += npy_half_to_float(data0[2]);

#line 907
        accum += npy_half_to_float(data0[3]);

#line 907
        accum += npy_half_to_float(data0[4]);

#line 907
        accum += npy_half_to_float(data0[5]);

#line 907
        accum += npy_half_to_float(data0[6]);

#line 907
        accum += npy_half_to_float(data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
half_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data2 = (npy_half *)dataptr[2];
    npy_half *data_out = (npy_half *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) *
                             npy_half_to_float(data2[0]) +
                             npy_half_to_float(data_out[0]));

#line 944
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) *
                             npy_half_to_float(data2[1]) +
                             npy_half_to_float(data_out[1]));

#line 944
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) *
                             npy_half_to_float(data2[2]) +
                             npy_half_to_float(data_out[2]));

#line 944
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) *
                             npy_half_to_float(data2[3]) +
                             npy_half_to_float(data_out[3]));

#line 944
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) *
                             npy_half_to_float(data2[4]) +
                             npy_half_to_float(data_out[4]));

#line 944
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) *
                             npy_half_to_float(data2[5]) +
                             npy_half_to_float(data_out[5]));

#line 944
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) *
                             npy_half_to_float(data2[6]) +
                             npy_half_to_float(data_out[6]));

#line 944
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) *
                             npy_half_to_float(data2[7]) +
                             npy_half_to_float(data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                         npy_half_to_float(data1[0]) *
                         npy_half_to_float(data2[0]) +
                         npy_half_to_float(data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                         npy_half_to_float(data1[1]) *
                         npy_half_to_float(data2[1]) +
                         npy_half_to_float(data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                         npy_half_to_float(data1[2]) *
                         npy_half_to_float(data2[2]) +
                         npy_half_to_float(data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                         npy_half_to_float(data1[3]) *
                         npy_half_to_float(data2[3]) +
                         npy_half_to_float(data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                         npy_half_to_float(data1[4]) *
                         npy_half_to_float(data2[4]) +
                         npy_half_to_float(data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                         npy_half_to_float(data1[5]) *
                         npy_half_to_float(data2[5]) +
                         npy_half_to_float(data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                         npy_half_to_float(data1[6]) *
                         npy_half_to_float(data2[6]) +
                         npy_half_to_float(data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                         npy_half_to_float(data1[7]) *
                         npy_half_to_float(data2[7]) +
                         npy_half_to_float(data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
half_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
half_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_half *data0 = (npy_half *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += npy_half_to_float(data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += npy_half_to_float(data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += npy_half_to_float(data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += npy_half_to_float(data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += npy_half_to_float(data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += npy_half_to_float(data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += npy_half_to_float(data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_half *)dataptr[1]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += npy_half_to_float(data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
half_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += npy_half_to_float(*(npy_half *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1) *
                 npy_half_to_float(*(npy_half *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_float *)dataptr[2])[0] += accum_re;
    ((npy_float *)dataptr[2])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_half *)dataptr[2]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[2])));
#  else
    *((npy_half *)dataptr[nop]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
half_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) *
                                         npy_half_to_float(*(npy_half *)data2) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
half_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data_out = (npy_half *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                                 npy_half_to_float(data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                                 npy_half_to_float(data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                                 npy_half_to_float(data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                                 npy_half_to_float(data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                                 npy_half_to_float(data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                                 npy_half_to_float(data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                                 npy_half_to_float(data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                             npy_half_to_float(data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                             npy_half_to_float(data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                             npy_half_to_float(data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                             npy_half_to_float(data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                             npy_half_to_float(data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                             npy_half_to_float(data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                             npy_half_to_float(data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) +
                             npy_half_to_float(data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
half_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 290
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 290
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 290
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 290
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 290
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 290
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 340
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 340
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 340
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 340
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 340
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 340
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 340
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
half_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 378
        case 5+1:
            data_out[5] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 378
        case 4+1:
            data_out[4] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 378
        case 3+1:
            data_out[3] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 378
        case 2+1:
            data_out[2] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 378
        case 1+1:
            data_out[1] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 378
        case 0+1:
            data_out[0] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 469
        data_out[1] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 469
        data_out[2] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 469
        data_out[3] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 469
        data_out[4] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 469
        data_out[5] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 469
        data_out[6] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 469
        data_out[7] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
half_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                                 value1  +
                                 npy_half_to_float(data_out[6]));

#line 505
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                                 value1  +
                                 npy_half_to_float(data_out[5]));

#line 505
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                                 value1  +
                                 npy_half_to_float(data_out[4]));

#line 505
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                                 value1  +
                                 npy_half_to_float(data_out[3]));

#line 505
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                                 value1  +
                                 npy_half_to_float(data_out[2]));

#line 505
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                                 value1  +
                                 npy_half_to_float(data_out[1]));

#line 505
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                                 value1  +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                             value1  +
                             npy_half_to_float(data_out[0]));

#line 555
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                             value1  +
                             npy_half_to_float(data_out[1]));

#line 555
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                             value1  +
                             npy_half_to_float(data_out[2]));

#line 555
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                             value1  +
                             npy_half_to_float(data_out[3]));

#line 555
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                             value1  +
                             npy_half_to_float(data_out[4]));

#line 555
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                             value1  +
                             npy_half_to_float(data_out[5]));

#line 555
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                             value1  +
                             npy_half_to_float(data_out[6]));

#line 555
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7])*
                             value1  +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 591
        case 5+1:
            accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 591
        case 4+1:
            accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 591
        case 3+1:
            accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 591
        case 2+1:
            accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 591
        case 1+1:
            accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 591
        case 0+1:
            accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

#line 703
        accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 703
        accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 703
        accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 703
        accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 703
        accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 703
        accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 703
        accum += npy_half_to_float(data0[7]) * npy_half_to_float(data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += npy_half_to_float(data1[6]);

#line 749
        case 5+1:
            accum += npy_half_to_float(data1[5]);

#line 749
        case 4+1:
            accum += npy_half_to_float(data1[4]);

#line 749
        case 3+1:
            accum += npy_half_to_float(data1[3]);

#line 749
        case 2+1:
            accum += npy_half_to_float(data1[2]);

#line 749
        case 1+1:
            accum += npy_half_to_float(data1[1]);

#line 749
        case 0+1:
            accum += npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += npy_half_to_float(data1[0]);

#line 808
        accum += npy_half_to_float(data1[1]);

#line 808
        accum += npy_half_to_float(data1[2]);

#line 808
        accum += npy_half_to_float(data1[3]);

#line 808
        accum += npy_half_to_float(data1[4]);

#line 808
        accum += npy_half_to_float(data1[5]);

#line 808
        accum += npy_half_to_float(data1[6]);

#line 808
        accum += npy_half_to_float(data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += npy_half_to_float(data0[6]);

#line 848
        case 5+1:
            accum += npy_half_to_float(data0[5]);

#line 848
        case 4+1:
            accum += npy_half_to_float(data0[4]);

#line 848
        case 3+1:
            accum += npy_half_to_float(data0[3]);

#line 848
        case 2+1:
            accum += npy_half_to_float(data0[2]);

#line 848
        case 1+1:
            accum += npy_half_to_float(data0[1]);

#line 848
        case 0+1:
            accum += npy_half_to_float(data0[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += npy_half_to_float(data0[0]);

#line 907
        accum += npy_half_to_float(data0[1]);

#line 907
        accum += npy_half_to_float(data0[2]);

#line 907
        accum += npy_half_to_float(data0[3]);

#line 907
        accum += npy_half_to_float(data0[4]);

#line 907
        accum += npy_half_to_float(data0[5]);

#line 907
        accum += npy_half_to_float(data0[6]);

#line 907
        accum += npy_half_to_float(data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
half_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data2 = (npy_half *)dataptr[2];
    npy_half *data_out = (npy_half *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) *
                             npy_half_to_float(data2[0]) +
                             npy_half_to_float(data_out[0]));

#line 944
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) *
                             npy_half_to_float(data2[1]) +
                             npy_half_to_float(data_out[1]));

#line 944
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) *
                             npy_half_to_float(data2[2]) +
                             npy_half_to_float(data_out[2]));

#line 944
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) *
                             npy_half_to_float(data2[3]) +
                             npy_half_to_float(data_out[3]));

#line 944
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) *
                             npy_half_to_float(data2[4]) +
                             npy_half_to_float(data_out[4]));

#line 944
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) *
                             npy_half_to_float(data2[5]) +
                             npy_half_to_float(data_out[5]));

#line 944
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) *
                             npy_half_to_float(data2[6]) +
                             npy_half_to_float(data_out[6]));

#line 944
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) *
                             npy_half_to_float(data2[7]) +
                             npy_half_to_float(data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                         npy_half_to_float(data1[0]) *
                         npy_half_to_float(data2[0]) +
                         npy_half_to_float(data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                         npy_half_to_float(data1[1]) *
                         npy_half_to_float(data2[1]) +
                         npy_half_to_float(data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                         npy_half_to_float(data1[2]) *
                         npy_half_to_float(data2[2]) +
                         npy_half_to_float(data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                         npy_half_to_float(data1[3]) *
                         npy_half_to_float(data2[3]) +
                         npy_half_to_float(data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                         npy_half_to_float(data1[4]) *
                         npy_half_to_float(data2[4]) +
                         npy_half_to_float(data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                         npy_half_to_float(data1[5]) *
                         npy_half_to_float(data2[5]) +
                         npy_half_to_float(data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                         npy_half_to_float(data1[6]) *
                         npy_half_to_float(data2[6]) +
                         npy_half_to_float(data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                         npy_half_to_float(data1[7]) *
                         npy_half_to_float(data2[7]) +
                         npy_half_to_float(data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
half_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
half_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_half *data0 = (npy_half *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += npy_half_to_float(data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += npy_half_to_float(data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += npy_half_to_float(data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += npy_half_to_float(data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += npy_half_to_float(data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += npy_half_to_float(data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += npy_half_to_float(data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_half *)dataptr[1]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += npy_half_to_float(data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
half_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += npy_half_to_float(*(npy_half *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1) *
                 npy_half_to_float(*(npy_half *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_float *)dataptr[3])[0] += accum_re;
    ((npy_float *)dataptr[3])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_half *)dataptr[3]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[3])));
#  else
    *((npy_half *)dataptr[nop]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
half_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_half *)data_out = npy_float_to_half(npy_half_to_float(*(npy_half *)data0) *
                                         npy_half_to_float(*(npy_half *)data1) *
                                         npy_half_to_float(*(npy_half *)data2) +
                                         npy_half_to_float(*(npy_half *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
half_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data_out = (npy_half *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                                 npy_half_to_float(data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                                 npy_half_to_float(data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                                 npy_half_to_float(data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                                 npy_half_to_float(data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                                 npy_half_to_float(data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                                 npy_half_to_float(data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                                 npy_half_to_float(data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) +
                             npy_half_to_float(data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) +
                             npy_half_to_float(data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) +
                             npy_half_to_float(data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) +
                             npy_half_to_float(data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) +
                             npy_half_to_float(data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) +
                             npy_half_to_float(data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) +
                             npy_half_to_float(data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) +
                             npy_half_to_float(data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
half_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 290
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 290
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 290
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 290
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 290
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 290
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 340
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 340
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 340
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 340
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 340
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 340
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 340
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
half_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[6]) +
                                 npy_half_to_float(data_out[6]));

#line 378
        case 5+1:
            data_out[5] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[5]) +
                                 npy_half_to_float(data_out[5]));

#line 378
        case 4+1:
            data_out[4] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[4]) +
                                 npy_half_to_float(data_out[4]));

#line 378
        case 3+1:
            data_out[3] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[3]) +
                                 npy_half_to_float(data_out[3]));

#line 378
        case 2+1:
            data_out[2] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[2]) +
                                 npy_half_to_float(data_out[2]));

#line 378
        case 1+1:
            data_out[1] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[1]) +
                                 npy_half_to_float(data_out[1]));

#line 378
        case 0+1:
            data_out[0] = npy_float_to_half(value0 *
                                 npy_half_to_float(data1[0]) +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[0]) +
                             npy_half_to_float(data_out[0]));

#line 469
        data_out[1] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[1]) +
                             npy_half_to_float(data_out[1]));

#line 469
        data_out[2] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[2]) +
                             npy_half_to_float(data_out[2]));

#line 469
        data_out[3] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[3]) +
                             npy_half_to_float(data_out[3]));

#line 469
        data_out[4] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[4]) +
                             npy_half_to_float(data_out[4]));

#line 469
        data_out[5] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[5]) +
                             npy_half_to_float(data_out[5]));

#line 469
        data_out[6] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[6]) +
                             npy_half_to_float(data_out[6]));

#line 469
        data_out[7] = npy_float_to_half(value0 *
                             npy_half_to_float(data1[7]) +
                             npy_half_to_float(data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
half_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_half *data_out = (npy_half *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                                 value1  +
                                 npy_half_to_float(data_out[6]));

#line 505
        case 5+1:
            data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                                 value1  +
                                 npy_half_to_float(data_out[5]));

#line 505
        case 4+1:
            data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                                 value1  +
                                 npy_half_to_float(data_out[4]));

#line 505
        case 3+1:
            data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                                 value1  +
                                 npy_half_to_float(data_out[3]));

#line 505
        case 2+1:
            data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                                 value1  +
                                 npy_half_to_float(data_out[2]));

#line 505
        case 1+1:
            data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                                 value1  +
                                 npy_half_to_float(data_out[1]));

#line 505
        case 0+1:
            data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                                 value1  +
                                 npy_half_to_float(data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0])*
                             value1  +
                             npy_half_to_float(data_out[0]));

#line 555
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1])*
                             value1  +
                             npy_half_to_float(data_out[1]));

#line 555
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2])*
                             value1  +
                             npy_half_to_float(data_out[2]));

#line 555
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3])*
                             value1  +
                             npy_half_to_float(data_out[3]));

#line 555
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4])*
                             value1  +
                             npy_half_to_float(data_out[4]));

#line 555
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5])*
                             value1  +
                             npy_half_to_float(data_out[5]));

#line 555
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6])*
                             value1  +
                             npy_half_to_float(data_out[6]));

#line 555
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7])*
                             value1  +
                             npy_half_to_float(data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 591
        case 5+1:
            accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 591
        case 4+1:
            accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 591
        case 3+1:
            accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 591
        case 2+1:
            accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 591
        case 1+1:
            accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 591
        case 0+1:
            accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += npy_half_to_float(data0[0]) * npy_half_to_float(data1[0]);

#line 703
        accum += npy_half_to_float(data0[1]) * npy_half_to_float(data1[1]);

#line 703
        accum += npy_half_to_float(data0[2]) * npy_half_to_float(data1[2]);

#line 703
        accum += npy_half_to_float(data0[3]) * npy_half_to_float(data1[3]);

#line 703
        accum += npy_half_to_float(data0[4]) * npy_half_to_float(data1[4]);

#line 703
        accum += npy_half_to_float(data0[5]) * npy_half_to_float(data1[5]);

#line 703
        accum += npy_half_to_float(data0[6]) * npy_half_to_float(data1[6]);

#line 703
        accum += npy_half_to_float(data0[7]) * npy_half_to_float(data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = npy_half_to_float(*(npy_half *)dataptr[0]);
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += npy_half_to_float(data1[6]);

#line 749
        case 5+1:
            accum += npy_half_to_float(data1[5]);

#line 749
        case 4+1:
            accum += npy_half_to_float(data1[4]);

#line 749
        case 3+1:
            accum += npy_half_to_float(data1[3]);

#line 749
        case 2+1:
            accum += npy_half_to_float(data1[2]);

#line 749
        case 1+1:
            accum += npy_half_to_float(data1[1]);

#line 749
        case 0+1:
            accum += npy_half_to_float(data1[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += npy_half_to_float(data1[0]);

#line 808
        accum += npy_half_to_float(data1[1]);

#line 808
        accum += npy_half_to_float(data1[2]);

#line 808
        accum += npy_half_to_float(data1[3]);

#line 808
        accum += npy_half_to_float(data1[4]);

#line 808
        accum += npy_half_to_float(data1[5]);

#line 808
        accum += npy_half_to_float(data1[6]);

#line 808
        accum += npy_half_to_float(data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
half_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_float value1 = npy_half_to_float(*(npy_half *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += npy_half_to_float(data0[6]);

#line 848
        case 5+1:
            accum += npy_half_to_float(data0[5]);

#line 848
        case 4+1:
            accum += npy_half_to_float(data0[4]);

#line 848
        case 3+1:
            accum += npy_half_to_float(data0[3]);

#line 848
        case 2+1:
            accum += npy_half_to_float(data0[2]);

#line 848
        case 1+1:
            accum += npy_half_to_float(data0[1]);

#line 848
        case 0+1:
            accum += npy_half_to_float(data0[0]);

        case 0:
            *(npy_half *)dataptr[2] = npy_float_to_half(npy_half_to_float(*(npy_half *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += npy_half_to_float(data0[0]);

#line 907
        accum += npy_half_to_float(data0[1]);

#line 907
        accum += npy_half_to_float(data0[2]);

#line 907
        accum += npy_half_to_float(data0[3]);

#line 907
        accum += npy_half_to_float(data0[4]);

#line 907
        accum += npy_half_to_float(data0[5]);

#line 907
        accum += npy_half_to_float(data0[6]);

#line 907
        accum += npy_half_to_float(data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
half_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_half *data0 = (npy_half *)dataptr[0];
    npy_half *data1 = (npy_half *)dataptr[1];
    npy_half *data2 = (npy_half *)dataptr[2];
    npy_half *data_out = (npy_half *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                             npy_half_to_float(data1[0]) *
                             npy_half_to_float(data2[0]) +
                             npy_half_to_float(data_out[0]));

#line 944
        data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                             npy_half_to_float(data1[1]) *
                             npy_half_to_float(data2[1]) +
                             npy_half_to_float(data_out[1]));

#line 944
        data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                             npy_half_to_float(data1[2]) *
                             npy_half_to_float(data2[2]) +
                             npy_half_to_float(data_out[2]));

#line 944
        data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                             npy_half_to_float(data1[3]) *
                             npy_half_to_float(data2[3]) +
                             npy_half_to_float(data_out[3]));

#line 944
        data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                             npy_half_to_float(data1[4]) *
                             npy_half_to_float(data2[4]) +
                             npy_half_to_float(data_out[4]));

#line 944
        data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                             npy_half_to_float(data1[5]) *
                             npy_half_to_float(data2[5]) +
                             npy_half_to_float(data_out[5]));

#line 944
        data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                             npy_half_to_float(data1[6]) *
                             npy_half_to_float(data2[6]) +
                             npy_half_to_float(data_out[6]));

#line 944
        data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                             npy_half_to_float(data1[7]) *
                             npy_half_to_float(data2[7]) +
                             npy_half_to_float(data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = npy_float_to_half(npy_half_to_float(data0[0]) *
                         npy_half_to_float(data1[0]) *
                         npy_half_to_float(data2[0]) +
                         npy_half_to_float(data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = npy_float_to_half(npy_half_to_float(data0[1]) *
                         npy_half_to_float(data1[1]) *
                         npy_half_to_float(data2[1]) +
                         npy_half_to_float(data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = npy_float_to_half(npy_half_to_float(data0[2]) *
                         npy_half_to_float(data1[2]) *
                         npy_half_to_float(data2[2]) +
                         npy_half_to_float(data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = npy_float_to_half(npy_half_to_float(data0[3]) *
                         npy_half_to_float(data1[3]) *
                         npy_half_to_float(data2[3]) +
                         npy_half_to_float(data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = npy_float_to_half(npy_half_to_float(data0[4]) *
                         npy_half_to_float(data1[4]) *
                         npy_half_to_float(data2[4]) +
                         npy_half_to_float(data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = npy_float_to_half(npy_half_to_float(data0[5]) *
                         npy_half_to_float(data1[5]) *
                         npy_half_to_float(data2[5]) +
                         npy_half_to_float(data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = npy_float_to_half(npy_half_to_float(data0[6]) *
                         npy_half_to_float(data1[6]) *
                         npy_half_to_float(data2[6]) +
                         npy_half_to_float(data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = npy_float_to_half(npy_half_to_float(data0[7]) *
                         npy_half_to_float(data1[7]) *
                         npy_half_to_float(data2[7]) +
                         npy_half_to_float(data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
half_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        *(npy_half *)dataptr[nop] = npy_float_to_half(temp +
                                           npy_half_to_float(*(npy_half *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_half);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
half_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_half *data0 = (npy_half *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += npy_half_to_float(data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += npy_half_to_float(data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += npy_half_to_float(data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += npy_half_to_float(data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += npy_half_to_float(data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += npy_half_to_float(data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += npy_half_to_float(data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_half *)dataptr[1]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += npy_half_to_float(data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += npy_half_to_float(data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
half_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("half_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += npy_half_to_float(*(npy_half *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += npy_half_to_float(*(npy_half *)data0) *
                 npy_half_to_float(*(npy_half *)data1) *
                 npy_half_to_float(*(npy_half *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = npy_half_to_float(*(npy_half *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= npy_half_to_float(*(npy_half *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_float *)dataptr[1000])[0] += accum_re;
    ((npy_float *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_half *)dataptr[1000]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[1000])));
#  else
    *((npy_half *)dataptr[nop]) = npy_float_to_half(accum +
                                    npy_half_to_float(*((npy_half *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
float_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_float *)data_out = ((*(npy_float *)data0) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) *
                                         (*(npy_float *)data2) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
float_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data_out = (npy_float *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
float_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
float_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
float_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
float_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data2 = (npy_float *)dataptr[2];
    npy_float *data_out = (npy_float *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
float_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
float_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_float *)dataptr[1]) = (accum +
                                    (*((npy_float *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
float_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_float *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1) *
                 (*(npy_float *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_float *)dataptr[1])[0] += accum_re;
    ((npy_float *)dataptr[1])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_float *)dataptr[1]) = (accum +
                                    (*((npy_float *)dataptr[1])));
#  else
    *((npy_float *)dataptr[nop]) = (accum +
                                    (*((npy_float *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
float_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_float *)data_out = ((*(npy_float *)data0) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) *
                                         (*(npy_float *)data2) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
float_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data_out = (npy_float *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
float_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
float_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
float_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
float_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data2 = (npy_float *)dataptr[2];
    npy_float *data_out = (npy_float *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
float_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
float_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_float *)dataptr[1]) = (accum +
                                    (*((npy_float *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
float_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_float *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1) *
                 (*(npy_float *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_float *)dataptr[2])[0] += accum_re;
    ((npy_float *)dataptr[2])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_float *)dataptr[2]) = (accum +
                                    (*((npy_float *)dataptr[2])));
#  else
    *((npy_float *)dataptr[nop]) = (accum +
                                    (*((npy_float *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
float_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_float *)data_out = ((*(npy_float *)data0) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) *
                                         (*(npy_float *)data2) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
float_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data_out = (npy_float *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
float_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
float_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
float_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
float_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data2 = (npy_float *)dataptr[2];
    npy_float *data_out = (npy_float *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
float_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
float_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_float *)dataptr[1]) = (accum +
                                    (*((npy_float *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
float_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_float *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1) *
                 (*(npy_float *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_float *)dataptr[3])[0] += accum_re;
    ((npy_float *)dataptr[3])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_float *)dataptr[3]) = (accum +
                                    (*((npy_float *)dataptr[3])));
#  else
    *((npy_float *)dataptr[nop]) = (accum +
                                    (*((npy_float *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
float_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_float *)data_out = ((*(npy_float *)data0) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_float *)data_out = ((*(npy_float *)data0) *
                                         (*(npy_float *)data1) *
                                         (*(npy_float *)data2) +
                                         (*(npy_float *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
float_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data_out = (npy_float *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
float_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
float_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
float_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float *data_out = (npy_float *)dataptr[2];

#if EINSUM_USE_SSE1 && 1
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 1
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_float *)dataptr[0]);
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
float_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float value1 = (*(npy_float *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_float *)dataptr[2] = ((*(npy_float *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 1
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
float_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float *data0 = (npy_float *)dataptr[0];
    npy_float *data1 = (npy_float *)dataptr[1];
    npy_float *data2 = (npy_float *)dataptr[2];
    npy_float *data_out = (npy_float *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
float_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        *(npy_float *)dataptr[nop] = (temp +
                                           (*(npy_float *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_float);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
float_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 1
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_float *)dataptr[1]) = (accum +
                                    (*((npy_float *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 1
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
float_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("float_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_float *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_float *)data0) *
                 (*(npy_float *)data1) *
                 (*(npy_float *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_float *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_float *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_float *)dataptr[1000])[0] += accum_re;
    ((npy_float *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_float *)dataptr[1000]) = (accum +
                                    (*((npy_float *)dataptr[1000])));
#  else
    *((npy_float *)dataptr[nop]) = (accum +
                                    (*((npy_float *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
double_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_double *)data_out = ((*(npy_double *)data0) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) *
                                         (*(npy_double *)data2) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
double_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data_out = (npy_double *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
double_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
double_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 1
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 1
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 1
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
double_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
double_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data2 = (npy_double *)dataptr[2];
    npy_double *data_out = (npy_double *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
double_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
double_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_double *)dataptr[1]) = (accum +
                                    (*((npy_double *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
double_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_double *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1) *
                 (*(npy_double *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_double *)dataptr[1])[0] += accum_re;
    ((npy_double *)dataptr[1])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_double *)dataptr[1]) = (accum +
                                    (*((npy_double *)dataptr[1])));
#  else
    *((npy_double *)dataptr[nop]) = (accum +
                                    (*((npy_double *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
double_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_double *)data_out = ((*(npy_double *)data0) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) *
                                         (*(npy_double *)data2) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
double_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data_out = (npy_double *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
double_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
double_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 1
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 1
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 1
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
double_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
double_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data2 = (npy_double *)dataptr[2];
    npy_double *data_out = (npy_double *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
double_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
double_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_double *)dataptr[1]) = (accum +
                                    (*((npy_double *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
double_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_double *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1) *
                 (*(npy_double *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_double *)dataptr[2])[0] += accum_re;
    ((npy_double *)dataptr[2])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_double *)dataptr[2]) = (accum +
                                    (*((npy_double *)dataptr[2])));
#  else
    *((npy_double *)dataptr[nop]) = (accum +
                                    (*((npy_double *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
double_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_double *)data_out = ((*(npy_double *)data0) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) *
                                         (*(npy_double *)data2) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
double_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data_out = (npy_double *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
double_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
double_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 1
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 1
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 1
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
double_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
double_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data2 = (npy_double *)dataptr[2];
    npy_double *data_out = (npy_double *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
double_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
double_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_double *)dataptr[1]) = (accum +
                                    (*((npy_double *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
double_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_double *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1) *
                 (*(npy_double *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_double *)dataptr[3])[0] += accum_re;
    ((npy_double *)dataptr[3])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_double *)dataptr[3]) = (accum +
                                    (*((npy_double *)dataptr[3])));
#  else
    *((npy_double *)dataptr[nop]) = (accum +
                                    (*((npy_double *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
double_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_double *)data_out = ((*(npy_double *)data0) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_double *)data_out = ((*(npy_double *)data0) *
                                         (*(npy_double *)data1) *
                                         (*(npy_double *)data2) +
                                         (*(npy_double *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
double_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data_out = (npy_double *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
double_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
double_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 1
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 1
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 1
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
double_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double *data_out = (npy_double *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_double *)dataptr[0]);
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
double_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double value1 = (*(npy_double *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_double *)dataptr[2] = ((*(npy_double *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
double_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double *data0 = (npy_double *)dataptr[0];
    npy_double *data1 = (npy_double *)dataptr[1];
    npy_double *data2 = (npy_double *)dataptr[2];
    npy_double *data_out = (npy_double *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
double_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        *(npy_double *)dataptr[nop] = (temp +
                                           (*(npy_double *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_double);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
double_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 1
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_double *)dataptr[1]) = (accum +
                                    (*((npy_double *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 1
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 1
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 1
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
double_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("double_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_double *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_double *)data0) *
                 (*(npy_double *)data1) *
                 (*(npy_double *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_double *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_double *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_double *)dataptr[1000])[0] += accum_re;
    ((npy_double *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_double *)dataptr[1000]) = (accum +
                                    (*((npy_double *)dataptr[1000])));
#  else
    *((npy_double *)dataptr[nop]) = (accum +
                                    (*((npy_double *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
longdouble_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !0)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) *
                                         (*(npy_longdouble *)data2) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
longdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !0

static void
longdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !0

static void
longdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data2 = (npy_longdouble *)dataptr[2];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
longdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
longdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_longdouble *)dataptr[1]) = (accum +
                                    (*((npy_longdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
longdouble_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1 == 1
        accum += (*(npy_longdouble *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1) *
                 (*(npy_longdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1 <= 3
    ((npy_longdouble *)dataptr[1])[0] += accum_re;
    ((npy_longdouble *)dataptr[1])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_longdouble *)dataptr[1]) = (accum +
                                    (*((npy_longdouble *)dataptr[1])));
#  else
    *((npy_longdouble *)dataptr[nop]) = (accum +
                                    (*((npy_longdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longdouble_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !0)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) *
                                         (*(npy_longdouble *)data2) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
longdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !0

static void
longdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !0

static void
longdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data2 = (npy_longdouble *)dataptr[2];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
longdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
longdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_longdouble *)dataptr[1]) = (accum +
                                    (*((npy_longdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
longdouble_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 2 == 1
        accum += (*(npy_longdouble *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1) *
                 (*(npy_longdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 2 <= 3
    ((npy_longdouble *)dataptr[2])[0] += accum_re;
    ((npy_longdouble *)dataptr[2])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_longdouble *)dataptr[2]) = (accum +
                                    (*((npy_longdouble *)dataptr[2])));
#  else
    *((npy_longdouble *)dataptr[nop]) = (accum +
                                    (*((npy_longdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longdouble_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !0)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) *
                                         (*(npy_longdouble *)data2) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
longdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !0

static void
longdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !0

static void
longdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data2 = (npy_longdouble *)dataptr[2];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
longdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
longdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_longdouble *)dataptr[1]) = (accum +
                                    (*((npy_longdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
longdouble_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 3 == 1
        accum += (*(npy_longdouble *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1) *
                 (*(npy_longdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 3 <= 3
    ((npy_longdouble *)dataptr[3])[0] += accum_re;
    ((npy_longdouble *)dataptr[3])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_longdouble *)dataptr[3]) = (accum +
                                    (*((npy_longdouble *)dataptr[3])));
#  else
    *((npy_longdouble *)dataptr[nop]) = (accum +
                                    (*((npy_longdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
longdouble_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !0)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_longdouble *)data_out = ((*(npy_longdouble *)data0) *
                                         (*(npy_longdouble *)data1) *
                                         (*(npy_longdouble *)data2) +
                                         (*(npy_longdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
longdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !0
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !0
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !0
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !0
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !0
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !0
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !0
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !0
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !0
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !0
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !0
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !0
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !0
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !0
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !0
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !0

static void
longdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
longdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
longdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble *data_out = (npy_longdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_longdouble *)dataptr[0]);
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
longdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_longdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_longdouble *)dataptr[2] = ((*(npy_longdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !0

static void
longdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
    npy_longdouble *data1 = (npy_longdouble *)dataptr[1];
    npy_longdouble *data2 = (npy_longdouble *)dataptr[2];
    npy_longdouble *data_out = (npy_longdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
longdouble_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        *(npy_longdouble *)dataptr[nop] = (temp +
                                           (*(npy_longdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_longdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
longdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !0
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !0
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !0
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !0
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !0
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !0
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !0
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 0
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_longdouble *)dataptr[1]) = (accum +
                                    (*((npy_longdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !0
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !0
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !0
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !0
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !0
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !0
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !0
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !0
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !0
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
longdouble_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 0
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !0)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !0
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !0
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("longdouble_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !0
#  if 1000 == 1
        accum += (*(npy_longdouble *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_longdouble *)data0) *
                 (*(npy_longdouble *)data1) *
                 (*(npy_longdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_longdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_longdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 0
#  if 1000 <= 3
    ((npy_longdouble *)dataptr[1000])[0] += accum_re;
    ((npy_longdouble *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_longdouble *)dataptr[1000]) = (accum +
                                    (*((npy_longdouble *)dataptr[1000])));
#  else
    *((npy_longdouble *)dataptr[nop]) = (accum +
                                    (*((npy_longdouble *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
cfloat_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !1)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) *
                                         (*(npy_cfloat *)data2) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
cfloat_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !1

static void
cfloat_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cfloat_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cfloat_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !1

static void
cfloat_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data2 = (npy_cfloat *)dataptr[2];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
cfloat_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
cfloat_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_cfloat *)dataptr[1]) = (accum +
                                    (*((npy_cfloat *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
cfloat_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        accum += (*(npy_cfloat *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1) *
                 (*(npy_cfloat *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1 <= 3
    ((npy_float *)dataptr[1])[0] += accum_re;
    ((npy_float *)dataptr[1])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_cfloat *)dataptr[1]) = (accum +
                                    (*((npy_cfloat *)dataptr[1])));
#  else
    *((npy_cfloat *)dataptr[nop]) = (accum +
                                    (*((npy_cfloat *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cfloat_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !1)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) *
                                         (*(npy_cfloat *)data2) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
cfloat_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !1

static void
cfloat_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cfloat_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cfloat_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !1

static void
cfloat_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data2 = (npy_cfloat *)dataptr[2];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
cfloat_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
cfloat_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_cfloat *)dataptr[1]) = (accum +
                                    (*((npy_cfloat *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
cfloat_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        accum += (*(npy_cfloat *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1) *
                 (*(npy_cfloat *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 2 <= 3
    ((npy_float *)dataptr[2])[0] += accum_re;
    ((npy_float *)dataptr[2])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_cfloat *)dataptr[2]) = (accum +
                                    (*((npy_cfloat *)dataptr[2])));
#  else
    *((npy_cfloat *)dataptr[nop]) = (accum +
                                    (*((npy_cfloat *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cfloat_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !1)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) *
                                         (*(npy_cfloat *)data2) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
cfloat_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !1

static void
cfloat_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cfloat_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cfloat_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !1

static void
cfloat_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data2 = (npy_cfloat *)dataptr[2];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
cfloat_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
cfloat_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_cfloat *)dataptr[1]) = (accum +
                                    (*((npy_cfloat *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
cfloat_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        accum += (*(npy_cfloat *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1) *
                 (*(npy_cfloat *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 3 <= 3
    ((npy_float *)dataptr[3])[0] += accum_re;
    ((npy_float *)dataptr[3])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_cfloat *)dataptr[3]) = (accum +
                                    (*((npy_cfloat *)dataptr[3])));
#  else
    *((npy_cfloat *)dataptr[nop]) = (accum +
                                    (*((npy_cfloat *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cfloat_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_cfloat *)data_out = ((*(npy_cfloat *)data0) *
                                         (*(npy_cfloat *)data1) *
                                         (*(npy_cfloat *)data2) +
                                         (*(npy_cfloat *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_float *)data_out)[0] = ((npy_float *)data0)[0] +
                                         ((npy_float *)data_out)[0];
        ((npy_float *)data_out)[1] = ((npy_float *)data0)[1] +
                                         ((npy_float *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
cfloat_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_float *)data_out + 2*6)[0] =
                                    ((npy_float *)data0 + 2*6)[0] +
                                    ((npy_float *)data_out + 2*6)[0];
            ((npy_float *)data_out + 2*6)[1] =
                                    ((npy_float *)data0 + 2*6)[1] +
                                    ((npy_float *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_float *)data_out + 2*5)[0] =
                                    ((npy_float *)data0 + 2*5)[0] +
                                    ((npy_float *)data_out + 2*5)[0];
            ((npy_float *)data_out + 2*5)[1] =
                                    ((npy_float *)data0 + 2*5)[1] +
                                    ((npy_float *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_float *)data_out + 2*4)[0] =
                                    ((npy_float *)data0 + 2*4)[0] +
                                    ((npy_float *)data_out + 2*4)[0];
            ((npy_float *)data_out + 2*4)[1] =
                                    ((npy_float *)data0 + 2*4)[1] +
                                    ((npy_float *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_float *)data_out + 2*3)[0] =
                                    ((npy_float *)data0 + 2*3)[0] +
                                    ((npy_float *)data_out + 2*3)[0];
            ((npy_float *)data_out + 2*3)[1] =
                                    ((npy_float *)data0 + 2*3)[1] +
                                    ((npy_float *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_float *)data_out + 2*2)[0] =
                                    ((npy_float *)data0 + 2*2)[0] +
                                    ((npy_float *)data_out + 2*2)[0];
            ((npy_float *)data_out + 2*2)[1] =
                                    ((npy_float *)data0 + 2*2)[1] +
                                    ((npy_float *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_float *)data_out + 2*1)[0] =
                                    ((npy_float *)data0 + 2*1)[0] +
                                    ((npy_float *)data_out + 2*1)[0];
            ((npy_float *)data_out + 2*1)[1] =
                                    ((npy_float *)data0 + 2*1)[1] +
                                    ((npy_float *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_float *)data_out + 2*0)[0] =
                                    ((npy_float *)data0 + 2*0)[0] +
                                    ((npy_float *)data_out + 2*0)[0];
            ((npy_float *)data_out + 2*0)[1] =
                                    ((npy_float *)data0 + 2*0)[1] +
                                    ((npy_float *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_float *)data_out + 2*0)[0] =
                                ((npy_float *)data0 + 2*0)[0] +
                                ((npy_float *)data_out + 2*0)[0];
        ((npy_float *)data_out + 2*0)[1] =
                                ((npy_float *)data0 + 2*0)[1] +
                                ((npy_float *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_float *)data_out + 2*1)[0] =
                                ((npy_float *)data0 + 2*1)[0] +
                                ((npy_float *)data_out + 2*1)[0];
        ((npy_float *)data_out + 2*1)[1] =
                                ((npy_float *)data0 + 2*1)[1] +
                                ((npy_float *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_float *)data_out + 2*2)[0] =
                                ((npy_float *)data0 + 2*2)[0] +
                                ((npy_float *)data_out + 2*2)[0];
        ((npy_float *)data_out + 2*2)[1] =
                                ((npy_float *)data0 + 2*2)[1] +
                                ((npy_float *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_float *)data_out + 2*3)[0] =
                                ((npy_float *)data0 + 2*3)[0] +
                                ((npy_float *)data_out + 2*3)[0];
        ((npy_float *)data_out + 2*3)[1] =
                                ((npy_float *)data0 + 2*3)[1] +
                                ((npy_float *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_float *)data_out + 2*4)[0] =
                                ((npy_float *)data0 + 2*4)[0] +
                                ((npy_float *)data_out + 2*4)[0];
        ((npy_float *)data_out + 2*4)[1] =
                                ((npy_float *)data0 + 2*4)[1] +
                                ((npy_float *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_float *)data_out + 2*5)[0] =
                                ((npy_float *)data0 + 2*5)[0] +
                                ((npy_float *)data_out + 2*5)[0];
        ((npy_float *)data_out + 2*5)[1] =
                                ((npy_float *)data0 + 2*5)[1] +
                                ((npy_float *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_float *)data_out + 2*6)[0] =
                                ((npy_float *)data0 + 2*6)[0] +
                                ((npy_float *)data_out + 2*6)[0];
        ((npy_float *)data_out + 2*6)[1] =
                                ((npy_float *)data0 + 2*6)[1] +
                                ((npy_float *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_float *)data_out + 2*7)[0] =
                                ((npy_float *)data0 + 2*7)[0] +
                                ((npy_float *)data_out + 2*7)[0];
        ((npy_float *)data_out + 2*7)[1] =
                                ((npy_float *)data0 + 2*7)[1] +
                                ((npy_float *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !1

static void
cfloat_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cfloat_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cfloat_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_cfloat *data_out = (npy_cfloat *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_float value0 = (*(npy_cfloat *)dataptr[0]);
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cfloat_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_float value1 = (*(npy_cfloat *)dataptr[1]);
    npy_float accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cfloat *)dataptr[2] = ((*(npy_cfloat *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !1

static void
cfloat_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
    npy_cfloat *data1 = (npy_cfloat *)dataptr[1];
    npy_cfloat *data2 = (npy_cfloat *)dataptr[2];
    npy_cfloat *data_out = (npy_cfloat *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
cfloat_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        *(npy_cfloat *)dataptr[nop] = (temp +
                                           (*(npy_cfloat *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_float *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[0];
        ((npy_float *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_float *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cfloat);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
cfloat_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
    npy_float *data0 = (npy_float *)dataptr[0];
#else
    npy_float accum = 0;
    npy_cfloat *data0 = (npy_cfloat *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_float *)dataptr[1])[0] += accum_re;
            ((npy_float *)dataptr[1])[1] += accum_im;
#else
            *((npy_cfloat *)dataptr[1]) = (accum +
                                    (*((npy_cfloat *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
cfloat_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_float accum_re = 0, accum_im = 0;
#else
    npy_float accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cfloat_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        accum += (*(npy_cfloat *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_cfloat *)data0) *
                 (*(npy_cfloat *)data1) *
                 (*(npy_cfloat *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_float temp = (*(npy_cfloat *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cfloat *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_float *)data0)[0];
        accum_im += ((npy_float *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_float re, im, tmp;
        int i;
        re = ((npy_float *)dataptr[0])[0];
        im = ((npy_float *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_float *)dataptr[i])[0] -
                  im * ((npy_float *)dataptr[i])[1];
            im = re * ((npy_float *)dataptr[i])[1] +
                 im * ((npy_float *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1000 <= 3
    ((npy_float *)dataptr[1000])[0] += accum_re;
    ((npy_float *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_float *)dataptr[nop])[0] += accum_re;
    ((npy_float *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_cfloat *)dataptr[1000]) = (accum +
                                    (*((npy_cfloat *)dataptr[1000])));
#  else
    *((npy_cfloat *)dataptr[nop]) = (accum +
                                    (*((npy_cfloat *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
cdouble_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !1)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) *
                                         (*(npy_cdouble *)data2) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
cdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !1

static void
cdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !1

static void
cdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data2 = (npy_cdouble *)dataptr[2];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
cdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
cdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_cdouble *)dataptr[1]) = (accum +
                                    (*((npy_cdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
cdouble_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        accum += (*(npy_cdouble *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1) *
                 (*(npy_cdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1 <= 3
    ((npy_double *)dataptr[1])[0] += accum_re;
    ((npy_double *)dataptr[1])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_cdouble *)dataptr[1]) = (accum +
                                    (*((npy_cdouble *)dataptr[1])));
#  else
    *((npy_cdouble *)dataptr[nop]) = (accum +
                                    (*((npy_cdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cdouble_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !1)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) *
                                         (*(npy_cdouble *)data2) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
cdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !1

static void
cdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !1

static void
cdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data2 = (npy_cdouble *)dataptr[2];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
cdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
cdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_cdouble *)dataptr[1]) = (accum +
                                    (*((npy_cdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
cdouble_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        accum += (*(npy_cdouble *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1) *
                 (*(npy_cdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 2 <= 3
    ((npy_double *)dataptr[2])[0] += accum_re;
    ((npy_double *)dataptr[2])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_cdouble *)dataptr[2]) = (accum +
                                    (*((npy_cdouble *)dataptr[2])));
#  else
    *((npy_cdouble *)dataptr[nop]) = (accum +
                                    (*((npy_cdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cdouble_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !1)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) *
                                         (*(npy_cdouble *)data2) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
cdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !1

static void
cdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !1

static void
cdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data2 = (npy_cdouble *)dataptr[2];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
cdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
cdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_cdouble *)dataptr[1]) = (accum +
                                    (*((npy_cdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
cdouble_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        accum += (*(npy_cdouble *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1) *
                 (*(npy_cdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 3 <= 3
    ((npy_double *)dataptr[3])[0] += accum_re;
    ((npy_double *)dataptr[3])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_cdouble *)dataptr[3]) = (accum +
                                    (*((npy_cdouble *)dataptr[3])));
#  else
    *((npy_cdouble *)dataptr[nop]) = (accum +
                                    (*((npy_cdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
cdouble_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_cdouble *)data_out = ((*(npy_cdouble *)data0) *
                                         (*(npy_cdouble *)data1) *
                                         (*(npy_cdouble *)data2) +
                                         (*(npy_cdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_double *)data_out)[0] = ((npy_double *)data0)[0] +
                                         ((npy_double *)data_out)[0];
        ((npy_double *)data_out)[1] = ((npy_double *)data0)[1] +
                                         ((npy_double *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
cdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_double *)data_out + 2*6)[0] =
                                    ((npy_double *)data0 + 2*6)[0] +
                                    ((npy_double *)data_out + 2*6)[0];
            ((npy_double *)data_out + 2*6)[1] =
                                    ((npy_double *)data0 + 2*6)[1] +
                                    ((npy_double *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_double *)data_out + 2*5)[0] =
                                    ((npy_double *)data0 + 2*5)[0] +
                                    ((npy_double *)data_out + 2*5)[0];
            ((npy_double *)data_out + 2*5)[1] =
                                    ((npy_double *)data0 + 2*5)[1] +
                                    ((npy_double *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_double *)data_out + 2*4)[0] =
                                    ((npy_double *)data0 + 2*4)[0] +
                                    ((npy_double *)data_out + 2*4)[0];
            ((npy_double *)data_out + 2*4)[1] =
                                    ((npy_double *)data0 + 2*4)[1] +
                                    ((npy_double *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_double *)data_out + 2*3)[0] =
                                    ((npy_double *)data0 + 2*3)[0] +
                                    ((npy_double *)data_out + 2*3)[0];
            ((npy_double *)data_out + 2*3)[1] =
                                    ((npy_double *)data0 + 2*3)[1] +
                                    ((npy_double *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_double *)data_out + 2*2)[0] =
                                    ((npy_double *)data0 + 2*2)[0] +
                                    ((npy_double *)data_out + 2*2)[0];
            ((npy_double *)data_out + 2*2)[1] =
                                    ((npy_double *)data0 + 2*2)[1] +
                                    ((npy_double *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_double *)data_out + 2*1)[0] =
                                    ((npy_double *)data0 + 2*1)[0] +
                                    ((npy_double *)data_out + 2*1)[0];
            ((npy_double *)data_out + 2*1)[1] =
                                    ((npy_double *)data0 + 2*1)[1] +
                                    ((npy_double *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_double *)data_out + 2*0)[0] =
                                    ((npy_double *)data0 + 2*0)[0] +
                                    ((npy_double *)data_out + 2*0)[0];
            ((npy_double *)data_out + 2*0)[1] =
                                    ((npy_double *)data0 + 2*0)[1] +
                                    ((npy_double *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_double *)data_out + 2*0)[0] =
                                ((npy_double *)data0 + 2*0)[0] +
                                ((npy_double *)data_out + 2*0)[0];
        ((npy_double *)data_out + 2*0)[1] =
                                ((npy_double *)data0 + 2*0)[1] +
                                ((npy_double *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_double *)data_out + 2*1)[0] =
                                ((npy_double *)data0 + 2*1)[0] +
                                ((npy_double *)data_out + 2*1)[0];
        ((npy_double *)data_out + 2*1)[1] =
                                ((npy_double *)data0 + 2*1)[1] +
                                ((npy_double *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_double *)data_out + 2*2)[0] =
                                ((npy_double *)data0 + 2*2)[0] +
                                ((npy_double *)data_out + 2*2)[0];
        ((npy_double *)data_out + 2*2)[1] =
                                ((npy_double *)data0 + 2*2)[1] +
                                ((npy_double *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_double *)data_out + 2*3)[0] =
                                ((npy_double *)data0 + 2*3)[0] +
                                ((npy_double *)data_out + 2*3)[0];
        ((npy_double *)data_out + 2*3)[1] =
                                ((npy_double *)data0 + 2*3)[1] +
                                ((npy_double *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_double *)data_out + 2*4)[0] =
                                ((npy_double *)data0 + 2*4)[0] +
                                ((npy_double *)data_out + 2*4)[0];
        ((npy_double *)data_out + 2*4)[1] =
                                ((npy_double *)data0 + 2*4)[1] +
                                ((npy_double *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_double *)data_out + 2*5)[0] =
                                ((npy_double *)data0 + 2*5)[0] +
                                ((npy_double *)data_out + 2*5)[0];
        ((npy_double *)data_out + 2*5)[1] =
                                ((npy_double *)data0 + 2*5)[1] +
                                ((npy_double *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_double *)data_out + 2*6)[0] =
                                ((npy_double *)data0 + 2*6)[0] +
                                ((npy_double *)data_out + 2*6)[0];
        ((npy_double *)data_out + 2*6)[1] =
                                ((npy_double *)data0 + 2*6)[1] +
                                ((npy_double *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_double *)data_out + 2*7)[0] =
                                ((npy_double *)data0 + 2*7)[0] +
                                ((npy_double *)data_out + 2*7)[0];
        ((npy_double *)data_out + 2*7)[1] =
                                ((npy_double *)data0 + 2*7)[1] +
                                ((npy_double *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !1

static void
cdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
cdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
cdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_cdouble *data_out = (npy_cdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_double value0 = (*(npy_cdouble *)dataptr[0]);
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
cdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_double value1 = (*(npy_cdouble *)dataptr[1]);
    npy_double accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_cdouble *)dataptr[2] = ((*(npy_cdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !1

static void
cdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
    npy_cdouble *data1 = (npy_cdouble *)dataptr[1];
    npy_cdouble *data2 = (npy_cdouble *)dataptr[2];
    npy_cdouble *data_out = (npy_cdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
cdouble_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        *(npy_cdouble *)dataptr[nop] = (temp +
                                           (*(npy_cdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_double *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[0];
        ((npy_double *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_double *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_cdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
cdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
    npy_double *data0 = (npy_double *)dataptr[0];
#else
    npy_double accum = 0;
    npy_cdouble *data0 = (npy_cdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_double *)dataptr[1])[0] += accum_re;
            ((npy_double *)dataptr[1])[1] += accum_im;
#else
            *((npy_cdouble *)dataptr[1]) = (accum +
                                    (*((npy_cdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
cdouble_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_double accum_re = 0, accum_im = 0;
#else
    npy_double accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("cdouble_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        accum += (*(npy_cdouble *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_cdouble *)data0) *
                 (*(npy_cdouble *)data1) *
                 (*(npy_cdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_double temp = (*(npy_cdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_cdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_double *)data0)[0];
        accum_im += ((npy_double *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_double re, im, tmp;
        int i;
        re = ((npy_double *)dataptr[0])[0];
        im = ((npy_double *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_double *)dataptr[i])[0] -
                  im * ((npy_double *)dataptr[i])[1];
            im = re * ((npy_double *)dataptr[i])[1] +
                 im * ((npy_double *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1000 <= 3
    ((npy_double *)dataptr[1000])[0] += accum_re;
    ((npy_double *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_double *)dataptr[nop])[0] += accum_re;
    ((npy_double *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_cdouble *)dataptr[1000]) = (accum +
                                    (*((npy_cdouble *)dataptr[1000])));
#  else
    *((npy_cdouble *)dataptr[nop]) = (accum +
                                    (*((npy_cdouble *)dataptr[nop])));
#  endif
#endif

}




#line 103

#line 108
static void
clongdouble_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 == 1) || (1 <= 3 && !1)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_one (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1 == 2
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1 == 3
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) *
                                         (*(npy_clongdouble *)data2) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1 == 1

static void
clongdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 2 && !1

static void
clongdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
clongdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
clongdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1 == 3 && !1

static void
clongdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data2 = (npy_clongdouble *)dataptr[2];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1 > 3 || @complex */

static void
clongdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#else /* complex */
#  if 1 <= 3
#    define _SUMPROD_NOP 1
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1 */

#if 1 == 1

static void
clongdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_clongdouble *)dataptr[1]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1 == 1 */

static void
clongdouble_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (1 == 1) || (1 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_outstride0_one (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1 == 1
        accum += (*(npy_clongdouble *)data0);
        data0 += stride0;
#  elif 1 == 2
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1 == 3
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1) *
                 (*(npy_clongdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 1 <= 3
#define _SUMPROD_NOP 1
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1 <= 3
    ((npy_longdouble *)dataptr[1])[0] += accum_re;
    ((npy_longdouble *)dataptr[1])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1 <= 3
    *((npy_clongdouble *)dataptr[1]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1])));
#  else
    *((npy_clongdouble *)dataptr[nop]) = (accum +
                                    (*((npy_clongdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
clongdouble_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 == 1) || (2 <= 3 && !1)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_two (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 2 == 2
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 2 == 3
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) *
                                         (*(npy_clongdouble *)data2) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 2 == 1

static void
clongdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 2 && !1

static void
clongdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
clongdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
clongdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 2 == 3 && !1

static void
clongdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data2 = (npy_clongdouble *)dataptr[2];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 2 > 3 || @complex */

static void
clongdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#else /* complex */
#  if 2 <= 3
#    define _SUMPROD_NOP 2
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 2 */

#if 2 == 1

static void
clongdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_clongdouble *)dataptr[1]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 2 == 1 */

static void
clongdouble_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (2 == 1) || (2 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_outstride0_two (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 2 == 1
        accum += (*(npy_clongdouble *)data0);
        data0 += stride0;
#  elif 2 == 2
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 2 == 3
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1) *
                 (*(npy_clongdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 2 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 2 <= 3
#define _SUMPROD_NOP 2
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 2 <= 3
    ((npy_longdouble *)dataptr[2])[0] += accum_re;
    ((npy_longdouble *)dataptr[2])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 2 <= 3
    *((npy_clongdouble *)dataptr[2]) = (accum +
                                    (*((npy_clongdouble *)dataptr[2])));
#  else
    *((npy_clongdouble *)dataptr[nop]) = (accum +
                                    (*((npy_clongdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
clongdouble_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 == 1) || (3 <= 3 && !1)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_three (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 3 == 2
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 3 == 3
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) *
                                         (*(npy_clongdouble *)data2) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 3 == 1

static void
clongdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 2 && !1

static void
clongdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
clongdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
clongdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 3 == 3 && !1

static void
clongdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data2 = (npy_clongdouble *)dataptr[2];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 3 > 3 || @complex */

static void
clongdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#else /* complex */
#  if 3 <= 3
#    define _SUMPROD_NOP 3
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 3 */

#if 3 == 1

static void
clongdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_clongdouble *)dataptr[1]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 3 == 1 */

static void
clongdouble_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (3 == 1) || (3 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_outstride0_three (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 3 == 1
        accum += (*(npy_clongdouble *)data0);
        data0 += stride0;
#  elif 3 == 2
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 3 == 3
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1) *
                 (*(npy_clongdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 3 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 3 <= 3
#define _SUMPROD_NOP 3
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 3 <= 3
    ((npy_longdouble *)dataptr[3])[0] += accum_re;
    ((npy_longdouble *)dataptr[3])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 3 <= 3
    *((npy_clongdouble *)dataptr[3]) = (accum +
                                    (*((npy_clongdouble *)dataptr[3])));
#  else
    *((npy_clongdouble *)dataptr[nop]) = (accum +
                                    (*((npy_clongdouble *)dataptr[nop])));
#  endif
#endif

}


#line 108
static void
clongdouble_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 == 1) || (1000 <= 3 && !1)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_any (%d)\n", (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif 1000 == 2
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif 1000 == 3
        *(npy_clongdouble *)data_out = ((*(npy_clongdouble *)data0) *
                                         (*(npy_clongdouble *)data1) *
                                         (*(npy_clongdouble *)data2) +
                                         (*(npy_clongdouble *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        ((npy_longdouble *)data_out)[0] = ((npy_longdouble *)data0)[0] +
                                         ((npy_longdouble *)data_out)[0];
        ((npy_longdouble *)data_out)[1] = ((npy_longdouble *)data0)[1] +
                                         ((npy_longdouble *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if 1000 == 1

static void
clongdouble_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 223
        case 6+1:
#if !1
            data_out[6] = ((data0[6]) +
                                 (data_out[6]));
#else
            ((npy_longdouble *)data_out + 2*6)[0] =
                                    ((npy_longdouble *)data0 + 2*6)[0] +
                                    ((npy_longdouble *)data_out + 2*6)[0];
            ((npy_longdouble *)data_out + 2*6)[1] =
                                    ((npy_longdouble *)data0 + 2*6)[1] +
                                    ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 223
        case 5+1:
#if !1
            data_out[5] = ((data0[5]) +
                                 (data_out[5]));
#else
            ((npy_longdouble *)data_out + 2*5)[0] =
                                    ((npy_longdouble *)data0 + 2*5)[0] +
                                    ((npy_longdouble *)data_out + 2*5)[0];
            ((npy_longdouble *)data_out + 2*5)[1] =
                                    ((npy_longdouble *)data0 + 2*5)[1] +
                                    ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 223
        case 4+1:
#if !1
            data_out[4] = ((data0[4]) +
                                 (data_out[4]));
#else
            ((npy_longdouble *)data_out + 2*4)[0] =
                                    ((npy_longdouble *)data0 + 2*4)[0] +
                                    ((npy_longdouble *)data_out + 2*4)[0];
            ((npy_longdouble *)data_out + 2*4)[1] =
                                    ((npy_longdouble *)data0 + 2*4)[1] +
                                    ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 223
        case 3+1:
#if !1
            data_out[3] = ((data0[3]) +
                                 (data_out[3]));
#else
            ((npy_longdouble *)data_out + 2*3)[0] =
                                    ((npy_longdouble *)data0 + 2*3)[0] +
                                    ((npy_longdouble *)data_out + 2*3)[0];
            ((npy_longdouble *)data_out + 2*3)[1] =
                                    ((npy_longdouble *)data0 + 2*3)[1] +
                                    ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 223
        case 2+1:
#if !1
            data_out[2] = ((data0[2]) +
                                 (data_out[2]));
#else
            ((npy_longdouble *)data_out + 2*2)[0] =
                                    ((npy_longdouble *)data0 + 2*2)[0] +
                                    ((npy_longdouble *)data_out + 2*2)[0];
            ((npy_longdouble *)data_out + 2*2)[1] =
                                    ((npy_longdouble *)data0 + 2*2)[1] +
                                    ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 223
        case 1+1:
#if !1
            data_out[1] = ((data0[1]) +
                                 (data_out[1]));
#else
            ((npy_longdouble *)data_out + 2*1)[0] =
                                    ((npy_longdouble *)data0 + 2*1)[0] +
                                    ((npy_longdouble *)data_out + 2*1)[0];
            ((npy_longdouble *)data_out + 2*1)[1] =
                                    ((npy_longdouble *)data0 + 2*1)[1] +
                                    ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 223
        case 0+1:
#if !1
            data_out[0] = ((data0[0]) +
                                 (data_out[0]));
#else
            ((npy_longdouble *)data_out + 2*0)[0] =
                                    ((npy_longdouble *)data0 + 2*0)[0] +
                                    ((npy_longdouble *)data_out + 2*0)[0];
            ((npy_longdouble *)data_out + 2*0)[1] =
                                    ((npy_longdouble *)data0 + 2*0)[1] +
                                    ((npy_longdouble *)data_out + 2*0)[1];
#endif

        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 247
#if !1
        data_out[0] = ((data0[0]) +
                             (data_out[0]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*0)[0] =
                                ((npy_longdouble *)data0 + 2*0)[0] +
                                ((npy_longdouble *)data_out + 2*0)[0];
        ((npy_longdouble *)data_out + 2*0)[1] =
                                ((npy_longdouble *)data0 + 2*0)[1] +
                                ((npy_longdouble *)data_out + 2*0)[1];
#endif

#line 247
#if !1
        data_out[1] = ((data0[1]) +
                             (data_out[1]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*1)[0] =
                                ((npy_longdouble *)data0 + 2*1)[0] +
                                ((npy_longdouble *)data_out + 2*1)[0];
        ((npy_longdouble *)data_out + 2*1)[1] =
                                ((npy_longdouble *)data0 + 2*1)[1] +
                                ((npy_longdouble *)data_out + 2*1)[1];
#endif

#line 247
#if !1
        data_out[2] = ((data0[2]) +
                             (data_out[2]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*2)[0] =
                                ((npy_longdouble *)data0 + 2*2)[0] +
                                ((npy_longdouble *)data_out + 2*2)[0];
        ((npy_longdouble *)data_out + 2*2)[1] =
                                ((npy_longdouble *)data0 + 2*2)[1] +
                                ((npy_longdouble *)data_out + 2*2)[1];
#endif

#line 247
#if !1
        data_out[3] = ((data0[3]) +
                             (data_out[3]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*3)[0] =
                                ((npy_longdouble *)data0 + 2*3)[0] +
                                ((npy_longdouble *)data_out + 2*3)[0];
        ((npy_longdouble *)data_out + 2*3)[1] =
                                ((npy_longdouble *)data0 + 2*3)[1] +
                                ((npy_longdouble *)data_out + 2*3)[1];
#endif

#line 247
#if !1
        data_out[4] = ((data0[4]) +
                             (data_out[4]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*4)[0] =
                                ((npy_longdouble *)data0 + 2*4)[0] +
                                ((npy_longdouble *)data_out + 2*4)[0];
        ((npy_longdouble *)data_out + 2*4)[1] =
                                ((npy_longdouble *)data0 + 2*4)[1] +
                                ((npy_longdouble *)data_out + 2*4)[1];
#endif

#line 247
#if !1
        data_out[5] = ((data0[5]) +
                             (data_out[5]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*5)[0] =
                                ((npy_longdouble *)data0 + 2*5)[0] +
                                ((npy_longdouble *)data_out + 2*5)[0];
        ((npy_longdouble *)data_out + 2*5)[1] =
                                ((npy_longdouble *)data0 + 2*5)[1] +
                                ((npy_longdouble *)data_out + 2*5)[1];
#endif

#line 247
#if !1
        data_out[6] = ((data0[6]) +
                             (data_out[6]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*6)[0] =
                                ((npy_longdouble *)data0 + 2*6)[0] +
                                ((npy_longdouble *)data_out + 2*6)[0];
        ((npy_longdouble *)data_out + 2*6)[1] =
                                ((npy_longdouble *)data0 + 2*6)[1] +
                                ((npy_longdouble *)data_out + 2*6)[1];
#endif

#line 247
#if !1
        data_out[7] = ((data0[7]) +
                             (data_out[7]));
#else /* complex */
        ((npy_longdouble *)data_out + 2*7)[0] =
                                ((npy_longdouble *)data0 + 2*7)[0] +
                                ((npy_longdouble *)data_out + 2*7)[0];
        ((npy_longdouble *)data_out + 2*7)[1] =
                                ((npy_longdouble *)data0 + 2*7)[1] +
                                ((npy_longdouble *)data_out + 2*7)[1];
#endif

        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 2 && !1

static void
clongdouble_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 290
        case 6+1:
            data_out[6] = ((data0[6]) *
                                 (data1[6]) +
                                 (data_out[6]));

#line 290
        case 5+1:
            data_out[5] = ((data0[5]) *
                                 (data1[5]) +
                                 (data_out[5]));

#line 290
        case 4+1:
            data_out[4] = ((data0[4]) *
                                 (data1[4]) +
                                 (data_out[4]));

#line 290
        case 3+1:
            data_out[3] = ((data0[3]) *
                                 (data1[3]) +
                                 (data_out[3]));

#line 290
        case 2+1:
            data_out[2] = ((data0[2]) *
                                 (data1[2]) +
                                 (data_out[2]));

#line 290
        case 1+1:
            data_out[1] = ((data0[1]) *
                                 (data1[1]) +
                                 (data_out[1]));

#line 290
        case 0+1:
            data_out[0] = ((data0[0]) *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1) &&
        EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 310
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 332
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 340
        data_out[0] = ((data0[0]) *
                             (data1[0]) +
                             (data_out[0]));

#line 340
        data_out[1] = ((data0[1]) *
                             (data1[1]) +
                             (data_out[1]));

#line 340
        data_out[2] = ((data0[2]) *
                             (data1[2]) +
                             (data_out[2]));

#line 340
        data_out[3] = ((data0[3]) *
                             (data1[3]) +
                             (data_out[3]));

#line 340
        data_out[4] = ((data0[4]) *
                             (data1[4]) +
                             (data_out[4]));

#line 340
        data_out[5] = ((data0[5]) *
                             (data1[5]) +
                             (data_out[5]));

#line 340
        data_out[6] = ((data0[6]) *
                             (data1[6]) +
                             (data_out[6]));

#line 340
        data_out[7] = ((data0[7]) *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data0 += 8;
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
clongdouble_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value0_sse;
#elif EINSUM_USE_SSE2 && 0
    __m128d a, b, value0_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 378
        case 6+1:
            data_out[6] = (value0 *
                                 (data1[6]) +
                                 (data_out[6]));

#line 378
        case 5+1:
            data_out[5] = (value0 *
                                 (data1[5]) +
                                 (data_out[5]));

#line 378
        case 4+1:
            data_out[4] = (value0 *
                                 (data1[4]) +
                                 (data_out[4]));

#line 378
        case 3+1:
            data_out[3] = (value0 *
                                 (data1[3]) +
                                 (data_out[3]));

#line 378
        case 2+1:
            data_out[2] = (value0 *
                                 (data1[2]) +
                                 (data_out[2]));

#line 378
        case 1+1:
            data_out[1] = (value0 *
                                 (data1[1]) +
                                 (data_out[1]));

#line 378
        case 0+1:
            data_out[0] = (value0 *
                                 (data1[0]) +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value0_sse = _mm_set_ps1(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+0));
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 399
            a = _mm_mul_ps(value0_sse, _mm_load_ps(data1+4));
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif EINSUM_USE_SSE2 && 0
    value0_sse = _mm_set1_pd(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+0));
            b = _mm_add_pd(a, _mm_load_pd(data_out+0));
            _mm_store_pd(data_out+0, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+2));
            b = _mm_add_pd(a, _mm_load_pd(data_out+2));
            _mm_store_pd(data_out+2, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+4));
            b = _mm_add_pd(a, _mm_load_pd(data_out+4));
            _mm_store_pd(data_out+4, b);

#line 427
            a = _mm_mul_pd(value0_sse, _mm_load_pd(data1+6));
            b = _mm_add_pd(a, _mm_load_pd(data_out+6));
            _mm_store_pd(data_out+6, b);

            data1 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+0));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 453
        a = _mm_mul_ps(value0_sse, _mm_loadu_ps(data1+4));
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#elif EINSUM_USE_SSE2 && 0
#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+0));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+0));
        _mm_storeu_pd(data_out+0, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+2));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+2));
        _mm_storeu_pd(data_out+2, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+4));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+4));
        _mm_storeu_pd(data_out+4, b);

#line 461
        a = _mm_mul_pd(value0_sse, _mm_loadu_pd(data1+6));
        b = _mm_add_pd(a, _mm_loadu_pd(data_out+6));
        _mm_storeu_pd(data_out+6, b);

#else
#line 469
        data_out[0] = (value0 *
                             (data1[0]) +
                             (data_out[0]));

#line 469
        data_out[1] = (value0 *
                             (data1[1]) +
                             (data_out[1]));

#line 469
        data_out[2] = (value0 *
                             (data1[2]) +
                             (data_out[2]));

#line 469
        data_out[3] = (value0 *
                             (data1[3]) +
                             (data_out[3]));

#line 469
        data_out[4] = (value0 *
                             (data1[4]) +
                             (data_out[4]));

#line 469
        data_out[5] = (value0 *
                             (data1[5]) +
                             (data_out[5]));

#line 469
        data_out[6] = (value0 *
                             (data1[6]) +
                             (data_out[6]));

#line 469
        data_out[7] = (value0 *
                             (data1[7]) +
                             (data_out[7]));

#endif
        data1 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
clongdouble_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[2];

#if EINSUM_USE_SSE1 && 0
    __m128 a, b, value1_sse;
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 505
        case 6+1:
            data_out[6] = ((data0[6])*
                                 value1  +
                                 (data_out[6]));

#line 505
        case 5+1:
            data_out[5] = ((data0[5])*
                                 value1  +
                                 (data_out[5]));

#line 505
        case 4+1:
            data_out[4] = ((data0[4])*
                                 value1  +
                                 (data_out[4]));

#line 505
        case 3+1:
            data_out[3] = ((data0[3])*
                                 value1  +
                                 (data_out[3]));

#line 505
        case 2+1:
            data_out[2] = ((data0[2])*
                                 value1  +
                                 (data_out[2]));

#line 505
        case 1+1:
            data_out[1] = ((data0[1])*
                                 value1  +
                                 (data_out[1]));

#line 505
        case 0+1:
            data_out[0] = ((data0[0])*
                                 value1  +
                                 (data_out[0]));

        case 0:
            return;
    }

#if EINSUM_USE_SSE1 && 0
    value1_sse = _mm_set_ps1(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data_out)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+0), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+0));
            _mm_store_ps(data_out+0, b);

#line 526
            a = _mm_mul_ps(_mm_load_ps(data0+4), value1_sse);
            b = _mm_add_ps(a, _mm_load_ps(data_out+4));
            _mm_store_ps(data_out+4, b);

            data0 += 8;
            data_out += 8;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+0));
        _mm_storeu_ps(data_out+0, b);

#line 547
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), value1_sse);
        b = _mm_add_ps(a, _mm_loadu_ps(data_out+4));
        _mm_storeu_ps(data_out+4, b);

#else
#line 555
        data_out[0] = ((data0[0])*
                             value1  +
                             (data_out[0]));

#line 555
        data_out[1] = ((data0[1])*
                             value1  +
                             (data_out[1]));

#line 555
        data_out[2] = ((data0[2])*
                             value1  +
                             (data_out[2]));

#line 555
        data_out[3] = ((data0[3])*
                             value1  +
                             (data_out[3]));

#line 555
        data_out[4] = ((data0[4])*
                             value1  +
                             (data_out[4]));

#line 555
        data_out[5] = ((data0[5])*
                             value1  +
                             (data_out[5]));

#line 555
        data_out[6] = ((data0[6])*
                             value1  +
                             (data_out[6]));

#line 555
        data_out[7] = ((data0[7])*
                             value1  +
                             (data_out[7]));

#endif
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 591
        case 6+1:
            accum += (data0[6]) * (data1[6]);

#line 591
        case 5+1:
            accum += (data0[5]) * (data1[5]);

#line 591
        case 4+1:
            accum += (data0[4]) * (data1[4]);

#line 591
        case 3+1:
            accum += (data0[3]) * (data1[3]);

#line 591
        case 2+1:
            accum += (data0[2]) * (data1[2]);

#line 591
        case 1+1:
            accum += (data0[1]) * (data1[1]);

#line 591
        case 0+1:
            accum += (data0[0]) * (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+0), _mm_load_ps(data1+0));
            accum_sse = _mm_add_ps(accum_sse, a);

#line 612
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_ps(_mm_load_ps(data0+4), _mm_load_ps(data1+4));
            accum_sse = _mm_add_ps(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0) && EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);
            _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+0), _mm_load_pd(data1+0));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+2), _mm_load_pd(data1+2));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+4), _mm_load_pd(data1+4));
            accum_sse = _mm_add_pd(accum_sse, a);

#line 646
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            a = _mm_mul_pd(_mm_load_pd(data0+6), _mm_load_pd(data1+6));
            accum_sse = _mm_add_pd(accum_sse, a);

            data0 += 8;
            data1 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+0), _mm_loadu_ps(data1+0));
        accum_sse = _mm_add_ps(accum_sse, a);

#line 678
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_ps(_mm_loadu_ps(data0+4), _mm_loadu_ps(data1+4));
        accum_sse = _mm_add_ps(accum_sse, a);

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);
        _mm_prefetch(data1 + 512, _MM_HINT_T0);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+0), _mm_loadu_pd(data1+0));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+2), _mm_loadu_pd(data1+2));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+4), _mm_loadu_pd(data1+4));
        accum_sse = _mm_add_pd(accum_sse, a);

#line 692
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        a = _mm_mul_pd(_mm_loadu_pd(data0+6), _mm_loadu_pd(data1+6));
        accum_sse = _mm_add_pd(accum_sse, a);

#else
#line 703
        accum += (data0[0]) * (data1[0]);

#line 703
        accum += (data0[1]) * (data1[1]);

#line 703
        accum += (data0[2]) * (data1[2]);

#line 703
        accum += (data0[3]) * (data1[3]);

#line 703
        accum += (data0[4]) * (data1[4]);

#line 703
        accum += (data0[5]) * (data1[5]);

#line 703
        accum += (data0[6]) * (data1[6]);

#line 703
        accum += (data0[7]) * (data1[7]);

#endif
        data0 += 8;
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_longdouble value0 = (*(npy_clongdouble *)dataptr[0]);
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 749
        case 6+1:
            accum += (data1[6]);

#line 749
        case 5+1:
            accum += (data1[5]);

#line 749
        case 4+1:
            accum += (data1[4]);

#line 749
        case 3+1:
            accum += (data1[3]);

#line 749
        case 2+1:
            accum += (data1[2]);

#line 749
        case 1+1:
            accum += (data1[1]);

#line 749
        case 0+1:
            accum += (data1[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + value0 * accum);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data1)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+0));

#line 767
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data1+4));

            data1 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+0));

#line 798
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data1+4));

#else
#line 808
        accum += (data1[0]);

#line 808
        accum += (data1[1]);

#line 808
        accum += (data1[2]);

#line 808
        accum += (data1[3]);

#line 808
        accum += (data1[4]);

#line 808
        accum += (data1[5]);

#line 808
        accum += (data1[6]);

#line 808
        accum += (data1[7]);

#endif
        data1 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
clongdouble_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_longdouble value1 = (*(npy_clongdouble *)dataptr[1]);
    npy_longdouble accum = 0;

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 848
        case 6+1:
            accum += (data0[6]);

#line 848
        case 5+1:
            accum += (data0[5]);

#line 848
        case 4+1:
            accum += (data0[4]);

#line 848
        case 3+1:
            accum += (data0[3]);

#line 848
        case 2+1:
            accum += (data0[2]);

#line 848
        case 1+1:
            accum += (data0[1]);

#line 848
        case 0+1:
            accum += (data0[0]);

        case 0:
            *(npy_clongdouble *)dataptr[2] = ((*(npy_clongdouble *)dataptr[2]) + accum * value1);
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 866
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

#if EINSUM_USE_SSE1 && 0
        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);
#endif

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 897
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#else
#line 907
        accum += (data0[0]);

#line 907
        accum += (data0[1]);

#line 907
        accum += (data0[2]);

#line 907
        accum += (data0[3]);

#line 907
        accum += (data0[4]);

#line 907
        accum += (data0[5]);

#line 907
        accum += (data0[6]);

#line 907
        accum += (data0[7]);

#endif
        data0 += 8;
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif 1000 == 3 && !1

static void
clongdouble_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
    npy_clongdouble *data1 = (npy_clongdouble *)dataptr[1];
    npy_clongdouble *data2 = (npy_clongdouble *)dataptr[2];
    npy_clongdouble *data_out = (npy_clongdouble *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#line 944
        data_out[0] = ((data0[0]) *
                             (data1[0]) *
                             (data2[0]) +
                             (data_out[0]));

#line 944
        data_out[1] = ((data0[1]) *
                             (data1[1]) *
                             (data2[1]) +
                             (data_out[1]));

#line 944
        data_out[2] = ((data0[2]) *
                             (data1[2]) *
                             (data2[2]) +
                             (data_out[2]));

#line 944
        data_out[3] = ((data0[3]) *
                             (data1[3]) *
                             (data2[3]) +
                             (data_out[3]));

#line 944
        data_out[4] = ((data0[4]) *
                             (data1[4]) *
                             (data2[4]) +
                             (data_out[4]));

#line 944
        data_out[5] = ((data0[5]) *
                             (data1[5]) *
                             (data2[5]) +
                             (data_out[5]));

#line 944
        data_out[6] = ((data0[6]) *
                             (data1[6]) *
                             (data2[6]) +
                             (data_out[6]));

#line 944
        data_out[7] = ((data0[7]) *
                             (data1[7]) *
                             (data2[7]) +
                             (data_out[7]));

        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[0] = ((data0[0]) *
                         (data1[0]) *
                         (data2[0]) +
                         (data_out[0]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[1] = ((data0[1]) *
                         (data1[1]) *
                         (data2[1]) +
                         (data_out[1]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[2] = ((data0[2]) *
                         (data1[2]) *
                         (data2[2]) +
                         (data_out[2]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[3] = ((data0[3]) *
                         (data1[3]) *
                         (data2[3]) +
                         (data_out[3]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[4] = ((data0[4]) *
                         (data1[4]) *
                         (data2[4]) +
                         (data_out[4]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[5] = ((data0[5]) *
                         (data1[5]) *
                         (data2[5]) +
                         (data_out[5]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[6] = ((data0[6]) *
                         (data1[6]) *
                         (data2[6]) +
                         (data_out[6]));

#line 960
    if (count-- == 0) {
        return;
    }
    data_out[7] = ((data0[7]) *
                         (data1[7]) *
                         (data2[7]) +
                         (data_out[7]));

}

#else /* 1000 > 3 || @complex */

static void
clongdouble_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        *(npy_clongdouble *)dataptr[nop] = (temp +
                                           (*(npy_clongdouble *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#else /* complex */
#  if 1000 <= 3
#    define _SUMPROD_NOP 1000
#  else
#    define _SUMPROD_NOP nop
#  endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[0];
        ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((npy_longdouble *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(npy_clongdouble);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various 1000 */

#if 1000 == 1

static void
clongdouble_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
    npy_longdouble *data0 = (npy_longdouble *)dataptr[0];
#else
    npy_longdouble accum = 0;
    npy_clongdouble *data0 = (npy_clongdouble *)dataptr[0];
#endif

#if EINSUM_USE_SSE1 && 0
    __m128 a, accum_sse = _mm_setzero_ps();
#elif EINSUM_USE_SSE2 && 0
    __m128d a, accum_sse = _mm_setzero_pd();
#endif


    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1053
        case 6+1:
#if !1
            accum += (data0[6]);
#else /* complex */
            accum_re += data0[2*6+0];
            accum_im += data0[2*6+1];
#endif

#line 1053
        case 5+1:
#if !1
            accum += (data0[5]);
#else /* complex */
            accum_re += data0[2*5+0];
            accum_im += data0[2*5+1];
#endif

#line 1053
        case 4+1:
#if !1
            accum += (data0[4]);
#else /* complex */
            accum_re += data0[2*4+0];
            accum_im += data0[2*4+1];
#endif

#line 1053
        case 3+1:
#if !1
            accum += (data0[3]);
#else /* complex */
            accum_re += data0[2*3+0];
            accum_im += data0[2*3+1];
#endif

#line 1053
        case 2+1:
#if !1
            accum += (data0[2]);
#else /* complex */
            accum_re += data0[2*2+0];
            accum_im += data0[2*2+1];
#endif

#line 1053
        case 1+1:
#if !1
            accum += (data0[1]);
#else /* complex */
            accum_re += data0[2*1+0];
            accum_im += data0[2*1+1];
#endif

#line 1053
        case 0+1:
#if !1
            accum += (data0[0]);
#else /* complex */
            accum_re += data0[2*0+0];
            accum_im += data0[2*0+1];
#endif

        case 0:
#if 1
            ((npy_longdouble *)dataptr[1])[0] += accum_re;
            ((npy_longdouble *)dataptr[1])[1] += accum_im;
#else
            *((npy_clongdouble *)dataptr[1]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1])));
#endif
            return;
    }

#if EINSUM_USE_SSE1 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+0));

#line 1084
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_ps(accum_sse, _mm_load_ps(data0+4));

            data0 += 8;
        }

        /* Add the four SSE values and put in accum */
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
        accum_sse = _mm_add_ps(a, accum_sse);
        a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
        accum_sse = _mm_add_ps(a, accum_sse);
        _mm_store_ss(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif EINSUM_USE_SSE2 && 0
    /* Use aligned instructions if possible */
    if (EINSUM_IS_SSE_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= 8) {
            count -= 8;

            _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+0));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+2));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+4));

#line 1115
            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            accum_sse = _mm_add_pd(accum_sse, _mm_load_pd(data0+6));

            data0 += 8;
        }

        /* Add the two SSE2 values and put in accum */
        a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
        accum_sse = _mm_add_pd(a, accum_sse);
        _mm_store_sd(&accum, accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

#if EINSUM_USE_SSE1 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+0));

#line 1144
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+4));

#elif EINSUM_USE_SSE2 && 0
        _mm_prefetch(data0 + 512, _MM_HINT_T0);

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+0));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+2));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+4));

#line 1156
        /*
         * NOTE: This accumulation changes the order, so will likely
         *       produce slightly different results.
         */
        accum_sse = _mm_add_pd(accum_sse, _mm_loadu_pd(data0+6));

#else
#line 1166
#  if !1
        accum += (data0[0]);
#  else /* complex */
        accum_re += data0[2*0+0];
        accum_im += data0[2*0+1];
#  endif

#line 1166
#  if !1
        accum += (data0[1]);
#  else /* complex */
        accum_re += data0[2*1+0];
        accum_im += data0[2*1+1];
#  endif

#line 1166
#  if !1
        accum += (data0[2]);
#  else /* complex */
        accum_re += data0[2*2+0];
        accum_im += data0[2*2+1];
#  endif

#line 1166
#  if !1
        accum += (data0[3]);
#  else /* complex */
        accum_re += data0[2*3+0];
        accum_im += data0[2*3+1];
#  endif

#line 1166
#  if !1
        accum += (data0[4]);
#  else /* complex */
        accum_re += data0[2*4+0];
        accum_im += data0[2*4+1];
#  endif

#line 1166
#  if !1
        accum += (data0[5]);
#  else /* complex */
        accum_re += data0[2*5+0];
        accum_im += data0[2*5+1];
#  endif

#line 1166
#  if !1
        accum += (data0[6]);
#  else /* complex */
        accum_re += data0[2*6+0];
        accum_im += data0[2*6+1];
#  endif

#line 1166
#  if !1
        accum += (data0[7]);
#  else /* complex */
        accum_re += data0[2*7+0];
        accum_im += data0[2*7+1];
#  endif

#endif

#if !1
        data0 += 8;
#else
        data0 += 8*2;
#endif
    }

#if EINSUM_USE_SSE1 && 0
    /* Add the four SSE values and put in accum */
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(2,3,0,1));
    accum_sse = _mm_add_ps(a, accum_sse);
    a = _mm_shuffle_ps(accum_sse, accum_sse, _MM_SHUFFLE(1,0,3,2));
    accum_sse = _mm_add_ps(a, accum_sse);
    _mm_store_ss(&accum, accum_sse);
#elif EINSUM_USE_SSE2 && 0
    /* Add the two SSE2 values and put in accum */
    a = _mm_shuffle_pd(accum_sse, accum_sse, _MM_SHUFFLE2(0,1));
    accum_sse = _mm_add_pd(a, accum_sse);
    _mm_store_sd(&accum, accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* 1000 == 1 */

static void
clongdouble_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if 1
    npy_longdouble accum_re = 0, accum_im = 0;
#else
    npy_longdouble accum = 0;
#endif

#if (1000 == 1) || (1000 <= 3 && !1)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3) && !1
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3) && !1
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("clongdouble_sum_of_products_outstride0_any (%d)\n",
                                                    (int)count);

    while (count--) {
#if !1
#  if 1000 == 1
        accum += (*(npy_clongdouble *)data0);
        data0 += stride0;
#  elif 1000 == 2
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif 1000 == 3
        accum += (*(npy_clongdouble *)data0) *
                 (*(npy_clongdouble *)data1) *
                 (*(npy_clongdouble *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        npy_longdouble temp = (*(npy_clongdouble *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= (*(npy_clongdouble *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if 1000 == 1
        accum_re += ((npy_longdouble *)data0)[0];
        accum_im += ((npy_longdouble *)data0)[1];
        data0 += stride0;
#  else
#    if 1000 <= 3
#define _SUMPROD_NOP 1000
#    else
#define _SUMPROD_NOP nop
#    endif
        npy_longdouble re, im, tmp;
        int i;
        re = ((npy_longdouble *)dataptr[0])[0];
        im = ((npy_longdouble *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((npy_longdouble *)dataptr[i])[0] -
                  im * ((npy_longdouble *)dataptr[i])[1];
            im = re * ((npy_longdouble *)dataptr[i])[1] +
                 im * ((npy_longdouble *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if 1
#  if 1000 <= 3
    ((npy_longdouble *)dataptr[1000])[0] += accum_re;
    ((npy_longdouble *)dataptr[1000])[1] += accum_im;
#  else
    ((npy_longdouble *)dataptr[nop])[0] += accum_re;
    ((npy_longdouble *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if 1000 <= 3
    *((npy_clongdouble *)dataptr[1000]) = (accum +
                                    (*((npy_clongdouble *)dataptr[1000])));
#  else
    *((npy_clongdouble *)dataptr[nop]) = (accum +
                                    (*((npy_clongdouble *)dataptr[nop])));
#  endif
#endif

}






/* Do OR of ANDs for the boolean type */

#line 1319

static void
bool_sum_of_products_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1 <= 3)
    char *data_out = dataptr[1];
    npy_intp stride_out = strides[1];
#endif

    while (count--) {
#if 1 == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif 1 == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif 1 == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1 <= 3)
    char *data0 = dataptr[0];
#endif
#if (1 == 2 || 1 == 3)
    char *data1 = dataptr[1];
#endif
#if (1 == 3)
    char *data2 = dataptr[2];
#endif
#if (1 <= 3)
    char *data_out = dataptr[1];
#endif

#if (1 <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1401
        case 6+1:
#  if 1 == 1
            ((npy_bool *)data_out)[6] = ((npy_bool *)data0)[6] ||
                                            ((npy_bool *)data_out)[6];
#  elif 1 == 2
            ((npy_bool *)data_out)[6] =
                            (((npy_bool *)data0)[6] &&
                             ((npy_bool *)data1)[6]) ||
                                ((npy_bool *)data_out)[6];
#  elif 1 == 3
            ((npy_bool *)data_out)[6] =
                           (((npy_bool *)data0)[6] &&
                            ((npy_bool *)data1)[6] &&
                            ((npy_bool *)data2)[6]) ||
                                ((npy_bool *)data_out)[6];
#  endif

#line 1401
        case 5+1:
#  if 1 == 1
            ((npy_bool *)data_out)[5] = ((npy_bool *)data0)[5] ||
                                            ((npy_bool *)data_out)[5];
#  elif 1 == 2
            ((npy_bool *)data_out)[5] =
                            (((npy_bool *)data0)[5] &&
                             ((npy_bool *)data1)[5]) ||
                                ((npy_bool *)data_out)[5];
#  elif 1 == 3
            ((npy_bool *)data_out)[5] =
                           (((npy_bool *)data0)[5] &&
                            ((npy_bool *)data1)[5] &&
                            ((npy_bool *)data2)[5]) ||
                                ((npy_bool *)data_out)[5];
#  endif

#line 1401
        case 4+1:
#  if 1 == 1
            ((npy_bool *)data_out)[4] = ((npy_bool *)data0)[4] ||
                                            ((npy_bool *)data_out)[4];
#  elif 1 == 2
            ((npy_bool *)data_out)[4] =
                            (((npy_bool *)data0)[4] &&
                             ((npy_bool *)data1)[4]) ||
                                ((npy_bool *)data_out)[4];
#  elif 1 == 3
            ((npy_bool *)data_out)[4] =
                           (((npy_bool *)data0)[4] &&
                            ((npy_bool *)data1)[4] &&
                            ((npy_bool *)data2)[4]) ||
                                ((npy_bool *)data_out)[4];
#  endif

#line 1401
        case 3+1:
#  if 1 == 1
            ((npy_bool *)data_out)[3] = ((npy_bool *)data0)[3] ||
                                            ((npy_bool *)data_out)[3];
#  elif 1 == 2
            ((npy_bool *)data_out)[3] =
                            (((npy_bool *)data0)[3] &&
                             ((npy_bool *)data1)[3]) ||
                                ((npy_bool *)data_out)[3];
#  elif 1 == 3
            ((npy_bool *)data_out)[3] =
                           (((npy_bool *)data0)[3] &&
                            ((npy_bool *)data1)[3] &&
                            ((npy_bool *)data2)[3]) ||
                                ((npy_bool *)data_out)[3];
#  endif

#line 1401
        case 2+1:
#  if 1 == 1
            ((npy_bool *)data_out)[2] = ((npy_bool *)data0)[2] ||
                                            ((npy_bool *)data_out)[2];
#  elif 1 == 2
            ((npy_bool *)data_out)[2] =
                            (((npy_bool *)data0)[2] &&
                             ((npy_bool *)data1)[2]) ||
                                ((npy_bool *)data_out)[2];
#  elif 1 == 3
            ((npy_bool *)data_out)[2] =
                           (((npy_bool *)data0)[2] &&
                            ((npy_bool *)data1)[2] &&
                            ((npy_bool *)data2)[2]) ||
                                ((npy_bool *)data_out)[2];
#  endif

#line 1401
        case 1+1:
#  if 1 == 1
            ((npy_bool *)data_out)[1] = ((npy_bool *)data0)[1] ||
                                            ((npy_bool *)data_out)[1];
#  elif 1 == 2
            ((npy_bool *)data_out)[1] =
                            (((npy_bool *)data0)[1] &&
                             ((npy_bool *)data1)[1]) ||
                                ((npy_bool *)data_out)[1];
#  elif 1 == 3
            ((npy_bool *)data_out)[1] =
                           (((npy_bool *)data0)[1] &&
                            ((npy_bool *)data1)[1] &&
                            ((npy_bool *)data2)[1]) ||
                                ((npy_bool *)data_out)[1];
#  endif

#line 1401
        case 0+1:
#  if 1 == 1
            ((npy_bool *)data_out)[0] = ((npy_bool *)data0)[0] ||
                                            ((npy_bool *)data_out)[0];
#  elif 1 == 2
            ((npy_bool *)data_out)[0] =
                            (((npy_bool *)data0)[0] &&
                             ((npy_bool *)data1)[0]) ||
                                ((npy_bool *)data_out)[0];
#  elif 1 == 3
            ((npy_bool *)data_out)[0] =
                           (((npy_bool *)data0)[0] &&
                            ((npy_bool *)data1)[0] &&
                            ((npy_bool *)data2)[0]) ||
                                ((npy_bool *)data_out)[0];
#  endif

        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (1 <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if 1 == 1
#line 1435
        *((npy_bool *)data_out + 0) = (*((npy_bool *)data0 + 0)) ||
                                        (*((npy_bool *)data_out + 0));

#line 1435
        *((npy_bool *)data_out + 1) = (*((npy_bool *)data0 + 1)) ||
                                        (*((npy_bool *)data_out + 1));

#line 1435
        *((npy_bool *)data_out + 2) = (*((npy_bool *)data0 + 2)) ||
                                        (*((npy_bool *)data_out + 2));

#line 1435
        *((npy_bool *)data_out + 3) = (*((npy_bool *)data0 + 3)) ||
                                        (*((npy_bool *)data_out + 3));

#line 1435
        *((npy_bool *)data_out + 4) = (*((npy_bool *)data0 + 4)) ||
                                        (*((npy_bool *)data_out + 4));

#line 1435
        *((npy_bool *)data_out + 5) = (*((npy_bool *)data0 + 5)) ||
                                        (*((npy_bool *)data_out + 5));

#line 1435
        *((npy_bool *)data_out + 6) = (*((npy_bool *)data0 + 6)) ||
                                        (*((npy_bool *)data_out + 6));

#line 1435
        *((npy_bool *)data_out + 7) = (*((npy_bool *)data0 + 7)) ||
                                        (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 1 == 2
#line 1444
        *((npy_bool *)data_out + 0) =
                        ((*((npy_bool *)data0 + 0)) &&
                         (*((npy_bool *)data1 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1444
        *((npy_bool *)data_out + 1) =
                        ((*((npy_bool *)data0 + 1)) &&
                         (*((npy_bool *)data1 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1444
        *((npy_bool *)data_out + 2) =
                        ((*((npy_bool *)data0 + 2)) &&
                         (*((npy_bool *)data1 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1444
        *((npy_bool *)data_out + 3) =
                        ((*((npy_bool *)data0 + 3)) &&
                         (*((npy_bool *)data1 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1444
        *((npy_bool *)data_out + 4) =
                        ((*((npy_bool *)data0 + 4)) &&
                         (*((npy_bool *)data1 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1444
        *((npy_bool *)data_out + 5) =
                        ((*((npy_bool *)data0 + 5)) &&
                         (*((npy_bool *)data1 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1444
        *((npy_bool *)data_out + 6) =
                        ((*((npy_bool *)data0 + 6)) &&
                         (*((npy_bool *)data1 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1444
        *((npy_bool *)data_out + 7) =
                        ((*((npy_bool *)data0 + 7)) &&
                         (*((npy_bool *)data1 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 1 == 3
#line 1456
        *((npy_bool *)data_out + 0) =
                       ((*((npy_bool *)data0 + 0)) &&
                        (*((npy_bool *)data1 + 0)) &&
                        (*((npy_bool *)data2 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1456
        *((npy_bool *)data_out + 1) =
                       ((*((npy_bool *)data0 + 1)) &&
                        (*((npy_bool *)data1 + 1)) &&
                        (*((npy_bool *)data2 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1456
        *((npy_bool *)data_out + 2) =
                       ((*((npy_bool *)data0 + 2)) &&
                        (*((npy_bool *)data1 + 2)) &&
                        (*((npy_bool *)data2 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1456
        *((npy_bool *)data_out + 3) =
                       ((*((npy_bool *)data0 + 3)) &&
                        (*((npy_bool *)data1 + 3)) &&
                        (*((npy_bool *)data2 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1456
        *((npy_bool *)data_out + 4) =
                       ((*((npy_bool *)data0 + 4)) &&
                        (*((npy_bool *)data1 + 4)) &&
                        (*((npy_bool *)data2 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1456
        *((npy_bool *)data_out + 5) =
                       ((*((npy_bool *)data0 + 5)) &&
                        (*((npy_bool *)data1 + 5)) &&
                        (*((npy_bool *)data2 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1456
        *((npy_bool *)data_out + 6) =
                       ((*((npy_bool *)data0 + 6)) &&
                        (*((npy_bool *)data1 + 6)) &&
                        (*((npy_bool *)data2 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1456
        *((npy_bool *)data_out + 7) =
                       ((*((npy_bool *)data0 + 7)) &&
                        (*((npy_bool *)data1 + 7)) &&
                        (*((npy_bool *)data2 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (1 <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_one(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (1 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1 == 2 || 1 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if 1 == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif 1 == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif 1 == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if 1 <= 3
    *((npy_bool *)dataptr[1]) = accum || *((npy_bool *)dataptr[1]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}


#line 1319

static void
bool_sum_of_products_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (2 <= 3)
    char *data_out = dataptr[2];
    npy_intp stride_out = strides[2];
#endif

    while (count--) {
#if 2 == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif 2 == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif 2 == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (2 <= 3)
    char *data0 = dataptr[0];
#endif
#if (2 == 2 || 2 == 3)
    char *data1 = dataptr[1];
#endif
#if (2 == 3)
    char *data2 = dataptr[2];
#endif
#if (2 <= 3)
    char *data_out = dataptr[2];
#endif

#if (2 <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1401
        case 6+1:
#  if 2 == 1
            ((npy_bool *)data_out)[6] = ((npy_bool *)data0)[6] ||
                                            ((npy_bool *)data_out)[6];
#  elif 2 == 2
            ((npy_bool *)data_out)[6] =
                            (((npy_bool *)data0)[6] &&
                             ((npy_bool *)data1)[6]) ||
                                ((npy_bool *)data_out)[6];
#  elif 2 == 3
            ((npy_bool *)data_out)[6] =
                           (((npy_bool *)data0)[6] &&
                            ((npy_bool *)data1)[6] &&
                            ((npy_bool *)data2)[6]) ||
                                ((npy_bool *)data_out)[6];
#  endif

#line 1401
        case 5+1:
#  if 2 == 1
            ((npy_bool *)data_out)[5] = ((npy_bool *)data0)[5] ||
                                            ((npy_bool *)data_out)[5];
#  elif 2 == 2
            ((npy_bool *)data_out)[5] =
                            (((npy_bool *)data0)[5] &&
                             ((npy_bool *)data1)[5]) ||
                                ((npy_bool *)data_out)[5];
#  elif 2 == 3
            ((npy_bool *)data_out)[5] =
                           (((npy_bool *)data0)[5] &&
                            ((npy_bool *)data1)[5] &&
                            ((npy_bool *)data2)[5]) ||
                                ((npy_bool *)data_out)[5];
#  endif

#line 1401
        case 4+1:
#  if 2 == 1
            ((npy_bool *)data_out)[4] = ((npy_bool *)data0)[4] ||
                                            ((npy_bool *)data_out)[4];
#  elif 2 == 2
            ((npy_bool *)data_out)[4] =
                            (((npy_bool *)data0)[4] &&
                             ((npy_bool *)data1)[4]) ||
                                ((npy_bool *)data_out)[4];
#  elif 2 == 3
            ((npy_bool *)data_out)[4] =
                           (((npy_bool *)data0)[4] &&
                            ((npy_bool *)data1)[4] &&
                            ((npy_bool *)data2)[4]) ||
                                ((npy_bool *)data_out)[4];
#  endif

#line 1401
        case 3+1:
#  if 2 == 1
            ((npy_bool *)data_out)[3] = ((npy_bool *)data0)[3] ||
                                            ((npy_bool *)data_out)[3];
#  elif 2 == 2
            ((npy_bool *)data_out)[3] =
                            (((npy_bool *)data0)[3] &&
                             ((npy_bool *)data1)[3]) ||
                                ((npy_bool *)data_out)[3];
#  elif 2 == 3
            ((npy_bool *)data_out)[3] =
                           (((npy_bool *)data0)[3] &&
                            ((npy_bool *)data1)[3] &&
                            ((npy_bool *)data2)[3]) ||
                                ((npy_bool *)data_out)[3];
#  endif

#line 1401
        case 2+1:
#  if 2 == 1
            ((npy_bool *)data_out)[2] = ((npy_bool *)data0)[2] ||
                                            ((npy_bool *)data_out)[2];
#  elif 2 == 2
            ((npy_bool *)data_out)[2] =
                            (((npy_bool *)data0)[2] &&
                             ((npy_bool *)data1)[2]) ||
                                ((npy_bool *)data_out)[2];
#  elif 2 == 3
            ((npy_bool *)data_out)[2] =
                           (((npy_bool *)data0)[2] &&
                            ((npy_bool *)data1)[2] &&
                            ((npy_bool *)data2)[2]) ||
                                ((npy_bool *)data_out)[2];
#  endif

#line 1401
        case 1+1:
#  if 2 == 1
            ((npy_bool *)data_out)[1] = ((npy_bool *)data0)[1] ||
                                            ((npy_bool *)data_out)[1];
#  elif 2 == 2
            ((npy_bool *)data_out)[1] =
                            (((npy_bool *)data0)[1] &&
                             ((npy_bool *)data1)[1]) ||
                                ((npy_bool *)data_out)[1];
#  elif 2 == 3
            ((npy_bool *)data_out)[1] =
                           (((npy_bool *)data0)[1] &&
                            ((npy_bool *)data1)[1] &&
                            ((npy_bool *)data2)[1]) ||
                                ((npy_bool *)data_out)[1];
#  endif

#line 1401
        case 0+1:
#  if 2 == 1
            ((npy_bool *)data_out)[0] = ((npy_bool *)data0)[0] ||
                                            ((npy_bool *)data_out)[0];
#  elif 2 == 2
            ((npy_bool *)data_out)[0] =
                            (((npy_bool *)data0)[0] &&
                             ((npy_bool *)data1)[0]) ||
                                ((npy_bool *)data_out)[0];
#  elif 2 == 3
            ((npy_bool *)data_out)[0] =
                           (((npy_bool *)data0)[0] &&
                            ((npy_bool *)data1)[0] &&
                            ((npy_bool *)data2)[0]) ||
                                ((npy_bool *)data_out)[0];
#  endif

        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (2 <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if 2 == 1
#line 1435
        *((npy_bool *)data_out + 0) = (*((npy_bool *)data0 + 0)) ||
                                        (*((npy_bool *)data_out + 0));

#line 1435
        *((npy_bool *)data_out + 1) = (*((npy_bool *)data0 + 1)) ||
                                        (*((npy_bool *)data_out + 1));

#line 1435
        *((npy_bool *)data_out + 2) = (*((npy_bool *)data0 + 2)) ||
                                        (*((npy_bool *)data_out + 2));

#line 1435
        *((npy_bool *)data_out + 3) = (*((npy_bool *)data0 + 3)) ||
                                        (*((npy_bool *)data_out + 3));

#line 1435
        *((npy_bool *)data_out + 4) = (*((npy_bool *)data0 + 4)) ||
                                        (*((npy_bool *)data_out + 4));

#line 1435
        *((npy_bool *)data_out + 5) = (*((npy_bool *)data0 + 5)) ||
                                        (*((npy_bool *)data_out + 5));

#line 1435
        *((npy_bool *)data_out + 6) = (*((npy_bool *)data0 + 6)) ||
                                        (*((npy_bool *)data_out + 6));

#line 1435
        *((npy_bool *)data_out + 7) = (*((npy_bool *)data0 + 7)) ||
                                        (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 2 == 2
#line 1444
        *((npy_bool *)data_out + 0) =
                        ((*((npy_bool *)data0 + 0)) &&
                         (*((npy_bool *)data1 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1444
        *((npy_bool *)data_out + 1) =
                        ((*((npy_bool *)data0 + 1)) &&
                         (*((npy_bool *)data1 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1444
        *((npy_bool *)data_out + 2) =
                        ((*((npy_bool *)data0 + 2)) &&
                         (*((npy_bool *)data1 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1444
        *((npy_bool *)data_out + 3) =
                        ((*((npy_bool *)data0 + 3)) &&
                         (*((npy_bool *)data1 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1444
        *((npy_bool *)data_out + 4) =
                        ((*((npy_bool *)data0 + 4)) &&
                         (*((npy_bool *)data1 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1444
        *((npy_bool *)data_out + 5) =
                        ((*((npy_bool *)data0 + 5)) &&
                         (*((npy_bool *)data1 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1444
        *((npy_bool *)data_out + 6) =
                        ((*((npy_bool *)data0 + 6)) &&
                         (*((npy_bool *)data1 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1444
        *((npy_bool *)data_out + 7) =
                        ((*((npy_bool *)data0 + 7)) &&
                         (*((npy_bool *)data1 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 2 == 3
#line 1456
        *((npy_bool *)data_out + 0) =
                       ((*((npy_bool *)data0 + 0)) &&
                        (*((npy_bool *)data1 + 0)) &&
                        (*((npy_bool *)data2 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1456
        *((npy_bool *)data_out + 1) =
                       ((*((npy_bool *)data0 + 1)) &&
                        (*((npy_bool *)data1 + 1)) &&
                        (*((npy_bool *)data2 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1456
        *((npy_bool *)data_out + 2) =
                       ((*((npy_bool *)data0 + 2)) &&
                        (*((npy_bool *)data1 + 2)) &&
                        (*((npy_bool *)data2 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1456
        *((npy_bool *)data_out + 3) =
                       ((*((npy_bool *)data0 + 3)) &&
                        (*((npy_bool *)data1 + 3)) &&
                        (*((npy_bool *)data2 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1456
        *((npy_bool *)data_out + 4) =
                       ((*((npy_bool *)data0 + 4)) &&
                        (*((npy_bool *)data1 + 4)) &&
                        (*((npy_bool *)data2 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1456
        *((npy_bool *)data_out + 5) =
                       ((*((npy_bool *)data0 + 5)) &&
                        (*((npy_bool *)data1 + 5)) &&
                        (*((npy_bool *)data2 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1456
        *((npy_bool *)data_out + 6) =
                       ((*((npy_bool *)data0 + 6)) &&
                        (*((npy_bool *)data1 + 6)) &&
                        (*((npy_bool *)data2 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1456
        *((npy_bool *)data_out + 7) =
                       ((*((npy_bool *)data0 + 7)) &&
                        (*((npy_bool *)data1 + 7)) &&
                        (*((npy_bool *)data2 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (2 <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_two(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (2 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (2 == 2 || 2 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (2 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if 2 == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif 2 == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif 2 == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if 2 <= 3
    *((npy_bool *)dataptr[2]) = accum || *((npy_bool *)dataptr[2]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}


#line 1319

static void
bool_sum_of_products_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (3 <= 3)
    char *data_out = dataptr[3];
    npy_intp stride_out = strides[3];
#endif

    while (count--) {
#if 3 == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif 3 == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif 3 == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (3 <= 3)
    char *data0 = dataptr[0];
#endif
#if (3 == 2 || 3 == 3)
    char *data1 = dataptr[1];
#endif
#if (3 == 3)
    char *data2 = dataptr[2];
#endif
#if (3 <= 3)
    char *data_out = dataptr[3];
#endif

#if (3 <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1401
        case 6+1:
#  if 3 == 1
            ((npy_bool *)data_out)[6] = ((npy_bool *)data0)[6] ||
                                            ((npy_bool *)data_out)[6];
#  elif 3 == 2
            ((npy_bool *)data_out)[6] =
                            (((npy_bool *)data0)[6] &&
                             ((npy_bool *)data1)[6]) ||
                                ((npy_bool *)data_out)[6];
#  elif 3 == 3
            ((npy_bool *)data_out)[6] =
                           (((npy_bool *)data0)[6] &&
                            ((npy_bool *)data1)[6] &&
                            ((npy_bool *)data2)[6]) ||
                                ((npy_bool *)data_out)[6];
#  endif

#line 1401
        case 5+1:
#  if 3 == 1
            ((npy_bool *)data_out)[5] = ((npy_bool *)data0)[5] ||
                                            ((npy_bool *)data_out)[5];
#  elif 3 == 2
            ((npy_bool *)data_out)[5] =
                            (((npy_bool *)data0)[5] &&
                             ((npy_bool *)data1)[5]) ||
                                ((npy_bool *)data_out)[5];
#  elif 3 == 3
            ((npy_bool *)data_out)[5] =
                           (((npy_bool *)data0)[5] &&
                            ((npy_bool *)data1)[5] &&
                            ((npy_bool *)data2)[5]) ||
                                ((npy_bool *)data_out)[5];
#  endif

#line 1401
        case 4+1:
#  if 3 == 1
            ((npy_bool *)data_out)[4] = ((npy_bool *)data0)[4] ||
                                            ((npy_bool *)data_out)[4];
#  elif 3 == 2
            ((npy_bool *)data_out)[4] =
                            (((npy_bool *)data0)[4] &&
                             ((npy_bool *)data1)[4]) ||
                                ((npy_bool *)data_out)[4];
#  elif 3 == 3
            ((npy_bool *)data_out)[4] =
                           (((npy_bool *)data0)[4] &&
                            ((npy_bool *)data1)[4] &&
                            ((npy_bool *)data2)[4]) ||
                                ((npy_bool *)data_out)[4];
#  endif

#line 1401
        case 3+1:
#  if 3 == 1
            ((npy_bool *)data_out)[3] = ((npy_bool *)data0)[3] ||
                                            ((npy_bool *)data_out)[3];
#  elif 3 == 2
            ((npy_bool *)data_out)[3] =
                            (((npy_bool *)data0)[3] &&
                             ((npy_bool *)data1)[3]) ||
                                ((npy_bool *)data_out)[3];
#  elif 3 == 3
            ((npy_bool *)data_out)[3] =
                           (((npy_bool *)data0)[3] &&
                            ((npy_bool *)data1)[3] &&
                            ((npy_bool *)data2)[3]) ||
                                ((npy_bool *)data_out)[3];
#  endif

#line 1401
        case 2+1:
#  if 3 == 1
            ((npy_bool *)data_out)[2] = ((npy_bool *)data0)[2] ||
                                            ((npy_bool *)data_out)[2];
#  elif 3 == 2
            ((npy_bool *)data_out)[2] =
                            (((npy_bool *)data0)[2] &&
                             ((npy_bool *)data1)[2]) ||
                                ((npy_bool *)data_out)[2];
#  elif 3 == 3
            ((npy_bool *)data_out)[2] =
                           (((npy_bool *)data0)[2] &&
                            ((npy_bool *)data1)[2] &&
                            ((npy_bool *)data2)[2]) ||
                                ((npy_bool *)data_out)[2];
#  endif

#line 1401
        case 1+1:
#  if 3 == 1
            ((npy_bool *)data_out)[1] = ((npy_bool *)data0)[1] ||
                                            ((npy_bool *)data_out)[1];
#  elif 3 == 2
            ((npy_bool *)data_out)[1] =
                            (((npy_bool *)data0)[1] &&
                             ((npy_bool *)data1)[1]) ||
                                ((npy_bool *)data_out)[1];
#  elif 3 == 3
            ((npy_bool *)data_out)[1] =
                           (((npy_bool *)data0)[1] &&
                            ((npy_bool *)data1)[1] &&
                            ((npy_bool *)data2)[1]) ||
                                ((npy_bool *)data_out)[1];
#  endif

#line 1401
        case 0+1:
#  if 3 == 1
            ((npy_bool *)data_out)[0] = ((npy_bool *)data0)[0] ||
                                            ((npy_bool *)data_out)[0];
#  elif 3 == 2
            ((npy_bool *)data_out)[0] =
                            (((npy_bool *)data0)[0] &&
                             ((npy_bool *)data1)[0]) ||
                                ((npy_bool *)data_out)[0];
#  elif 3 == 3
            ((npy_bool *)data_out)[0] =
                           (((npy_bool *)data0)[0] &&
                            ((npy_bool *)data1)[0] &&
                            ((npy_bool *)data2)[0]) ||
                                ((npy_bool *)data_out)[0];
#  endif

        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (3 <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if 3 == 1
#line 1435
        *((npy_bool *)data_out + 0) = (*((npy_bool *)data0 + 0)) ||
                                        (*((npy_bool *)data_out + 0));

#line 1435
        *((npy_bool *)data_out + 1) = (*((npy_bool *)data0 + 1)) ||
                                        (*((npy_bool *)data_out + 1));

#line 1435
        *((npy_bool *)data_out + 2) = (*((npy_bool *)data0 + 2)) ||
                                        (*((npy_bool *)data_out + 2));

#line 1435
        *((npy_bool *)data_out + 3) = (*((npy_bool *)data0 + 3)) ||
                                        (*((npy_bool *)data_out + 3));

#line 1435
        *((npy_bool *)data_out + 4) = (*((npy_bool *)data0 + 4)) ||
                                        (*((npy_bool *)data_out + 4));

#line 1435
        *((npy_bool *)data_out + 5) = (*((npy_bool *)data0 + 5)) ||
                                        (*((npy_bool *)data_out + 5));

#line 1435
        *((npy_bool *)data_out + 6) = (*((npy_bool *)data0 + 6)) ||
                                        (*((npy_bool *)data_out + 6));

#line 1435
        *((npy_bool *)data_out + 7) = (*((npy_bool *)data0 + 7)) ||
                                        (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 3 == 2
#line 1444
        *((npy_bool *)data_out + 0) =
                        ((*((npy_bool *)data0 + 0)) &&
                         (*((npy_bool *)data1 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1444
        *((npy_bool *)data_out + 1) =
                        ((*((npy_bool *)data0 + 1)) &&
                         (*((npy_bool *)data1 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1444
        *((npy_bool *)data_out + 2) =
                        ((*((npy_bool *)data0 + 2)) &&
                         (*((npy_bool *)data1 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1444
        *((npy_bool *)data_out + 3) =
                        ((*((npy_bool *)data0 + 3)) &&
                         (*((npy_bool *)data1 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1444
        *((npy_bool *)data_out + 4) =
                        ((*((npy_bool *)data0 + 4)) &&
                         (*((npy_bool *)data1 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1444
        *((npy_bool *)data_out + 5) =
                        ((*((npy_bool *)data0 + 5)) &&
                         (*((npy_bool *)data1 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1444
        *((npy_bool *)data_out + 6) =
                        ((*((npy_bool *)data0 + 6)) &&
                         (*((npy_bool *)data1 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1444
        *((npy_bool *)data_out + 7) =
                        ((*((npy_bool *)data0 + 7)) &&
                         (*((npy_bool *)data1 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 3 == 3
#line 1456
        *((npy_bool *)data_out + 0) =
                       ((*((npy_bool *)data0 + 0)) &&
                        (*((npy_bool *)data1 + 0)) &&
                        (*((npy_bool *)data2 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1456
        *((npy_bool *)data_out + 1) =
                       ((*((npy_bool *)data0 + 1)) &&
                        (*((npy_bool *)data1 + 1)) &&
                        (*((npy_bool *)data2 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1456
        *((npy_bool *)data_out + 2) =
                       ((*((npy_bool *)data0 + 2)) &&
                        (*((npy_bool *)data1 + 2)) &&
                        (*((npy_bool *)data2 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1456
        *((npy_bool *)data_out + 3) =
                       ((*((npy_bool *)data0 + 3)) &&
                        (*((npy_bool *)data1 + 3)) &&
                        (*((npy_bool *)data2 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1456
        *((npy_bool *)data_out + 4) =
                       ((*((npy_bool *)data0 + 4)) &&
                        (*((npy_bool *)data1 + 4)) &&
                        (*((npy_bool *)data2 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1456
        *((npy_bool *)data_out + 5) =
                       ((*((npy_bool *)data0 + 5)) &&
                        (*((npy_bool *)data1 + 5)) &&
                        (*((npy_bool *)data2 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1456
        *((npy_bool *)data_out + 6) =
                       ((*((npy_bool *)data0 + 6)) &&
                        (*((npy_bool *)data1 + 6)) &&
                        (*((npy_bool *)data2 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1456
        *((npy_bool *)data_out + 7) =
                       ((*((npy_bool *)data0 + 7)) &&
                        (*((npy_bool *)data1 + 7)) &&
                        (*((npy_bool *)data2 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (3 <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_three(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (3 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (3 == 2 || 3 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (3 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if 3 == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif 3 == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif 3 == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if 3 <= 3
    *((npy_bool *)dataptr[3]) = accum || *((npy_bool *)dataptr[3]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}


#line 1319

static void
bool_sum_of_products_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (1000 <= 3)
    char *data_out = dataptr[1000];
    npy_intp stride_out = strides[1000];
#endif

    while (count--) {
#if 1000 == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif 1000 == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif 1000 == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
#if (1000 <= 3)
    char *data0 = dataptr[0];
#endif
#if (1000 == 2 || 1000 == 3)
    char *data1 = dataptr[1];
#endif
#if (1000 == 3)
    char *data2 = dataptr[2];
#endif
#if (1000 <= 3)
    char *data_out = dataptr[1000];
#endif

#if (1000 <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
#line 1401
        case 6+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[6] = ((npy_bool *)data0)[6] ||
                                            ((npy_bool *)data_out)[6];
#  elif 1000 == 2
            ((npy_bool *)data_out)[6] =
                            (((npy_bool *)data0)[6] &&
                             ((npy_bool *)data1)[6]) ||
                                ((npy_bool *)data_out)[6];
#  elif 1000 == 3
            ((npy_bool *)data_out)[6] =
                           (((npy_bool *)data0)[6] &&
                            ((npy_bool *)data1)[6] &&
                            ((npy_bool *)data2)[6]) ||
                                ((npy_bool *)data_out)[6];
#  endif

#line 1401
        case 5+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[5] = ((npy_bool *)data0)[5] ||
                                            ((npy_bool *)data_out)[5];
#  elif 1000 == 2
            ((npy_bool *)data_out)[5] =
                            (((npy_bool *)data0)[5] &&
                             ((npy_bool *)data1)[5]) ||
                                ((npy_bool *)data_out)[5];
#  elif 1000 == 3
            ((npy_bool *)data_out)[5] =
                           (((npy_bool *)data0)[5] &&
                            ((npy_bool *)data1)[5] &&
                            ((npy_bool *)data2)[5]) ||
                                ((npy_bool *)data_out)[5];
#  endif

#line 1401
        case 4+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[4] = ((npy_bool *)data0)[4] ||
                                            ((npy_bool *)data_out)[4];
#  elif 1000 == 2
            ((npy_bool *)data_out)[4] =
                            (((npy_bool *)data0)[4] &&
                             ((npy_bool *)data1)[4]) ||
                                ((npy_bool *)data_out)[4];
#  elif 1000 == 3
            ((npy_bool *)data_out)[4] =
                           (((npy_bool *)data0)[4] &&
                            ((npy_bool *)data1)[4] &&
                            ((npy_bool *)data2)[4]) ||
                                ((npy_bool *)data_out)[4];
#  endif

#line 1401
        case 3+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[3] = ((npy_bool *)data0)[3] ||
                                            ((npy_bool *)data_out)[3];
#  elif 1000 == 2
            ((npy_bool *)data_out)[3] =
                            (((npy_bool *)data0)[3] &&
                             ((npy_bool *)data1)[3]) ||
                                ((npy_bool *)data_out)[3];
#  elif 1000 == 3
            ((npy_bool *)data_out)[3] =
                           (((npy_bool *)data0)[3] &&
                            ((npy_bool *)data1)[3] &&
                            ((npy_bool *)data2)[3]) ||
                                ((npy_bool *)data_out)[3];
#  endif

#line 1401
        case 2+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[2] = ((npy_bool *)data0)[2] ||
                                            ((npy_bool *)data_out)[2];
#  elif 1000 == 2
            ((npy_bool *)data_out)[2] =
                            (((npy_bool *)data0)[2] &&
                             ((npy_bool *)data1)[2]) ||
                                ((npy_bool *)data_out)[2];
#  elif 1000 == 3
            ((npy_bool *)data_out)[2] =
                           (((npy_bool *)data0)[2] &&
                            ((npy_bool *)data1)[2] &&
                            ((npy_bool *)data2)[2]) ||
                                ((npy_bool *)data_out)[2];
#  endif

#line 1401
        case 1+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[1] = ((npy_bool *)data0)[1] ||
                                            ((npy_bool *)data_out)[1];
#  elif 1000 == 2
            ((npy_bool *)data_out)[1] =
                            (((npy_bool *)data0)[1] &&
                             ((npy_bool *)data1)[1]) ||
                                ((npy_bool *)data_out)[1];
#  elif 1000 == 3
            ((npy_bool *)data_out)[1] =
                           (((npy_bool *)data0)[1] &&
                            ((npy_bool *)data1)[1] &&
                            ((npy_bool *)data2)[1]) ||
                                ((npy_bool *)data_out)[1];
#  endif

#line 1401
        case 0+1:
#  if 1000 == 1
            ((npy_bool *)data_out)[0] = ((npy_bool *)data0)[0] ||
                                            ((npy_bool *)data_out)[0];
#  elif 1000 == 2
            ((npy_bool *)data_out)[0] =
                            (((npy_bool *)data0)[0] &&
                             ((npy_bool *)data1)[0]) ||
                                ((npy_bool *)data_out)[0];
#  elif 1000 == 3
            ((npy_bool *)data_out)[0] =
                           (((npy_bool *)data0)[0] &&
                            ((npy_bool *)data1)[0] &&
                            ((npy_bool *)data2)[0]) ||
                                ((npy_bool *)data_out)[0];
#  endif

        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (1000 <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if 1000 == 1
#line 1435
        *((npy_bool *)data_out + 0) = (*((npy_bool *)data0 + 0)) ||
                                        (*((npy_bool *)data_out + 0));

#line 1435
        *((npy_bool *)data_out + 1) = (*((npy_bool *)data0 + 1)) ||
                                        (*((npy_bool *)data_out + 1));

#line 1435
        *((npy_bool *)data_out + 2) = (*((npy_bool *)data0 + 2)) ||
                                        (*((npy_bool *)data_out + 2));

#line 1435
        *((npy_bool *)data_out + 3) = (*((npy_bool *)data0 + 3)) ||
                                        (*((npy_bool *)data_out + 3));

#line 1435
        *((npy_bool *)data_out + 4) = (*((npy_bool *)data0 + 4)) ||
                                        (*((npy_bool *)data_out + 4));

#line 1435
        *((npy_bool *)data_out + 5) = (*((npy_bool *)data0 + 5)) ||
                                        (*((npy_bool *)data_out + 5));

#line 1435
        *((npy_bool *)data_out + 6) = (*((npy_bool *)data0 + 6)) ||
                                        (*((npy_bool *)data_out + 6));

#line 1435
        *((npy_bool *)data_out + 7) = (*((npy_bool *)data0 + 7)) ||
                                        (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 1000 == 2
#line 1444
        *((npy_bool *)data_out + 0) =
                        ((*((npy_bool *)data0 + 0)) &&
                         (*((npy_bool *)data1 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1444
        *((npy_bool *)data_out + 1) =
                        ((*((npy_bool *)data0 + 1)) &&
                         (*((npy_bool *)data1 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1444
        *((npy_bool *)data_out + 2) =
                        ((*((npy_bool *)data0 + 2)) &&
                         (*((npy_bool *)data1 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1444
        *((npy_bool *)data_out + 3) =
                        ((*((npy_bool *)data0 + 3)) &&
                         (*((npy_bool *)data1 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1444
        *((npy_bool *)data_out + 4) =
                        ((*((npy_bool *)data0 + 4)) &&
                         (*((npy_bool *)data1 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1444
        *((npy_bool *)data_out + 5) =
                        ((*((npy_bool *)data0 + 5)) &&
                         (*((npy_bool *)data1 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1444
        *((npy_bool *)data_out + 6) =
                        ((*((npy_bool *)data0 + 6)) &&
                         (*((npy_bool *)data1 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1444
        *((npy_bool *)data_out + 7) =
                        ((*((npy_bool *)data0 + 7)) &&
                         (*((npy_bool *)data1 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif 1000 == 3
#line 1456
        *((npy_bool *)data_out + 0) =
                       ((*((npy_bool *)data0 + 0)) &&
                        (*((npy_bool *)data1 + 0)) &&
                        (*((npy_bool *)data2 + 0))) ||
                            (*((npy_bool *)data_out + 0));

#line 1456
        *((npy_bool *)data_out + 1) =
                       ((*((npy_bool *)data0 + 1)) &&
                        (*((npy_bool *)data1 + 1)) &&
                        (*((npy_bool *)data2 + 1))) ||
                            (*((npy_bool *)data_out + 1));

#line 1456
        *((npy_bool *)data_out + 2) =
                       ((*((npy_bool *)data0 + 2)) &&
                        (*((npy_bool *)data1 + 2)) &&
                        (*((npy_bool *)data2 + 2))) ||
                            (*((npy_bool *)data_out + 2));

#line 1456
        *((npy_bool *)data_out + 3) =
                       ((*((npy_bool *)data0 + 3)) &&
                        (*((npy_bool *)data1 + 3)) &&
                        (*((npy_bool *)data2 + 3))) ||
                            (*((npy_bool *)data_out + 3));

#line 1456
        *((npy_bool *)data_out + 4) =
                       ((*((npy_bool *)data0 + 4)) &&
                        (*((npy_bool *)data1 + 4)) &&
                        (*((npy_bool *)data2 + 4))) ||
                            (*((npy_bool *)data_out + 4));

#line 1456
        *((npy_bool *)data_out + 5) =
                       ((*((npy_bool *)data0 + 5)) &&
                        (*((npy_bool *)data1 + 5)) &&
                        (*((npy_bool *)data2 + 5))) ||
                            (*((npy_bool *)data_out + 5));

#line 1456
        *((npy_bool *)data_out + 6) =
                       ((*((npy_bool *)data0 + 6)) &&
                        (*((npy_bool *)data1 + 6)) &&
                        (*((npy_bool *)data2 + 6))) ||
                            (*((npy_bool *)data_out + 6));

#line 1456
        *((npy_bool *)data_out + 7) =
                       ((*((npy_bool *)data0 + 7)) &&
                        (*((npy_bool *)data1 + 7)) &&
                        (*((npy_bool *)data2 + 7))) ||
                            (*((npy_bool *)data_out + 7));

        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (1000 <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_any(int nop, char **dataptr,
                                npy_intp *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (1000 <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (1000 == 2 || 1000 == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (1000 == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if 1000 == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif 1000 == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif 1000 == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if 1000 <= 3
    *((npy_bool *)dataptr[1000]) = accum || *((npy_bool *)dataptr[1000]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}



typedef void (*sum_of_products_fn)(int, char **, npy_intp *, npy_intp);

/* These tables need to match up with the type enum */
static sum_of_products_fn
_contig_outstride0_unary_specialization_table[NPY_NTYPES] = {
#line 1568
#if 0
    &bool_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &byte_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &ubyte_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &short_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &ushort_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &int_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &uint_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &long_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &ulong_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &longlong_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &ulonglong_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &float_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &double_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &longdouble_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &cfloat_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &cdouble_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &clongdouble_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &object_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &string_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &unicode_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &void_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &datetime_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 0
    &timedelta_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

#line 1568
#if 1
    &half_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif

}; /* End of _contig_outstride0_unary_specialization_table */

static sum_of_products_fn _binary_specialization_table[NPY_NTYPES][5] = {
#line 1599
#if 0
{
    &bool_sum_of_products_stride0_contig_outstride0_two,
    &bool_sum_of_products_stride0_contig_outcontig_two,
    &bool_sum_of_products_contig_stride0_outstride0_two,
    &bool_sum_of_products_contig_stride0_outcontig_two,
    &bool_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &byte_sum_of_products_stride0_contig_outstride0_two,
    &byte_sum_of_products_stride0_contig_outcontig_two,
    &byte_sum_of_products_contig_stride0_outstride0_two,
    &byte_sum_of_products_contig_stride0_outcontig_two,
    &byte_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &ubyte_sum_of_products_stride0_contig_outstride0_two,
    &ubyte_sum_of_products_stride0_contig_outcontig_two,
    &ubyte_sum_of_products_contig_stride0_outstride0_two,
    &ubyte_sum_of_products_contig_stride0_outcontig_two,
    &ubyte_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &short_sum_of_products_stride0_contig_outstride0_two,
    &short_sum_of_products_stride0_contig_outcontig_two,
    &short_sum_of_products_contig_stride0_outstride0_two,
    &short_sum_of_products_contig_stride0_outcontig_two,
    &short_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &ushort_sum_of_products_stride0_contig_outstride0_two,
    &ushort_sum_of_products_stride0_contig_outcontig_two,
    &ushort_sum_of_products_contig_stride0_outstride0_two,
    &ushort_sum_of_products_contig_stride0_outcontig_two,
    &ushort_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &int_sum_of_products_stride0_contig_outstride0_two,
    &int_sum_of_products_stride0_contig_outcontig_two,
    &int_sum_of_products_contig_stride0_outstride0_two,
    &int_sum_of_products_contig_stride0_outcontig_two,
    &int_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &uint_sum_of_products_stride0_contig_outstride0_two,
    &uint_sum_of_products_stride0_contig_outcontig_two,
    &uint_sum_of_products_contig_stride0_outstride0_two,
    &uint_sum_of_products_contig_stride0_outcontig_two,
    &uint_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &long_sum_of_products_stride0_contig_outstride0_two,
    &long_sum_of_products_stride0_contig_outcontig_two,
    &long_sum_of_products_contig_stride0_outstride0_two,
    &long_sum_of_products_contig_stride0_outcontig_two,
    &long_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &ulong_sum_of_products_stride0_contig_outstride0_two,
    &ulong_sum_of_products_stride0_contig_outcontig_two,
    &ulong_sum_of_products_contig_stride0_outstride0_two,
    &ulong_sum_of_products_contig_stride0_outcontig_two,
    &ulong_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &longlong_sum_of_products_stride0_contig_outstride0_two,
    &longlong_sum_of_products_stride0_contig_outcontig_two,
    &longlong_sum_of_products_contig_stride0_outstride0_two,
    &longlong_sum_of_products_contig_stride0_outcontig_two,
    &longlong_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &ulonglong_sum_of_products_stride0_contig_outstride0_two,
    &ulonglong_sum_of_products_stride0_contig_outcontig_two,
    &ulonglong_sum_of_products_contig_stride0_outstride0_two,
    &ulonglong_sum_of_products_contig_stride0_outcontig_two,
    &ulonglong_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &float_sum_of_products_stride0_contig_outstride0_two,
    &float_sum_of_products_stride0_contig_outcontig_two,
    &float_sum_of_products_contig_stride0_outstride0_two,
    &float_sum_of_products_contig_stride0_outcontig_two,
    &float_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &double_sum_of_products_stride0_contig_outstride0_two,
    &double_sum_of_products_stride0_contig_outcontig_two,
    &double_sum_of_products_contig_stride0_outstride0_two,
    &double_sum_of_products_contig_stride0_outcontig_two,
    &double_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &longdouble_sum_of_products_stride0_contig_outstride0_two,
    &longdouble_sum_of_products_stride0_contig_outcontig_two,
    &longdouble_sum_of_products_contig_stride0_outstride0_two,
    &longdouble_sum_of_products_contig_stride0_outcontig_two,
    &longdouble_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &cfloat_sum_of_products_stride0_contig_outstride0_two,
    &cfloat_sum_of_products_stride0_contig_outcontig_two,
    &cfloat_sum_of_products_contig_stride0_outstride0_two,
    &cfloat_sum_of_products_contig_stride0_outcontig_two,
    &cfloat_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &cdouble_sum_of_products_stride0_contig_outstride0_two,
    &cdouble_sum_of_products_stride0_contig_outcontig_two,
    &cdouble_sum_of_products_contig_stride0_outstride0_two,
    &cdouble_sum_of_products_contig_stride0_outcontig_two,
    &cdouble_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &clongdouble_sum_of_products_stride0_contig_outstride0_two,
    &clongdouble_sum_of_products_stride0_contig_outcontig_two,
    &clongdouble_sum_of_products_contig_stride0_outstride0_two,
    &clongdouble_sum_of_products_contig_stride0_outcontig_two,
    &clongdouble_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &object_sum_of_products_stride0_contig_outstride0_two,
    &object_sum_of_products_stride0_contig_outcontig_two,
    &object_sum_of_products_contig_stride0_outstride0_two,
    &object_sum_of_products_contig_stride0_outcontig_two,
    &object_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &string_sum_of_products_stride0_contig_outstride0_two,
    &string_sum_of_products_stride0_contig_outcontig_two,
    &string_sum_of_products_contig_stride0_outstride0_two,
    &string_sum_of_products_contig_stride0_outcontig_two,
    &string_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &unicode_sum_of_products_stride0_contig_outstride0_two,
    &unicode_sum_of_products_stride0_contig_outcontig_two,
    &unicode_sum_of_products_contig_stride0_outstride0_two,
    &unicode_sum_of_products_contig_stride0_outcontig_two,
    &unicode_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &void_sum_of_products_stride0_contig_outstride0_two,
    &void_sum_of_products_stride0_contig_outcontig_two,
    &void_sum_of_products_contig_stride0_outstride0_two,
    &void_sum_of_products_contig_stride0_outcontig_two,
    &void_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &datetime_sum_of_products_stride0_contig_outstride0_two,
    &datetime_sum_of_products_stride0_contig_outcontig_two,
    &datetime_sum_of_products_contig_stride0_outstride0_two,
    &datetime_sum_of_products_contig_stride0_outcontig_two,
    &datetime_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 0
{
    &timedelta_sum_of_products_stride0_contig_outstride0_two,
    &timedelta_sum_of_products_stride0_contig_outcontig_two,
    &timedelta_sum_of_products_contig_stride0_outstride0_two,
    &timedelta_sum_of_products_contig_stride0_outcontig_two,
    &timedelta_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

#line 1599
#if 1
{
    &half_sum_of_products_stride0_contig_outstride0_two,
    &half_sum_of_products_stride0_contig_outcontig_two,
    &half_sum_of_products_contig_stride0_outstride0_two,
    &half_sum_of_products_contig_stride0_outcontig_two,
    &half_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif

}; /* End of _binary_specialization_table */

static sum_of_products_fn _outstride0_specialized_table[NPY_NTYPES][4] = {
#line 1636
#if 1
{
    &bool_sum_of_products_outstride0_any,
    &bool_sum_of_products_outstride0_one,
    &bool_sum_of_products_outstride0_two,
    &bool_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &byte_sum_of_products_outstride0_any,
    &byte_sum_of_products_outstride0_one,
    &byte_sum_of_products_outstride0_two,
    &byte_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &ubyte_sum_of_products_outstride0_any,
    &ubyte_sum_of_products_outstride0_one,
    &ubyte_sum_of_products_outstride0_two,
    &ubyte_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &short_sum_of_products_outstride0_any,
    &short_sum_of_products_outstride0_one,
    &short_sum_of_products_outstride0_two,
    &short_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &ushort_sum_of_products_outstride0_any,
    &ushort_sum_of_products_outstride0_one,
    &ushort_sum_of_products_outstride0_two,
    &ushort_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &int_sum_of_products_outstride0_any,
    &int_sum_of_products_outstride0_one,
    &int_sum_of_products_outstride0_two,
    &int_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &uint_sum_of_products_outstride0_any,
    &uint_sum_of_products_outstride0_one,
    &uint_sum_of_products_outstride0_two,
    &uint_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &long_sum_of_products_outstride0_any,
    &long_sum_of_products_outstride0_one,
    &long_sum_of_products_outstride0_two,
    &long_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &ulong_sum_of_products_outstride0_any,
    &ulong_sum_of_products_outstride0_one,
    &ulong_sum_of_products_outstride0_two,
    &ulong_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &longlong_sum_of_products_outstride0_any,
    &longlong_sum_of_products_outstride0_one,
    &longlong_sum_of_products_outstride0_two,
    &longlong_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &ulonglong_sum_of_products_outstride0_any,
    &ulonglong_sum_of_products_outstride0_one,
    &ulonglong_sum_of_products_outstride0_two,
    &ulonglong_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &float_sum_of_products_outstride0_any,
    &float_sum_of_products_outstride0_one,
    &float_sum_of_products_outstride0_two,
    &float_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &double_sum_of_products_outstride0_any,
    &double_sum_of_products_outstride0_one,
    &double_sum_of_products_outstride0_two,
    &double_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &longdouble_sum_of_products_outstride0_any,
    &longdouble_sum_of_products_outstride0_one,
    &longdouble_sum_of_products_outstride0_two,
    &longdouble_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &cfloat_sum_of_products_outstride0_any,
    &cfloat_sum_of_products_outstride0_one,
    &cfloat_sum_of_products_outstride0_two,
    &cfloat_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &cdouble_sum_of_products_outstride0_any,
    &cdouble_sum_of_products_outstride0_one,
    &cdouble_sum_of_products_outstride0_two,
    &cdouble_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &clongdouble_sum_of_products_outstride0_any,
    &clongdouble_sum_of_products_outstride0_one,
    &clongdouble_sum_of_products_outstride0_two,
    &clongdouble_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &object_sum_of_products_outstride0_any,
    &object_sum_of_products_outstride0_one,
    &object_sum_of_products_outstride0_two,
    &object_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &string_sum_of_products_outstride0_any,
    &string_sum_of_products_outstride0_one,
    &string_sum_of_products_outstride0_two,
    &string_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &unicode_sum_of_products_outstride0_any,
    &unicode_sum_of_products_outstride0_one,
    &unicode_sum_of_products_outstride0_two,
    &unicode_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &void_sum_of_products_outstride0_any,
    &void_sum_of_products_outstride0_one,
    &void_sum_of_products_outstride0_two,
    &void_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &datetime_sum_of_products_outstride0_any,
    &datetime_sum_of_products_outstride0_one,
    &datetime_sum_of_products_outstride0_two,
    &datetime_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 0
{
    &timedelta_sum_of_products_outstride0_any,
    &timedelta_sum_of_products_outstride0_one,
    &timedelta_sum_of_products_outstride0_two,
    &timedelta_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1636
#if 1
{
    &half_sum_of_products_outstride0_any,
    &half_sum_of_products_outstride0_one,
    &half_sum_of_products_outstride0_two,
    &half_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

}; /* End of _outstride0_specialized_table */

static sum_of_products_fn _allcontig_specialized_table[NPY_NTYPES][4] = {
#line 1672
#if 1
{
    &bool_sum_of_products_contig_any,
    &bool_sum_of_products_contig_one,
    &bool_sum_of_products_contig_two,
    &bool_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &byte_sum_of_products_contig_any,
    &byte_sum_of_products_contig_one,
    &byte_sum_of_products_contig_two,
    &byte_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &ubyte_sum_of_products_contig_any,
    &ubyte_sum_of_products_contig_one,
    &ubyte_sum_of_products_contig_two,
    &ubyte_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &short_sum_of_products_contig_any,
    &short_sum_of_products_contig_one,
    &short_sum_of_products_contig_two,
    &short_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &ushort_sum_of_products_contig_any,
    &ushort_sum_of_products_contig_one,
    &ushort_sum_of_products_contig_two,
    &ushort_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &int_sum_of_products_contig_any,
    &int_sum_of_products_contig_one,
    &int_sum_of_products_contig_two,
    &int_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &uint_sum_of_products_contig_any,
    &uint_sum_of_products_contig_one,
    &uint_sum_of_products_contig_two,
    &uint_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &long_sum_of_products_contig_any,
    &long_sum_of_products_contig_one,
    &long_sum_of_products_contig_two,
    &long_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &ulong_sum_of_products_contig_any,
    &ulong_sum_of_products_contig_one,
    &ulong_sum_of_products_contig_two,
    &ulong_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &longlong_sum_of_products_contig_any,
    &longlong_sum_of_products_contig_one,
    &longlong_sum_of_products_contig_two,
    &longlong_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &ulonglong_sum_of_products_contig_any,
    &ulonglong_sum_of_products_contig_one,
    &ulonglong_sum_of_products_contig_two,
    &ulonglong_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &float_sum_of_products_contig_any,
    &float_sum_of_products_contig_one,
    &float_sum_of_products_contig_two,
    &float_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &double_sum_of_products_contig_any,
    &double_sum_of_products_contig_one,
    &double_sum_of_products_contig_two,
    &double_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &longdouble_sum_of_products_contig_any,
    &longdouble_sum_of_products_contig_one,
    &longdouble_sum_of_products_contig_two,
    &longdouble_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &cfloat_sum_of_products_contig_any,
    &cfloat_sum_of_products_contig_one,
    &cfloat_sum_of_products_contig_two,
    &cfloat_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &cdouble_sum_of_products_contig_any,
    &cdouble_sum_of_products_contig_one,
    &cdouble_sum_of_products_contig_two,
    &cdouble_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &clongdouble_sum_of_products_contig_any,
    &clongdouble_sum_of_products_contig_one,
    &clongdouble_sum_of_products_contig_two,
    &clongdouble_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &object_sum_of_products_contig_any,
    &object_sum_of_products_contig_one,
    &object_sum_of_products_contig_two,
    &object_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &string_sum_of_products_contig_any,
    &string_sum_of_products_contig_one,
    &string_sum_of_products_contig_two,
    &string_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &unicode_sum_of_products_contig_any,
    &unicode_sum_of_products_contig_one,
    &unicode_sum_of_products_contig_two,
    &unicode_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &void_sum_of_products_contig_any,
    &void_sum_of_products_contig_one,
    &void_sum_of_products_contig_two,
    &void_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &datetime_sum_of_products_contig_any,
    &datetime_sum_of_products_contig_one,
    &datetime_sum_of_products_contig_two,
    &datetime_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 0
{
    &timedelta_sum_of_products_contig_any,
    &timedelta_sum_of_products_contig_one,
    &timedelta_sum_of_products_contig_two,
    &timedelta_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1672
#if 1
{
    &half_sum_of_products_contig_any,
    &half_sum_of_products_contig_one,
    &half_sum_of_products_contig_two,
    &half_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

}; /* End of _allcontig_specialized_table */

static sum_of_products_fn _unspecialized_table[NPY_NTYPES][4] = {
#line 1708
#if 1
{
    &bool_sum_of_products_any,
    &bool_sum_of_products_one,
    &bool_sum_of_products_two,
    &bool_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &byte_sum_of_products_any,
    &byte_sum_of_products_one,
    &byte_sum_of_products_two,
    &byte_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &ubyte_sum_of_products_any,
    &ubyte_sum_of_products_one,
    &ubyte_sum_of_products_two,
    &ubyte_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &short_sum_of_products_any,
    &short_sum_of_products_one,
    &short_sum_of_products_two,
    &short_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &ushort_sum_of_products_any,
    &ushort_sum_of_products_one,
    &ushort_sum_of_products_two,
    &ushort_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &int_sum_of_products_any,
    &int_sum_of_products_one,
    &int_sum_of_products_two,
    &int_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &uint_sum_of_products_any,
    &uint_sum_of_products_one,
    &uint_sum_of_products_two,
    &uint_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &long_sum_of_products_any,
    &long_sum_of_products_one,
    &long_sum_of_products_two,
    &long_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &ulong_sum_of_products_any,
    &ulong_sum_of_products_one,
    &ulong_sum_of_products_two,
    &ulong_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &longlong_sum_of_products_any,
    &longlong_sum_of_products_one,
    &longlong_sum_of_products_two,
    &longlong_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &ulonglong_sum_of_products_any,
    &ulonglong_sum_of_products_one,
    &ulonglong_sum_of_products_two,
    &ulonglong_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &float_sum_of_products_any,
    &float_sum_of_products_one,
    &float_sum_of_products_two,
    &float_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &double_sum_of_products_any,
    &double_sum_of_products_one,
    &double_sum_of_products_two,
    &double_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &longdouble_sum_of_products_any,
    &longdouble_sum_of_products_one,
    &longdouble_sum_of_products_two,
    &longdouble_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &cfloat_sum_of_products_any,
    &cfloat_sum_of_products_one,
    &cfloat_sum_of_products_two,
    &cfloat_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &cdouble_sum_of_products_any,
    &cdouble_sum_of_products_one,
    &cdouble_sum_of_products_two,
    &cdouble_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &clongdouble_sum_of_products_any,
    &clongdouble_sum_of_products_one,
    &clongdouble_sum_of_products_two,
    &clongdouble_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &object_sum_of_products_any,
    &object_sum_of_products_one,
    &object_sum_of_products_two,
    &object_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &string_sum_of_products_any,
    &string_sum_of_products_one,
    &string_sum_of_products_two,
    &string_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &unicode_sum_of_products_any,
    &unicode_sum_of_products_one,
    &unicode_sum_of_products_two,
    &unicode_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &void_sum_of_products_any,
    &void_sum_of_products_one,
    &void_sum_of_products_two,
    &void_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &datetime_sum_of_products_any,
    &datetime_sum_of_products_one,
    &datetime_sum_of_products_two,
    &datetime_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 0
{
    &timedelta_sum_of_products_any,
    &timedelta_sum_of_products_one,
    &timedelta_sum_of_products_two,
    &timedelta_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

#line 1708
#if 1
{
    &half_sum_of_products_any,
    &half_sum_of_products_one,
    &half_sum_of_products_two,
    &half_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif

}; /* End of _unnspecialized_table */

static sum_of_products_fn
get_sum_of_products_function(int nop, int type_num,
                             npy_intp itemsize, npy_intp *fixed_strides)
{
    int iop;

    if (type_num >= NPY_NTYPES) {
        return NULL;
    }

    /* contiguous reduction */
    if (nop == 1 && fixed_strides[0] == itemsize && fixed_strides[1] == 0) {
        sum_of_products_fn ret =
            _contig_outstride0_unary_specialization_table[type_num];
        if (ret != NULL) {
            return ret;
        }
    }

    /* nop of 2 has more specializations */
    if (nop == 2) {
        /* Encode the zero/contiguous strides */
        int code;
        code = (fixed_strides[0] == 0) ? 0 :
                    (fixed_strides[0] == itemsize) ? 2*2*1 : 8;
        code += (fixed_strides[1] == 0) ? 0 :
                    (fixed_strides[1] == itemsize) ? 2*1 : 8;
        code += (fixed_strides[2] == 0) ? 0 :
                    (fixed_strides[2] == itemsize) ? 1 : 8;
        if (code >= 2 && code < 7) {
            sum_of_products_fn ret =
                        _binary_specialization_table[type_num][code-2];
            if (ret != NULL) {
                return ret;
            }
        }
    }

    /* Inner loop with an output stride of 0 */
    if (fixed_strides[nop] == 0) {
        return _outstride0_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* Check for all contiguous */
    for (iop = 0; iop < nop + 1; ++iop) {
        if (fixed_strides[iop] != itemsize) {
            break;
        }
    }

    /* Contiguous loop */
    if (iop == nop + 1) {
        return _allcontig_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* None of the above specializations caught it, general loops */
    return _unspecialized_table[type_num][nop <= 3 ? nop : 0];
}


/*
 * Parses the subscripts for one operand into an output of 'ndim'
 * labels. The resulting 'op_labels' array will have:
 *  - the ASCII code of the label for the first occurrence of a label;
 *  - the (negative) offset to the first occurrence of the label for
 *    repeated labels;
 *  - zero for broadcast dimensions, if subscripts has an ellipsis.
 * For example:
 *  - subscripts="abbcbc",  ndim=6 -> op_labels=[97, 98, -1, 99, -3, -2]
 *  - subscripts="ab...bc", ndim=6 -> op_labels=[97, 98, 0, 0, -3, 99]
 */

static int
parse_operand_subscripts(char *subscripts, int length,
                         int ndim, int iop, char *op_labels,
                         char *label_counts, int *min_label, int *max_label)
{
    int i;
    int idim = 0;
    int ellipsis = -1;

    /* Process all labels for this operand */
    for (i = 0; i < length; ++i) {
        int label = subscripts[i];

        /* A proper label for an axis. */
        if (label > 0 && isalpha(label)) {
            /* Check we don't exceed the operator dimensions. */
            if (idim >= ndim) {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string contains "
                             "too many subscripts for operand %d", iop);
                return -1;
            }

            op_labels[idim++] = label;
            if (label < *min_label) {
                *min_label = label;
            }
            if (label > *max_label) {
                *max_label = label;
            }
            label_counts[label]++;
        }
        /* The beginning of the ellipsis. */
        else if (label == '.') {
            /* Check it's a proper ellipsis. */
            if (ellipsis != -1 || i + 2 >= length
                    || subscripts[++i] != '.' || subscripts[++i] != '.') {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string contains a "
                             "'.' that is not part of an ellipsis ('...') "
                             "in operand %d", iop);
                return -1;
            }

            ellipsis = idim;
        }
        else if (label != ' ') {
            PyErr_Format(PyExc_ValueError,
                         "invalid subscript '%c' in einstein sum "
                         "subscripts string, subscripts must "
                         "be letters", (char)label);
            return -1;
        }
    }

    /* No ellipsis found, labels must match dimensions exactly. */
    if (ellipsis == -1) {
        if (idim != ndim) {
            PyErr_Format(PyExc_ValueError,
                         "operand has more dimensions than subscripts "
                         "given in einstein sum, but no '...' ellipsis "
                         "provided to broadcast the extra dimensions.");
            return -1;
        }
    }
    /* Ellipsis found, may have to add broadcast dimensions. */
    else if (idim < ndim) {
        /* Move labels after ellipsis to the end. */
        for (i = 0; i < idim - ellipsis; ++i) {
            op_labels[ndim - i - 1] = op_labels[idim - i - 1];
        }
        /* Set all broadcast dimensions to zero. */
        for (i = 0; i < ndim - idim; ++i) {
            op_labels[ellipsis + i] = 0;
        }
    }

    /*
     * Find any labels duplicated for this operand, and turn them
     * into negative offsets to the axis to merge with.
     *
     * In C, the char type may be signed or unsigned, but with
     * twos complement arithmetic the char is ok either way here, and
     * later where it matters the char is cast to a signed char.
     */
    for (idim = 0; idim < ndim - 1; ++idim) {
        int label = op_labels[idim];
        /* If it is a proper label, find any duplicates of it. */
        if (label > 0) {
            /* Search for the next matching label. */
            char *next = memchr(op_labels + idim + 1, label, ndim - idim - 1);

            while (next != NULL) {
                /* The offset from next to op_labels[idim] (negative). */
                *next = (char)((op_labels + idim) - next);
                /* Search for the next matching label. */
                next = memchr(next + 1, label, op_labels + ndim - 1 - next);
            }
        }
    }

    return 0;
}


/*
 * Parses the subscripts for the output operand into an output that
 * includes 'ndim_broadcast' unlabeled dimensions, and returns the total
 * number of output dimensions, or -1 if there is an error. Similarly
 * to parse_operand_subscripts, the 'out_labels' array will have, for
 * each dimension:
 *  - the ASCII code of the corresponding label;
 *  - zero for broadcast dimensions, if subscripts has an ellipsis.
 */
static int
parse_output_subscripts(char *subscripts, int length,
                        int ndim_broadcast,
                        const char *label_counts, char *out_labels)
{
    int i, bdim;
    int ndim = 0;
    int ellipsis = 0;

    /* Process all the output labels. */
    for (i = 0; i < length; ++i) {
        int label = subscripts[i];

        /* A proper label for an axis. */
        if (label > 0 && isalpha(label)) {
            /* Check that it doesn't occur again. */
            if (memchr(subscripts + i + 1, label, length - i - 1) != NULL) {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string includes "
                             "output subscript '%c' multiple times",
                             (char)label);
                return -1;
            }
            /* Check that it was used in the inputs. */
            if (label_counts[label] == 0) {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string included "
                             "output subscript '%c' which never appeared "
                             "in an input", (char)label);
                return -1;
            }
            /* Check that there is room in out_labels for this label. */
            if (ndim >= NPY_MAXDIMS) {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string contains "
                             "too many subscripts in the output");
                return -1;
            }

            out_labels[ndim++] = label;
        }
        /* The beginning of the ellipsis. */
        else if (label == '.') {
            /* Check it is a proper ellipsis. */
            if (ellipsis || i + 2 >= length
                    || subscripts[++i] != '.' || subscripts[++i] != '.') {
                PyErr_SetString(PyExc_ValueError,
                                "einstein sum subscripts string "
                                "contains a '.' that is not part of "
                                "an ellipsis ('...') in the output");
                return -1;
            }
            /* Check there is room in out_labels for broadcast dims. */
            if (ndim + ndim_broadcast > NPY_MAXDIMS) {
                PyErr_Format(PyExc_ValueError,
                             "einstein sum subscripts string contains "
                             "too many subscripts in the output");
                return -1;
            }

            ellipsis = 1;
            for (bdim = 0; bdim < ndim_broadcast; ++bdim) {
                out_labels[ndim++] = 0;
            }
        }
        else if (label != ' ') {
            PyErr_Format(PyExc_ValueError,
                         "invalid subscript '%c' in einstein sum "
                         "subscripts string, subscripts must "
                         "be letters", (char)label);
            return -1;
        }
    }

    /* If no ellipsis was found there should be no broadcast dimensions. */
    if (!ellipsis && ndim_broadcast > 0) {
        PyErr_SetString(PyExc_ValueError,
                        "output has more dimensions than subscripts "
                        "given in einstein sum, but no '...' ellipsis "
                        "provided to broadcast the extra dimensions.");
        return -1;
    }

    return ndim;
}


/*
 * When there's just one operand and no reduction, we
 * can return a view into op.  This calculates the view
 * if possible.
 */
static int
get_single_op_view(PyArrayObject *op, int  iop, char *labels,
                   int ndim_output, char *output_labels,
                   PyArrayObject **ret)
{
    npy_intp new_strides[NPY_MAXDIMS];
    npy_intp new_dims[NPY_MAXDIMS];
    char *out_label;
    int label, i, idim, ndim, ibroadcast = 0;

    ndim = PyArray_NDIM(op);

    /* Initialize the dimensions and strides to zero */
    for (idim = 0; idim < ndim_output; ++idim) {
        new_dims[idim] = 0;
        new_strides[idim] = 0;
    }

    /* Match the labels in the operand with the output labels */
    for (idim = 0; idim < ndim; ++idim) {
        /*
         * The char type may be either signed or unsigned, we
         * need it to be signed here.
         */
        label = (signed char)labels[idim];
        /* If this label says to merge axes, get the actual label */
        if (label < 0) {
            label = labels[idim+label];
        }
        /* If the label is 0, it's an unlabeled broadcast dimension */
        if (label == 0) {
            /* The next output label that's a broadcast dimension */
            for (; ibroadcast < ndim_output; ++ibroadcast) {
                if (output_labels[ibroadcast] == 0) {
                    break;
                }
            }
            if (ibroadcast == ndim_output) {
                PyErr_SetString(PyExc_ValueError,
                        "output had too few broadcast dimensions");
                return -1;
            }
            new_dims[ibroadcast] = PyArray_DIM(op, idim);
            new_strides[ibroadcast] = PyArray_STRIDE(op, idim);
            ++ibroadcast;
        }
        else {
            /* Find the position for this dimension in the output */
            out_label = (char *)memchr(output_labels, label,
                                                    ndim_output);
            /* If it's not found, reduction -> can't return a view */
            if (out_label == NULL) {
                break;
            }
            /* Update the dimensions and strides of the output */
            i = out_label - output_labels;
            if (new_dims[i] != 0 &&
                    new_dims[i] != PyArray_DIM(op, idim)) {
                PyErr_Format(PyExc_ValueError,
                        "dimensions in operand %d for collapsing "
                        "index '%c' don't match (%d != %d)",
                        iop, label, (int)new_dims[i],
                        (int)PyArray_DIM(op, idim));
                return -1;
            }
            new_dims[i] = PyArray_DIM(op, idim);
            new_strides[i] += PyArray_STRIDE(op, idim);
        }
    }
    /* If we processed all the input axes, return a view */
    if (idim == ndim) {
        Py_INCREF(PyArray_DESCR(op));
        *ret = (PyArrayObject *)PyArray_NewFromDescr_int(
                Py_TYPE(op), PyArray_DESCR(op),
                ndim_output, new_dims, new_strides, PyArray_DATA(op),
                PyArray_ISWRITEABLE(op) ? NPY_ARRAY_WRITEABLE : 0,
                (PyObject *)op, (PyObject *)op,
                0, 0);

        if (*ret == NULL) {
            return -1;
        }
        return 0;
    }

    /* Return success, but that we couldn't make a view */
    *ret = NULL;
    return 0;
}

static PyArrayObject *
get_combined_dims_view(PyArrayObject *op, int iop, char *labels)
{
    npy_intp new_strides[NPY_MAXDIMS];
    npy_intp new_dims[NPY_MAXDIMS];
    int idim, ndim, icombine, combineoffset;
    int icombinemap[NPY_MAXDIMS];

    PyArrayObject *ret = NULL;

    ndim = PyArray_NDIM(op);

    /* Initialize the dimensions and strides to zero */
    for (idim = 0; idim < ndim; ++idim) {
        new_dims[idim] = 0;
        new_strides[idim] = 0;
    }

    /* Copy the dimensions and strides, except when collapsing */
    icombine = 0;
    for (idim = 0; idim < ndim; ++idim) {
        /*
         * The char type may be either signed or unsigned, we
         * need it to be signed here.
         */
        int label = (signed char)labels[idim];
        /* If this label says to merge axes, get the actual label */
        if (label < 0) {
            combineoffset = label;
            label = labels[idim+label];
        }
        else {
            combineoffset = 0;
            if (icombine != idim) {
                labels[icombine] = labels[idim];
            }
            icombinemap[idim] = icombine;
        }
        /* If the label is 0, it's an unlabeled broadcast dimension */
        if (label == 0) {
            new_dims[icombine] = PyArray_DIM(op, idim);
            new_strides[icombine] = PyArray_STRIDE(op, idim);
        }
        else {
            /* Update the combined axis dimensions and strides */
            int i = icombinemap[idim + combineoffset];
            if (combineoffset < 0 && new_dims[i] != 0 &&
                        new_dims[i] != PyArray_DIM(op, idim)) {
                PyErr_Format(PyExc_ValueError,
                        "dimensions in operand %d for collapsing "
                        "index '%c' don't match (%d != %d)",
                        iop, label, (int)new_dims[i],
                        (int)PyArray_DIM(op, idim));
                return NULL;
            }
            new_dims[i] = PyArray_DIM(op, idim);
            new_strides[i] += PyArray_STRIDE(op, idim);
        }

        /* If the label didn't say to combine axes, increment dest i */
        if (combineoffset == 0) {
            icombine++;
        }
    }

    /* The compressed number of dimensions */
    ndim = icombine;

    Py_INCREF(PyArray_DESCR(op));
    ret = (PyArrayObject *)PyArray_NewFromDescrAndBase(
            Py_TYPE(op), PyArray_DESCR(op),
            ndim, new_dims, new_strides, PyArray_DATA(op),
            PyArray_ISWRITEABLE(op) ? NPY_ARRAY_WRITEABLE : 0,
            (PyObject *)op, (PyObject *)op);
    return ret;
}

static int
prepare_op_axes(int ndim, int iop, char *labels, int *axes,
            int ndim_iter, char *iter_labels)
{
    int i, label, ibroadcast;

    ibroadcast = ndim-1;
    for (i = ndim_iter-1; i >= 0; --i) {
        label = iter_labels[i];
        /*
         * If it's an unlabeled broadcast dimension, choose
         * the next broadcast dimension from the operand.
         */
        if (label == 0) {
            while (ibroadcast >= 0 && labels[ibroadcast] != 0) {
                --ibroadcast;
            }
            /*
             * If we used up all the operand broadcast dimensions,
             * extend it with a "newaxis"
             */
            if (ibroadcast < 0) {
                axes[i] = -1;
            }
            /* Otherwise map to the broadcast axis */
            else {
                axes[i] = ibroadcast;
                --ibroadcast;
            }
        }
        /* It's a labeled dimension, find the matching one */
        else {
            char *match = memchr(labels, label, ndim);
            /* If the op doesn't have the label, broadcast it */
            if (match == NULL) {
                axes[i] = -1;
            }
            /* Otherwise use it */
            else {
                axes[i] = match - labels;
            }
        }
    }

    return 0;
}

static int
unbuffered_loop_nop1_ndim2(NpyIter *iter)
{
    npy_intp coord, shape[2], strides[2][2];
    char *ptrs[2][2], *ptr;
    sum_of_products_fn sop;
    NPY_BEGIN_THREADS_DEF;

#if NPY_EINSUM_DBG_TRACING
    NpyIter_DebugPrint(iter);
#endif
    NPY_EINSUM_DBG_PRINT("running hand-coded 1-op 2-dim loop\n");

    NpyIter_GetShape(iter, shape);
    memcpy(strides[0], NpyIter_GetAxisStrideArray(iter, 0),
                                            2*sizeof(npy_intp));
    memcpy(strides[1], NpyIter_GetAxisStrideArray(iter, 1),
                                            2*sizeof(npy_intp));
    memcpy(ptrs[0], NpyIter_GetInitialDataPtrArray(iter),
                                            2*sizeof(char *));
    memcpy(ptrs[1], ptrs[0], 2*sizeof(char*));

    sop = get_sum_of_products_function(1,
                    NpyIter_GetDescrArray(iter)[0]->type_num,
                    NpyIter_GetDescrArray(iter)[0]->elsize,
                    strides[0]);

    if (sop == NULL) {
        PyErr_SetString(PyExc_TypeError,
                    "invalid data type for einsum");
        return -1;
    }

    /*
     * Since the iterator wasn't tracking coordinates, the
     * loop provided by the iterator is in Fortran-order.
     */
    NPY_BEGIN_THREADS_THRESHOLDED(shape[1] * shape[0]);
    for (coord = shape[1]; coord > 0; --coord) {
        sop(1, ptrs[0], strides[0], shape[0]);

        ptr = ptrs[1][0] + strides[1][0];
        ptrs[0][0] = ptrs[1][0] = ptr;
        ptr = ptrs[1][1] + strides[1][1];
        ptrs[0][1] = ptrs[1][1] = ptr;
    }
    NPY_END_THREADS;

    return 0;
}

static int
unbuffered_loop_nop1_ndim3(NpyIter *iter)
{
    npy_intp coords[2], shape[3], strides[3][2];
    char *ptrs[3][2], *ptr;
    sum_of_products_fn sop;
    NPY_BEGIN_THREADS_DEF;

#if NPY_EINSUM_DBG_TRACING
    NpyIter_DebugPrint(iter);
#endif
    NPY_EINSUM_DBG_PRINT("running hand-coded 1-op 3-dim loop\n");

    NpyIter_GetShape(iter, shape);
    memcpy(strides[0], NpyIter_GetAxisStrideArray(iter, 0),
                                            2*sizeof(npy_intp));
    memcpy(strides[1], NpyIter_GetAxisStrideArray(iter, 1),
                                            2*sizeof(npy_intp));
    memcpy(strides[2], NpyIter_GetAxisStrideArray(iter, 2),
                                            2*sizeof(npy_intp));
    memcpy(ptrs[0], NpyIter_GetInitialDataPtrArray(iter),
                                            2*sizeof(char *));
    memcpy(ptrs[1], ptrs[0], 2*sizeof(char*));
    memcpy(ptrs[2], ptrs[0], 2*sizeof(char*));

    sop = get_sum_of_products_function(1,
                    NpyIter_GetDescrArray(iter)[0]->type_num,
                    NpyIter_GetDescrArray(iter)[0]->elsize,
                    strides[0]);

    if (sop == NULL) {
        PyErr_SetString(PyExc_TypeError,
                    "invalid data type for einsum");
        return -1;
    }

    /*
     * Since the iterator wasn't tracking coordinates, the
     * loop provided by the iterator is in Fortran-order.
     */
    NPY_BEGIN_THREADS_THRESHOLDED(shape[2] * shape[1] * shape[0]);
    for (coords[1] = shape[2]; coords[1] > 0; --coords[1]) {
        for (coords[0] = shape[1]; coords[0] > 0; --coords[0]) {
            sop(1, ptrs[0], strides[0], shape[0]);

            ptr = ptrs[1][0] + strides[1][0];
            ptrs[0][0] = ptrs[1][0] = ptr;
            ptr = ptrs[1][1] + strides[1][1];
            ptrs[0][1] = ptrs[1][1] = ptr;
        }
        ptr = ptrs[2][0] + strides[2][0];
        ptrs[0][0] = ptrs[1][0] = ptrs[2][0] = ptr;
        ptr = ptrs[2][1] + strides[2][1];
        ptrs[0][1] = ptrs[1][1] = ptrs[2][1] = ptr;
    }
    NPY_END_THREADS;

    return 0;
}

static int
unbuffered_loop_nop2_ndim2(NpyIter *iter)
{
    npy_intp coord, shape[2], strides[2][3];
    char *ptrs[2][3], *ptr;
    sum_of_products_fn sop;
    NPY_BEGIN_THREADS_DEF;

#if NPY_EINSUM_DBG_TRACING
    NpyIter_DebugPrint(iter);
#endif
    NPY_EINSUM_DBG_PRINT("running hand-coded 2-op 2-dim loop\n");

    NpyIter_GetShape(iter, shape);
    memcpy(strides[0], NpyIter_GetAxisStrideArray(iter, 0),
                                            3*sizeof(npy_intp));
    memcpy(strides[1], NpyIter_GetAxisStrideArray(iter, 1),
                                            3*sizeof(npy_intp));
    memcpy(ptrs[0], NpyIter_GetInitialDataPtrArray(iter),
                                            3*sizeof(char *));
    memcpy(ptrs[1], ptrs[0], 3*sizeof(char*));

    sop = get_sum_of_products_function(2,
                    NpyIter_GetDescrArray(iter)[0]->type_num,
                    NpyIter_GetDescrArray(iter)[0]->elsize,
                    strides[0]);

    if (sop == NULL) {
        PyErr_SetString(PyExc_TypeError,
                    "invalid data type for einsum");
        return -1;
    }

    /*
     * Since the iterator wasn't tracking coordinates, the
     * loop provided by the iterator is in Fortran-order.
     */
    NPY_BEGIN_THREADS_THRESHOLDED(shape[1] * shape[0]);
    for (coord = shape[1]; coord > 0; --coord) {
        sop(2, ptrs[0], strides[0], shape[0]);

        ptr = ptrs[1][0] + strides[1][0];
        ptrs[0][0] = ptrs[1][0] = ptr;
        ptr = ptrs[1][1] + strides[1][1];
        ptrs[0][1] = ptrs[1][1] = ptr;
        ptr = ptrs[1][2] + strides[1][2];
        ptrs[0][2] = ptrs[1][2] = ptr;
    }
    NPY_END_THREADS;

    return 0;
}

static int
unbuffered_loop_nop2_ndim3(NpyIter *iter)
{
    npy_intp coords[2], shape[3], strides[3][3];
    char *ptrs[3][3], *ptr;
    sum_of_products_fn sop;
    NPY_BEGIN_THREADS_DEF;

#if NPY_EINSUM_DBG_TRACING
    NpyIter_DebugPrint(iter);
#endif
    NPY_EINSUM_DBG_PRINT("running hand-coded 2-op 3-dim loop\n");

    NpyIter_GetShape(iter, shape);
    memcpy(strides[0], NpyIter_GetAxisStrideArray(iter, 0),
                                            3*sizeof(npy_intp));
    memcpy(strides[1], NpyIter_GetAxisStrideArray(iter, 1),
                                            3*sizeof(npy_intp));
    memcpy(strides[2], NpyIter_GetAxisStrideArray(iter, 2),
                                            3*sizeof(npy_intp));
    memcpy(ptrs[0], NpyIter_GetInitialDataPtrArray(iter),
                                            3*sizeof(char *));
    memcpy(ptrs[1], ptrs[0], 3*sizeof(char*));
    memcpy(ptrs[2], ptrs[0], 3*sizeof(char*));

    sop = get_sum_of_products_function(2,
                    NpyIter_GetDescrArray(iter)[0]->type_num,
                    NpyIter_GetDescrArray(iter)[0]->elsize,
                    strides[0]);

    if (sop == NULL) {
        PyErr_SetString(PyExc_TypeError,
                    "invalid data type for einsum");
        return -1;
    }

    /*
     * Since the iterator wasn't tracking coordinates, the
     * loop provided by the iterator is in Fortran-order.
     */
    NPY_BEGIN_THREADS_THRESHOLDED(shape[2] * shape[1] * shape[0]);
    for (coords[1] = shape[2]; coords[1] > 0; --coords[1]) {
        for (coords[0] = shape[1]; coords[0] > 0; --coords[0]) {
            sop(2, ptrs[0], strides[0], shape[0]);

            ptr = ptrs[1][0] + strides[1][0];
            ptrs[0][0] = ptrs[1][0] = ptr;
            ptr = ptrs[1][1] + strides[1][1];
            ptrs[0][1] = ptrs[1][1] = ptr;
            ptr = ptrs[1][2] + strides[1][2];
            ptrs[0][2] = ptrs[1][2] = ptr;
        }
        ptr = ptrs[2][0] + strides[2][0];
        ptrs[0][0] = ptrs[1][0] = ptrs[2][0] = ptr;
        ptr = ptrs[2][1] + strides[2][1];
        ptrs[0][1] = ptrs[1][1] = ptrs[2][1] = ptr;
        ptr = ptrs[2][2] + strides[2][2];
        ptrs[0][2] = ptrs[1][2] = ptrs[2][2] = ptr;
    }
    NPY_END_THREADS;

    return 0;
}


/*NUMPY_API
 * This function provides summation of array elements according to
 * the Einstein summation convention.  For example:
 *  - trace(a)        -> einsum("ii", a)
 *  - transpose(a)    -> einsum("ji", a)
 *  - multiply(a,b)   -> einsum(",", a, b)
 *  - inner(a,b)      -> einsum("i,i", a, b)
 *  - outer(a,b)      -> einsum("i,j", a, b)
 *  - matvec(a,b)     -> einsum("ij,j", a, b)
 *  - matmat(a,b)     -> einsum("ij,jk", a, b)
 *
 * subscripts: The string of subscripts for einstein summation.
 * nop:        The number of operands
 * op_in:      The array of operands
 * dtype:      Either NULL, or the data type to force the calculation as.
 * order:      The order for the calculation/the output axes.
 * casting:    What kind of casts should be permitted.
 * out:        Either NULL, or an array into which the output should be placed.
 *
 * By default, the labels get placed in alphabetical order
 * at the end of the output. So, if c = einsum("i,j", a, b)
 * then c[i,j] == a[i]*b[j], but if c = einsum("j,i", a, b)
 * then c[i,j] = a[j]*b[i].
 *
 * Alternatively, you can control the output order or prevent
 * an axis from being summed/force an axis to be summed by providing
 * indices for the output. This allows us to turn 'trace' into
 * 'diag', for example.
 *  - diag(a)         -> einsum("ii->i", a)
 *  - sum(a, axis=0)  -> einsum("i...->", a)
 *
 * Subscripts at the beginning and end may be specified by
 * putting an ellipsis "..." in the middle.  For example,
 * the function einsum("i...i", a) takes the diagonal of
 * the first and last dimensions of the operand, and
 * einsum("ij...,jk...->ik...") takes the matrix product using
 * the first two indices of each operand instead of the last two.
 *
 * When there is only one operand, no axes being summed, and
 * no output parameter, this function returns a view
 * into the operand instead of making a copy.
 */
NPY_NO_EXPORT PyArrayObject *
PyArray_EinsteinSum(char *subscripts, npy_intp nop,
                    PyArrayObject **op_in,
                    PyArray_Descr *dtype,
                    NPY_ORDER order, NPY_CASTING casting,
                    PyArrayObject *out)
{
    int iop, label, min_label = 127, max_label = 0;
    char label_counts[128];
    char op_labels[NPY_MAXARGS][NPY_MAXDIMS];
    char output_labels[NPY_MAXDIMS], *iter_labels;
    int idim, ndim_output, ndim_broadcast, ndim_iter;

    PyArrayObject *op[NPY_MAXARGS], *ret = NULL;
    PyArray_Descr *op_dtypes_array[NPY_MAXARGS], **op_dtypes;

    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];
    int *op_axes[NPY_MAXARGS];
    npy_uint32 iter_flags, op_flags[NPY_MAXARGS];

    NpyIter *iter;
    sum_of_products_fn sop;
    npy_intp fixed_strides[NPY_MAXARGS];

    /* nop+1 (+1 is for the output) must fit in NPY_MAXARGS */
    if (nop >= NPY_MAXARGS) {
        PyErr_SetString(PyExc_ValueError,
                    "too many operands provided to einstein sum function");
        return NULL;
    }
    else if (nop < 1) {
        PyErr_SetString(PyExc_ValueError,
                    "not enough operands provided to einstein sum function");
        return NULL;
    }

    /* Parse the subscripts string into label_counts and op_labels */
    memset(label_counts, 0, sizeof(label_counts));
    for (iop = 0; iop < nop; ++iop) {
        int length = (int)strcspn(subscripts, ",-");

        if (iop == nop-1 && subscripts[length] == ',') {
            PyErr_SetString(PyExc_ValueError,
                        "more operands provided to einstein sum function "
                        "than specified in the subscripts string");
            return NULL;
        }
        else if(iop < nop-1 && subscripts[length] != ',') {
            PyErr_SetString(PyExc_ValueError,
                        "fewer operands provided to einstein sum function "
                        "than specified in the subscripts string");
            return NULL;
        }

        if (parse_operand_subscripts(subscripts, length,
                        PyArray_NDIM(op_in[iop]),
                        iop, op_labels[iop], label_counts,
                        &min_label, &max_label) < 0) {
            return NULL;
        }

        /* Move subscripts to the start of the labels for the next op */
        subscripts += length;
        if (iop < nop-1) {
            subscripts++;
        }
    }

    /*
     * Find the number of broadcast dimensions, which is the maximum
     * number of labels == 0 in an op_labels array.
     */
    ndim_broadcast = 0;
    for (iop = 0; iop < nop; ++iop) {
        npy_intp count_zeros = 0;
        int ndim;
        char *labels = op_labels[iop];

        ndim = PyArray_NDIM(op_in[iop]);
        for (idim = 0; idim < ndim; ++idim) {
            if (labels[idim] == 0) {
                ++count_zeros;
            }
        }

        if (count_zeros > ndim_broadcast) {
            ndim_broadcast = count_zeros;
        }
    }

    /*
     * If there is no output signature, fill output_labels and ndim_output
     * using each label that appeared once, in alphabetical order.
     */
    if (subscripts[0] == '\0') {
        /* If no output was specified, always broadcast left, as usual. */
        for (ndim_output = 0; ndim_output < ndim_broadcast; ++ndim_output) {
            output_labels[ndim_output] = 0;
        }
        for (label = min_label; label <= max_label; ++label) {
            if (label_counts[label] == 1) {
                if (ndim_output < NPY_MAXDIMS) {
                    output_labels[ndim_output++] = label;
                }
                else {
                    PyErr_SetString(PyExc_ValueError,
                                "einstein sum subscript string has too many "
                                "distinct labels");
                    return NULL;
                }
            }
        }
    }
    else {
        if (subscripts[0] != '-' || subscripts[1] != '>') {
            PyErr_SetString(PyExc_ValueError,
                        "einstein sum subscript string does not "
                        "contain proper '->' output specified");
            return NULL;
        }
        subscripts += 2;

        /* Parse the output subscript string. */
        ndim_output = parse_output_subscripts(subscripts, strlen(subscripts),
                                        ndim_broadcast, label_counts,
                                        output_labels);
        if (ndim_output < 0) {
            return NULL;
        }
    }

    if (out != NULL && PyArray_NDIM(out) != ndim_output) {
        PyErr_Format(PyExc_ValueError,
                "out parameter does not have the correct number of "
                "dimensions, has %d but should have %d",
                (int)PyArray_NDIM(out), (int)ndim_output);
        return NULL;
    }

    /* Set all the op references to NULL */
    for (iop = 0; iop < nop; ++iop) {
        op[iop] = NULL;
    }

    /*
     * Process all the input ops, combining dimensions into their
     * diagonal where specified.
     */
    for (iop = 0; iop < nop; ++iop) {
        char *labels = op_labels[iop];
        int combine, ndim;

        ndim = PyArray_NDIM(op_in[iop]);

        /*
         * If there's just one operand and no output parameter,
         * first try remapping the axes to the output to return
         * a view instead of a copy.
         */
        if (iop == 0 && nop == 1 && out == NULL) {
            ret = NULL;

            if (get_single_op_view(op_in[iop], iop, labels,
                                   ndim_output, output_labels,
                                   &ret) < 0) {
                return NULL;
            }

            if (ret != NULL) {
                return ret;
            }
        }

        /*
         * Check whether any dimensions need to be combined
         *
         * The char type may be either signed or unsigned, we
         * need it to be signed here.
         */
        combine = 0;
        for (idim = 0; idim < ndim; ++idim) {
            if ((signed char)labels[idim] < 0) {
                combine = 1;
            }
        }

        /* If any dimensions are combined, create a view which combines them */
        if (combine) {
            op[iop] = get_combined_dims_view(op_in[iop], iop, labels);
            if (op[iop] == NULL) {
                goto fail;
            }
        }
        /* No combining needed */
        else {
            Py_INCREF(op_in[iop]);
            op[iop] = op_in[iop];
        }
    }

    /* Set the output op */
    op[nop] = out;

    /*
     * Set up the labels for the iterator (output + combined labels).
     * Can just share the output_labels memory, because iter_labels
     * is output_labels with some more labels appended.
     */
    iter_labels = output_labels;
    ndim_iter = ndim_output;
    for (label = min_label; label <= max_label; ++label) {
        if (label_counts[label] > 0 &&
                memchr(output_labels, label, ndim_output) == NULL) {
            if (ndim_iter >= NPY_MAXDIMS) {
                PyErr_SetString(PyExc_ValueError,
                            "too many subscripts in einsum");
                goto fail;
            }
            iter_labels[ndim_iter++] = label;
        }
    }

    /* Set up the op_axes for the iterator */
    for (iop = 0; iop < nop; ++iop) {
        op_axes[iop] = op_axes_arrays[iop];

        if (prepare_op_axes(PyArray_NDIM(op[iop]), iop, op_labels[iop],
                    op_axes[iop], ndim_iter, iter_labels) < 0) {
            goto fail;
        }
    }

    /* Set up the op_dtypes if dtype was provided */
    if (dtype == NULL) {
        op_dtypes = NULL;
    }
    else {
        op_dtypes = op_dtypes_array;
        for (iop = 0; iop <= nop; ++iop) {
            op_dtypes[iop] = dtype;
        }
    }

    /* Set the op_axes for the output */
    op_axes[nop] = op_axes_arrays[nop];
    for (idim = 0; idim < ndim_output; ++idim) {
        op_axes[nop][idim] = idim;
    }
    for (idim = ndim_output; idim < ndim_iter; ++idim) {
        op_axes[nop][idim] = -1;
    }

    /* Set the iterator per-op flags */

    for (iop = 0; iop < nop; ++iop) {
        op_flags[iop] = NPY_ITER_READONLY|
                        NPY_ITER_NBO|
                        NPY_ITER_ALIGNED;
    }
    op_flags[nop] = NPY_ITER_READWRITE|
                    NPY_ITER_NBO|
                    NPY_ITER_ALIGNED|
                    NPY_ITER_ALLOCATE|
                    NPY_ITER_NO_BROADCAST;
    iter_flags = NPY_ITER_EXTERNAL_LOOP|
            NPY_ITER_BUFFERED|
            NPY_ITER_DELAY_BUFALLOC|
            NPY_ITER_GROWINNER|
            NPY_ITER_REDUCE_OK|
            NPY_ITER_REFS_OK|
            NPY_ITER_ZEROSIZE_OK;
    if (out != NULL) {
        iter_flags |= NPY_ITER_COPY_IF_OVERLAP;
    }
    if (dtype == NULL) {
        iter_flags |= NPY_ITER_COMMON_DTYPE;
    }

    /* Allocate the iterator */
    iter = NpyIter_AdvancedNew(nop+1, op, iter_flags, order, casting, op_flags,
                               op_dtypes, ndim_iter, op_axes, NULL, 0);

    if (iter == NULL) {
        goto fail;
    }

    /* Initialize the output to all zeros */
    ret = NpyIter_GetOperandArray(iter)[nop];
    if (PyArray_AssignZero(ret, NULL) < 0) {
        goto fail;
    }

    /***************************/
    /*
     * Acceleration for some specific loop structures. Note
     * that with axis coalescing, inputs with more dimensions can
     * be reduced to fit into these patterns.
     */
    if (!NpyIter_RequiresBuffering(iter)) {
        int ndim = NpyIter_GetNDim(iter);
        switch (nop) {
            case 1:
                if (ndim == 2) {
                    if (unbuffered_loop_nop1_ndim2(iter) < 0) {
                        goto fail;
                    }
                    goto finish;
                }
                else if (ndim == 3) {
                    if (unbuffered_loop_nop1_ndim3(iter) < 0) {
                        goto fail;
                    }
                    goto finish;
                }
                break;
            case 2:
                if (ndim == 2) {
                    if (unbuffered_loop_nop2_ndim2(iter) < 0) {
                        goto fail;
                    }
                    goto finish;
                }
                else if (ndim == 3) {
                    if (unbuffered_loop_nop2_ndim3(iter) < 0) {
                        goto fail;
                    }
                    goto finish;
                }
                break;
        }
    }
    /***************************/

    if (NpyIter_Reset(iter, NULL) != NPY_SUCCEED) {
        goto fail;
    }

    /*
     * Get an inner loop function, specializing it based on
     * the strides that are fixed for the whole loop.
     */
    NpyIter_GetInnerFixedStrideArray(iter, fixed_strides);
    sop = get_sum_of_products_function(nop,
                        NpyIter_GetDescrArray(iter)[0]->type_num,
                        NpyIter_GetDescrArray(iter)[0]->elsize,
                        fixed_strides);

#if NPY_EINSUM_DBG_TRACING
    NpyIter_DebugPrint(iter);
#endif

    /* Finally, the main loop */
    if (sop == NULL) {
        PyErr_SetString(PyExc_TypeError,
                    "invalid data type for einsum");
    }
    else if (NpyIter_GetIterSize(iter) != 0) {
        NpyIter_IterNextFunc *iternext;
        char **dataptr;
        npy_intp *stride;
        npy_intp *countptr;
        NPY_BEGIN_THREADS_DEF;

        iternext = NpyIter_GetIterNext(iter, NULL);
        if (iternext == NULL) {
            NpyIter_Deallocate(iter);
            goto fail;
        }
        dataptr = NpyIter_GetDataPtrArray(iter);
        stride = NpyIter_GetInnerStrideArray(iter);
        countptr = NpyIter_GetInnerLoopSizePtr(iter);

        NPY_BEGIN_THREADS_NDITER(iter);
        NPY_EINSUM_DBG_PRINT("Einsum loop\n");
        do {
            sop(nop, dataptr, stride, *countptr);
        } while(iternext(iter));
        NPY_END_THREADS;

        /* If the API was needed, it may have thrown an error */
        if (NpyIter_IterationNeedsAPI(iter) && PyErr_Occurred()) {
            goto fail;
        }
    }

finish:
    if (out != NULL) {
        ret = out;
    }
    Py_INCREF(ret);

    NpyIter_Deallocate(iter);
    for (iop = 0; iop < nop; ++iop) {
        Py_DECREF(op[iop]);
    }

    return ret;

fail:
    for (iop = 0; iop < nop; ++iop) {
        Py_XDECREF(op[iop]);
    }

    return NULL;
}

